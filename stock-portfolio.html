<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Financial Portfolio Tracker v6.1 - STOCKS & BONDS - FIXED</title>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
    <script src="https://unpkg.com/simple-statistics@7.8.3/dist/simple-statistics.min.js"></script>
    <script>
                // FINANCIAL PORTFOLIO TRACKER - STOCKS & BONDS
        const timestamp = new Date().getTime();
        console.log(`Financial Portfolio Tracker v6.0 loaded at ${timestamp} - STOCKS & BONDS`);
        

        

        
        // Force reload if on old ports or old versions
        if (window.location.href.includes('localhost:8000') || 
            window.location.href.includes('localhost:8001') || 
            window.location.href.includes('localhost:8002') || 
            window.location.href.includes('localhost:8003') ||
            window.location.href.includes('localhost:8004') ||
            window.location.href.includes('localhost:8005') ||
            window.location.href.includes('localhost:8006') ||
            window.location.href.includes('localhost:8007') ||
            window.location.href.includes('v=5.') ||
            window.location.href.includes('v=4.') ||
            window.location.href.includes('v=3.') ||
            window.location.href.includes('v=2.') ||
            window.location.href.includes('v=1.')) {
            console.error('Detected old version or port - redirecting to port 8009 with v6.0');
            const newUrl = window.location.href.replace(/localhost:800[0-8]/, 'localhost:8009').replace(/v=[0-9]+\.[0-9]+/, 'v=6.0');
            window.location.href = newUrl;
        }
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --bg-secondary: rgba(255, 255, 255, 0.95);
            --text-primary: #333;
            --text-secondary: #666;
            --text-light: #888;
            --card-bg: white;
            --card-border: #e1e5e9;
            --card-shadow: 0 4px 20px rgba(0,0,0,0.1);
            --input-bg: white;
            --input-border: #e1e5e9;
            --success-color: #2ed573;
            --error-color: #ff4757;
            --warning-color: #ffa502;
            --accent-color: #667eea;
            --accent-gradient: linear-gradient(135deg, #667eea, #764ba2);
        }

        [data-theme="dark"] {
            --bg-primary: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            --bg-secondary: rgba(20, 20, 35, 0.95);
            --text-primary: #ffffff;
            --text-secondary: #cccccc;
            --text-light: #999999;
            --card-bg: #1e1e2e;
            --card-border: #2a2a3a;
            --card-shadow: 0 4px 20px rgba(0,0,0,0.5);
            --input-bg: #2a2a3a;
            --input-border: #3a3a4a;
            --success-color: #00d4aa;
            --error-color: #ff6b6b;
            --warning-color: #ffd93d;
            --accent-color: #4ecdc4;
            --accent-gradient: linear-gradient(135deg, #4ecdc4, #44a08d);
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-primary);
            min-height: 100vh;
            color: var(--text-primary);
            transition: all 0.3s ease;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            color: white;
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        /* Dark Mode Toggle Button */
        .theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 50px;
            padding: 12px 20px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .theme-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }

        .theme-toggle.dark {
            background: linear-gradient(135deg, #2c3e50, #34495e);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .search-section {
            background: var(--bg-secondary);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: var(--card-shadow);
            position: relative;
            z-index: 10000;
        }

        .search-container {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            position: relative;
            z-index: 10001;
        }

        .search-input {
            flex: 1;
            min-width: 200px;
            padding: 15px 20px;
            border: 2px solid var(--input-border);
            border-radius: 12px;
            font-size: 16px;
            transition: all 0.3s ease;
            background: var(--input-bg);
            color: var(--text-primary);
        }

        .search-input:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .stock-preview {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--card-bg);
            border: 2px solid var(--accent-color);
            border-top: none;
            border-radius: 0 0 12px 12px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            z-index: 10002;
            max-height: 300px;
            overflow-y: auto;
            display: none;
            margin-top: 5px;
        }

        .stock-preview.show {
            display: block;
        }

        .preview-item {
            padding: 15px 20px;
            border-bottom: 1px solid var(--card-border);
            cursor: pointer;
            transition: background-color 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: var(--text-primary);
        }

        .preview-item:hover {
            background-color: var(--bg-secondary);
        }

        .preview-item:last-child {
            border-bottom: none;
        }

        .preview-item.selected {
            background-color: rgba(102, 126, 234, 0.1);
            border-left: 4px solid var(--accent-color);
        }

        .preview-symbol {
            font-weight: 700;
            font-size: 1.1rem;
            color: var(--text-primary);
        }

        .preview-company {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .preview-exchange {
            background: #667eea;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .preview-loading {
            padding: 20px;
            text-align: center;
            color: #666;
        }

        .preview-no-results {
            padding: 20px;
            text-align: center;
            color: #666;
            font-style: italic;
        }

        .preview-item.disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background-color: #f5f5f5;
        }

        .preview-item.disabled:hover {
            background-color: #f5f5f5;
        }

        .search-btn {
            padding: 15px 30px;
            background: var(--accent-gradient);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .search-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
        }

        .search-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .cors-help-btn {
            background: #ff6b6b;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 15px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            margin-left: 10px;
        }

        .cors-help-btn:hover {
            background: #ff5252;
            transform: scale(1.05);
        }

        .setup-server-btn {
            background: #2ed573;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 15px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            margin-left: 10px;
        }

        .setup-server-btn:hover {
            background: #26d0aa;
            transform: scale(1.05);
        }



        .date-filters {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .date-input {
            padding: 12px 15px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 14px;
        }

        .date-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .portfolio-section {
            background: var(--bg-secondary);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: var(--card-shadow);
            position: relative;
            z-index: 1;
            margin-top: 20px;
        }

        .portfolio-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .portfolio-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #333;
        }

        .clear-portfolio {
            padding: 8px 16px;
            background: #ff4757;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .clear-portfolio:hover {
            background: #ff3742;
        }

        .portfolio-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .stock-card {
            background: var(--card-bg);
            border-radius: 15px;
            padding: 20px;
            box-shadow: var(--card-shadow);
            transition: all 0.3s ease;
            border: 1px solid var(--card-border);
        }

        .stock-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 30px rgba(0,0,0,0.15);
        }

        .stock-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .stock-symbol {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        .remove-stock {
            background: none;
            border: none;
            color: #ff4757;
            cursor: pointer;
            font-size: 18px;
            padding: 5px;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .remove-stock:hover {
            background: #ff4757;
            color: white;
        }

        .stock-price {
            font-size: 2rem;
            font-weight: 700;
            color: var(--accent-color);
            margin-bottom: 10px;
        }

        .stock-change {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }

        .period-return {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 15px;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .period-details {
            background: rgba(102, 126, 234, 0.05);
            border-radius: 8px;
            padding: 12px;
            margin-top: 8px;
            margin-bottom: 15px;
            border-left: 3px solid #667eea;
        }

        .period-detail-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.85rem;
        }

        .period-detail-item:last-child {
            margin-bottom: 0;
        }

        .change-positive {
            color: #2ed573;
        }

        .change-negative {
            color: #ff4757;
        }

        .stock-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            font-size: 14px;
        }

        .detail-item {
            display: flex;
            justify-content: space-between;
        }

        .detail-label {
            color: var(--text-secondary);
            font-weight: 500;
        }

        .detail-value {
            font-weight: 600;
            color: var(--text-primary);
        }

        /* Mini chart icon and tooltip */
        .stock-price-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .mini-chart {
            position: relative;
            color: #667eea;
            cursor: pointer;
        }

        .mini-chart i {
            font-size: 1rem;
        }

        .mini-chart-tooltip {
            position: absolute;
            top: -8px;
            left: 24px;
            width: 320px;
            background: #ffffff;
            border-radius: 10px;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.15);
            padding: 10px;
            opacity: 0;
            transform: translateX(6px);
            transition: opacity 0.15s ease, transform 0.15s ease;
            pointer-events: none;
            z-index: 50;
        }

        .mini-chart:hover .mini-chart-tooltip {
            opacity: 1;
            transform: translateX(0);
            pointer-events: auto;
        }

        .mini-chart-tooltip svg {
            display: block;
            width: 100%;
            height: auto;
        }

        .mini-chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            margin-bottom: 6px;
            color: #333;
            font-weight: 600;
        }

        .mini-chart-meta {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            font-size: 11px;
            color: #666;
            margin-bottom: 8px;
        }

        /* Historical Adjusted Close Table */
        .adj-table-card {
            margin-top: 20px;
        }
        .adj-table-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .download-excel-btn {
            padding: 8px 12px;
            background: linear-gradient(135deg, #2ed573, #00b894);
            color: #fff;
            border: none;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            display: inline-flex;
            gap: 8px;
            align-items: center;
        }
        .download-excel-btn:hover {
            filter: brightness(0.95);
        }
        .adj-table-wrapper {
            position: relative;
            overflow: auto;
            max-height: 280px;
            border: 1px solid #e1e5e9;
            border-radius: 8px;
        }
        table.adj-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }
        .adj-table thead th {
            background: #f6f7fb;
            color: #333;
            font-weight: 600;
            text-align: right;
            padding: 8px 10px;
            border-bottom: 1px solid #e1e5e9;
            white-space: nowrap;
        }
        .adj-table thead th:first-child,
        .adj-table tbody td:first-child {
            text-align: left;
        }
        .adj-table tbody td {
            padding: 8px 10px;
            border-bottom: 1px solid #f0f0f0;
            text-align: right;
            white-space: nowrap;
        }
        .adj-table tbody tr:last-child td {
            border-bottom: none;
        }

        .adj-scroll-btn {
            position: absolute;
            right: 8px;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: #ffffff;
            border: 1px solid #e1e5e9;
            box-shadow: 0 6px 16px rgba(0,0,0,0.12);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #667eea;
            cursor: pointer;
            z-index: 2;
        }
        .adj-scroll-btn:hover { filter: brightness(0.98); }
        .adj-scroll-up { top: 8px; }
        .adj-scroll-down { bottom: 8px; }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Progress Bar Styles */
        .progress-container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            text-align: center;
        }

        .progress-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 20px;
        }

        .progress-bar-container {
            background: #f0f0f0;
            border-radius: 10px;
            height: 20px;
            margin: 20px 0;
            overflow: hidden;
            position: relative;
        }

        .progress-bar {
            background: linear-gradient(90deg, #667eea, #764ba2);
            height: 100%;
            border-radius: 10px;
            transition: width 0.3s ease;
            position: relative;
        }

        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .progress-text {
            font-size: 1rem;
            color: #666;
            margin-top: 10px;
        }

        .progress-details {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 15px;
            font-size: 0.9rem;
            color: #888;
        }

        .progress-current {
            font-weight: 600;
            color: #667eea;
        }

        .error {
            background: #ffe6e6;
            color: #d63031;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 4px solid #d63031;
        }

        .success {
            background: #e6ffe6;
            color: #00b894;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 4px solid #00b894;
        }

        .warning {
            background: #fff3cd;
            color: #856404;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 4px solid #ffc107;
        }

        .empty-portfolio {
            text-align: center;
            padding: 60px 20px;
            color: #666;
        }

        .empty-portfolio i {
            font-size: 4rem;
            color: #ddd;
            margin-bottom: 20px;
        }

        /* Analysis Section Styles */
        .analysis-section {
            background: var(--bg-secondary);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: var(--card-shadow);
        }

        .analysis-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .analysis-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .calculate-btn {
            padding: 12px 24px;
            background: linear-gradient(135deg, #2ed573, #00b894);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .calculate-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(46, 213, 115, 0.3);
        }

        .calculate-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            background: #ccc;
        }

        .analysis-results {
            min-height: 200px;
        }

        .empty-analysis {
            text-align: center;
            padding: 60px 20px;
            color: #666;
        }

        .empty-analysis i {
            font-size: 4rem;
            color: #ddd;
            margin-bottom: 20px;
        }

        .analysis-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .analysis-card {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            border: 1px solid #e1e5e9;
            display: block !important;
            margin-bottom: 20px;
            position: relative;
            z-index: 1;
        }

        .analysis-card h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.2rem;
            font-weight: 600;
        }

        .metric-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .metric-item:last-child {
            border-bottom: none;
        }

        .metric-label {
            color: #666;
            font-weight: 500;
        }

        .metric-value {
            font-weight: 600;
            color: #333;
        }

        .metric-value.positive {
            color: #2ed573;
        }

        .metric-value.negative {
            color: #ff4757;
        }

        .metric-value.high-risk {
            color: #ff6b35;
        }

        .metric-value.medium-risk {
            color: #ffa726;
        }

                 .metric-value.low-risk {
             color: #2ed573;
         }

         /* Stock Metrics Table Styles */
         .stock-metrics-table {
             border: 1px solid #e1e5e9;
             border-radius: 8px;
             overflow: hidden;
             margin-top: 15px;
             overflow-x: auto;
             min-width: 1000px;
         }

                   .table-header {
              display: grid;
              grid-template-columns: 1.4fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr;
              background: linear-gradient(135deg, #667eea, #764ba2);
              color: white;
              font-weight: 600;
          }

          .table-header .table-cell {
              cursor: pointer;
              user-select: none;
              transition: background-color 0.2s ease;
              position: relative;
          }

          .table-header .table-cell:hover {
              background-color: rgba(255, 255, 255, 0.1);
          }

                     .table-header .table-cell.sortable::after {
               content: '';
               position: absolute;
               right: 10px;
               opacity: 0;
               font-size: 0.8em;
               transition: opacity 0.2s ease;
           }

          .table-header .table-cell.sort-asc::after {
              content: '↑';
              opacity: 1;
          }

          .table-header .table-cell.sort-desc::after {
              content: '↓';
              opacity: 1;
          }

         .table-row {
             display: grid;
              grid-template-columns: 1.4fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr;
             border-bottom: 1px solid #e1e5e9;
             transition: background-color 0.2s ease;
         }

         .table-row:hover {
             background-color: #f8f9fa;
         }

         .table-row:last-child {
             border-bottom: none;
         }

         .table-cell {
             padding: 12px 15px;
             text-align: center;
             font-weight: 500;
         }

         .table-header .table-cell {
             font-weight: 600;
             text-align: center;
         }

         .stock-name {
             font-weight: 700;
             color: #333;
             text-align: left;
         }

        .portfolio-summary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .portfolio-summary h3 {
            color: white;
            margin-bottom: 15px;
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .summary-item {
            text-align: center;
        }

        .summary-value {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 5px;
        }

                 .summary-label {
             font-size: 0.9rem;
             opacity: 0.9;
         }

        .analysis-card.wide-card {
            grid-column: 1 / -1;
         }

        /* Sector Allocation Donut Chart Styles */
        .sector-allocation-card {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            border: 1px solid #e1e5e9;
            display: flex;
            flex-direction: column;
            grid-column: 1 / -1;
        }

        .sector-content {
            display: flex;
            align-items: center;
            gap: 30px;
        }

        .donut-section {
            flex: 1;
            display: flex;
            justify-content: center;
        }

        .sector-percentages {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .donut-chart-container {
            position: relative;
            width: 100%;
            height: 400px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 20px 0;
        }

        .donut-chart {
            position: relative;
            width: 350px;
            height: 350px;
        }

        .donut-segment {
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .donut-segment:hover {
            opacity: 0.8;
            transform: scale(1.02);
        }

        .sector-legend {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
        }

        .sector-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 0;
            font-size: 16px;
            border-bottom: 1px solid #f0f0f0;
        }

        .sector-item:last-child {
            border-bottom: none;
        }

        .sector-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .sector-name {
            font-weight: 500;
            color: #333;
            flex: 1;
        }

        .sector-percentage {
            font-weight: 600;
            color: #667eea;
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .search-container {
                flex-direction: column;
            }
            
            .date-filters {
                flex-direction: column;
                align-items: stretch;
            }
            
            .portfolio-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Cov Heatmap Styles */
        .cov-heatmap-container {
            width: 100%;
            height: 800px;
            border: 1px solid #e1e5e9;
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #fafafa;
        }
        .heatmaps-grid {
            display: flex;
            flex-direction: column;
            align-items: stretch;
        }
        .heatmap-card {
            width: 100%;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 20px;
            position: relative;
        }
        .heatmap-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }
        .heatmap-title {
            font-size: 16px;
            color: #333;
            margin: 0;
        }
        .heatmap-nav {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .heatmap-nav-btn {
            background: #007bff;
            color: white;
            border: none;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .heatmap-nav-btn:hover {
            background: #0056b3;
        }
        .heatmap-nav-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .heatmap-nav-indicator {
            font-size: 14px;
            color: #666;
            min-width: 80px;
            text-align: center;
        }
        /* Only stack on very narrow screens */
        @media (max-width: 520px) {
            .heatmaps-grid { flex-wrap: wrap; }
            .heatmap-card { flex: 1 1 100%; }
        }

        /* Efficient Frontier Styles */
        .portfolio-detail {
            background: #f8f9fa;
            border: 1px solid #e1e5e9;
            border-radius: 8px;
            padding: 15px;
        }

        .portfolio-detail h5 {
            margin: 0 0 10px 0;
             color: #333;
            font-size: 14px;
             font-weight: 600;
        }

        .portfolio-detail .metric {
             display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 12px;
        }

        .portfolio-detail .metric .label {
            color: #666;
        }

        .portfolio-detail .metric .value {
            font-weight: 600;
             color: #333;
         }

        .portfolio-detail .weights {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #e1e5e9;
        }

        .portfolio-detail .weights .weight-item {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            margin: 3px 0;
        }

        /* Tab Navigation Styles */
        .tab-navigation {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 10px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }

        .tab-btn {
            background: transparent;
            border: none;
            padding: 15px 30px;
            margin: 0 10px;
            border-radius: 15px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #666;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .tab-btn:hover {
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
        }

        .tab-btn.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .tab-btn i {
            font-size: 18px;
        }

        /* CLEAN TAB SYSTEM */
        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }



        /* Bond Analysis Styles */
        .bonds-header {
            text-align: center;
            margin-bottom: 40px;
            color: white;
        }

        .bonds-header h2 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .bonds-header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .bonds-search-section {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }

        .bonds-search-container {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .bond-filters {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .bonds-portfolio-section {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }

        .bonds-portfolio-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .bonds-analysis-section {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }

        .bonds-analysis-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        /* Bond Calculator Styles */
        .bond-calculator-section {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }

        [data-theme="dark"] .bond-calculator-section {
            background: rgba(20, 20, 35, 0.95);
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
        }

        .bond-calculator-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .bond-calculator-header h3 {
            font-size: 1.8rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
        }

        .bond-calculator-header p {
            color: #666;
            font-size: 1rem;
        }

        [data-theme="dark"] .bond-calculator-header h3 {
            color: #ffffff;
        }

        [data-theme="dark"] .bond-calculator-header p {
            color: #cccccc;
        }

        .bond-calculator-form {
            max-width: 100%;
        }

        .form-section {
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 15px;
            border-left: 4px solid #667eea;
        }

        [data-theme="dark"] .form-section {
            background: #1a1a2e;
            border-left: 4px solid #4ecdc4;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }

        .form-section h4 {
            font-size: 1.3rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        [data-theme="dark"] .form-section h4 {
            color: #ffffff;
        }

        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        .form-group label {
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        [data-theme="dark"] .form-group label {
            color: #ffffff;
        }

        .form-input {
            padding: 12px 15px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
            background: white;
        }

        .form-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        [data-theme="dark"] .form-input {
            background: #2a2a3a;
            border-color: #3a3a4a;
            color: #ffffff;
        }

        [data-theme="dark"] .form-input:focus {
            border-color: #4ecdc4;
            box-shadow: 0 0 0 3px rgba(78, 205, 196, 0.2);
        }

        .form-input:invalid {
            border-color: #ff4757;
        }

        .amortization-controls {
            margin-bottom: 20px;
        }

        .add-btn {
            background: linear-gradient(135deg, #2ed573, #00b894);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 10px 20px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .add-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(46, 213, 115, 0.3);
        }

        .amortization-schedule {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .amortization-entry {
            display: grid;
            grid-template-columns: 1fr 1fr auto;
            gap: 15px;
            align-items: end;
            padding: 15px;
            background: white;
            border-radius: 10px;
            border: 1px solid #e1e5e9;
        }

        .remove-btn {
            background: #ff4757;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .remove-btn:hover {
            background: #ff3742;
        }

        .form-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }

        .clear-btn {
            background: #ffa502;
            color: white;
            border: none;
            border-radius: 12px;
            padding: 12px 24px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .clear-btn:hover {
            background: #ff9500;
            transform: translateY(-2px);
        }

        .bond-results-section {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }

        [data-theme="dark"] .bond-results-section {
            background: rgba(20, 20, 35, 0.95);
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
        }

        .bond-results-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .bond-results-header h3 {
            font-size: 1.8rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
        }

        [data-theme="dark"] .bond-results-header h3 {
            color: #ffffff;
        }

        .bond-results-content {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .bond-metric-card {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            border: 1px solid #e1e5e9;
        }

        [data-theme="dark"] .bond-metric-card {
            background: #1e1e2e;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            border: 1px solid #2a2a3a;
        }

        .bond-metric-card h4 {
            font-size: 1.1rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        [data-theme="dark"] .bond-metric-card h4 {
            color: #ffffff;
        }

        .bond-metric-value {
            font-size: 2rem;
            font-weight: 700;
            color: #667eea;
            margin-bottom: 5px;
        }

        .bond-metric-label {
            font-size: 0.9rem;
            color: #666;
        }

        [data-theme="dark"] .bond-metric-value {
            color: #4ecdc4;
        }

        [data-theme="dark"] .bond-metric-label {
            color: #cccccc;
        }

        .bond-metric-description {
            font-size: 0.8rem;
            color: #888;
            margin-top: 10px;
            font-style: italic;
        }

        [data-theme="dark"] .bond-metric-description {
            color: #999999;
        }

        /* Bond Portfolio Styles */
        .empty-bond-portfolio {
            text-align: center;
            padding: 60px 20px;
            color: #666;
        }

        .empty-bond-portfolio i {
            font-size: 4rem;
            color: #ddd;
            margin-bottom: 20px;
        }

        [data-theme="dark"] .empty-bond-portfolio {
            color: #cccccc;
        }

        [data-theme="dark"] .empty-bond-portfolio i {
            color: #444444;
        }

        /* Bond Portfolio Table Styles */
        .bond-portfolio-table {
            width: 100%;
            border-collapse: collapse;
            background: var(--card-bg);
            border-radius: 15px;
            overflow: hidden;
            box-shadow: var(--card-shadow);
            border: 1px solid var(--card-border);
            margin-top: 20px;
            table-layout: fixed;
        }

        .bond-portfolio-table thead th {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            font-weight: 600;
            text-align: center;
            padding: 15px 12px;
            border-bottom: 2px solid rgba(255,255,255,0.1);
            white-space: nowrap;
            width: 16.66%;
        }

        .bond-portfolio-table thead th {
            text-align: center;
        }

        .bond-portfolio-table tbody tr {
            border-bottom: 1px solid var(--card-border);
            transition: background-color 0.2s ease;
        }

        .bond-portfolio-table tbody tr:hover {
            background-color: rgba(102, 126, 234, 0.05);
        }

        .bond-portfolio-table tbody tr:last-child {
            border-bottom: none;
        }

        .bond-portfolio-table tbody td {
            padding: 12px;
            text-align: center;
            color: #555;
            font-weight: 500;
            width: 16.66%;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .bond-portfolio-table tbody td:first-child {
            text-align: left;
            font-weight: 600;
        }

        .bond-portfolio-table .bond-actions {
            display: flex;
            gap: 8px;
            justify-content: center;
        }

        .bond-portfolio-table .bond-action-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 6px;
            border-radius: 50%;
            transition: all 0.3s ease;
            font-size: 14px;
            color: white;
        }

        .bond-portfolio-table .bond-action-btn:hover {
            background: rgba(255,255,255,0.2);
        }

        .bond-portfolio-table .bond-action-btn.compare {
            color: #4ecdc4;
        }

        .bond-portfolio-table .bond-action-btn.remove {
            color: #ff6b6b;
        }

        .bond-portfolio-table .bond-metric {
            font-weight: 600;
            color: #4ecdc4 !important;
        }

        .bond-portfolio-table .bond-metric-grey {
            font-weight: 600;
            color: #555;
        }

        /* Distribution Graphs Carousel Styles */
        .graphs-carousel {
            position: relative;
            max-width: 100%;
            margin: 0 auto;
            overflow: hidden;
        }

        .carousel-container {
            display: flex;
            transition: transform 0.5s ease-in-out;
            gap: 20px;
        }

        .graph-slide {
            min-width: 100%;
            flex-shrink: 0;
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }

        .carousel-nav {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 20px;
            gap: 15px;
        }

        .carousel-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .carousel-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .carousel-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .carousel-indicators {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-top: 15px;
        }

        .indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ddd;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .indicator.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            transform: scale(1.2);
        }

        .graph-title {
            text-align: center;
            margin-bottom: 20px;
            color: #333;
            font-size: 1.3rem;
            font-weight: 600;
        }

        .graph-container {
            position: relative;
            height: 400px;
            margin: 20px 0;
        }

        .distribution-legend {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 15px;
            font-size: 14px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 3px;
            border-radius: 2px;
        }

        .legend-actual {
            background: #ff6b6b;
        }

        .legend-normal {
            background: #667eea;
        }

        /* Stock Sector Information Styles */
        .stock-sector-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            padding: 8px 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .sector-badge {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            border-radius: 12px;
            color: white;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .sector-badge i {
            font-size: 0.7rem;
        }

        .portfolio-percentage {
            display: flex;
            align-items: center;
            gap: 4px;
            color: #667eea;
            font-weight: 600;
            font-size: 0.85rem;
        }

        .portfolio-percentage i {
            font-size: 0.75rem;
        }

        /* Dark mode adjustments for sector info */
        [data-theme="dark"] .stock-sector-info {
            border-bottom-color: #2a2a3a;
        }

        [data-theme="dark"] .portfolio-percentage {
            color: #4ecdc4;
        }

        .bond-portfolio-table .bond-date {
            font-size: 0.85rem;
            color: rgba(255,255,255,0.8);
        }

        .bond-portfolio-table .bond-company {
            color: #555;
            font-weight: 600;
            font-size: 0.85rem;
        }

        .bond-portfolio-table .bond-maturity {
            color: #555;
            font-size: 0.85rem;
        }

        /* Dark mode adjustments for bond table */
        [data-theme="dark"] .bond-portfolio-table {
            background: #1e1e2e;
            border: 1px solid #2a2a3a;
        }

        [data-theme="dark"] .bond-portfolio-table tbody tr:hover {
            background-color: rgba(78, 205, 196, 0.1);
        }

        /* Legacy bond card styles (kept for compatibility) */
        .bond-card {
            background: var(--card-bg);
            border-radius: 15px;
            padding: 20px;
            box-shadow: var(--card-shadow);
            border: 1px solid var(--card-border);
            transition: all 0.3s ease;
            position: relative;
        }

        .bond-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 30px rgba(0,0,0,0.15);
        }

        .bond-card.selected {
            border: 2px solid #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .bond-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .bond-company {
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        .bond-actions {
            display: flex;
            gap: 10px;
        }

        .bond-action-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .bond-action-btn:hover {
            background: #f0f0f0;
        }

        .bond-action-btn.compare {
            color: #667eea;
        }

        .bond-action-btn.remove {
            color: #ff4757;
        }

        .bond-metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }

        .bond-metric-item {
            text-align: center;
            padding: 10px;
            background: var(--bg-secondary);
            border-radius: 8px;
        }

        .bond-metric-value {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--accent-color);
            margin-bottom: 5px;
        }

        .bond-metric-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        /* Bond Comparison Styles */
        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .comparison-container {
            display: flex;
            flex-direction: column;
            gap: 30px;
        }

        .comparison-bond-card {
            background: var(--card-bg);
            border-radius: 15px;
            padding: 25px;
            box-shadow: var(--card-shadow);
            border: 1px solid var(--card-border);
        }

        .comparison-bond-header {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #f0f0f0;
        }

        .comparison-bond-company {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 5px;
        }

        .comparison-bond-details {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .comparison-metrics-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .comparison-metrics-table th,
        .comparison-metrics-table td {
            padding: 12px;
            text-align: center;
            border-bottom: 1px solid var(--card-border);
            color: var(--text-primary);
        }

        .comparison-metrics-table th {
            background: var(--bg-secondary);
            font-weight: 600;
            color: var(--text-primary);
        }

        .comparison-metrics-table td.better {
            background: rgba(46, 213, 115, 0.1);
            color: #2ed573;
            font-weight: 600;
        }

        .comparison-metrics-table td.worse {
            background: rgba(255, 71, 87, 0.1);
            color: #ff4757;
            font-weight: 600;
        }

        .comparison-charts {
            margin-top: 30px;
        }

        .comparison-chart-container {
            height: 400px;
            margin-bottom: 20px;
        }

        .comparison-summary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border-radius: 15px;
            padding: 20px;
            margin: 0;
            width: 100%;
        }

        [data-theme="dark"] .comparison-summary {
            background: linear-gradient(135deg, #2a2a3a, #1a1a2e);
            border: 1px solid #3a3a4a;
        }

        .comparison-summary h4 {
            color: white;
            margin-bottom: 15px;
        }

        .comparison-summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .comparison-summary-item {
            text-align: center;
        }

        .comparison-summary-value {
            font-size: 1.3rem;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .comparison-summary-label {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .bond-selection-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .bond-select {
            padding: 10px 15px;
            border: 2px solid var(--input-border);
            border-radius: 8px;
            font-size: 14px;
            min-width: 200px;
            background: var(--input-bg);
            color: var(--text-primary);
        }

        .bond-select:focus {
            outline: none;
            border-color: var(--accent-color);
        }

        .compare-bonds-btn {
            padding: 12px 24px;
            background: var(--accent-gradient);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .compare-bonds-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
        }

        .compare-bonds-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        /* Bond Calculator Title Section */
        .bond-calculator-title {
            text-align: center;
            margin: 40px 0 30px 0;
            padding: 25px;
            background: linear-gradient(135deg, #00b894 0%, #00a085 25%, #8e44ad 50%, #9b59b6 75%, #e056fd 100%);
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .bond-calculator-title h2 {
            color: white;
            font-size: 32px;
            font-weight: 700;
            margin: 0;
            text-shadow: 0 3px 6px rgba(0,0,0,0.5);
            letter-spacing: 1px;
        }

        .bond-calculator-title p {
            color: rgba(255,255,255,0.85);
            font-size: 16px;
            margin: 12px 0 0 0;
            font-weight: 400;
            letter-spacing: 0.5px;
        }

        [data-theme="dark"] .bond-calculator-title {
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 25%, #2a2a3a 50%, #ff6600 75%, #ff8533 100%);
            box-shadow: 0 8px 25px rgba(255, 102, 0, 0.25);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-left: 3px solid rgba(255, 102, 0, 0.3);
            border-right: 3px solid rgba(255, 102, 0, 0.3);
        }




    </style>
</head>
<body>
    <div class="container">
        <!-- Dark Mode Toggle Button -->
        <button id="themeToggle" class="theme-toggle">
            <i class="fas fa-moon"></i>
            <span>Dark Mode</span>
        </button>
        
        <div class="header">
            <h1><i class="fas fa-chart-line"></i> Financial Portfolio Tracker</h1>
            <p>Comprehensive investment analysis with stocks and bonds</p>
        </div>



        <!-- Stock Portfolio Tab -->
        <div class="tab-content active" id="stocks-tab">

        <!-- Stock Portfolio Content -->

        <div class="search-section">
            <div class="search-container">
                <input type="text" id="stockSearch" class="search-input" placeholder="Enter stock symbol (e.g., AAPL, MSFT, GOOGL)" maxlength="10">
                <button id="searchBtn" class="search-btn">
                    <i class="fas fa-search"></i> Search
                </button>
                <button id="corsHelpBtn" class="cors-help-btn" title="CORS Help">
                    <i class="fas fa-question-circle"></i>
                </button>
                <button id="setupLocalServerBtn" class="setup-server-btn" title="Setup Local Server">
                    <i class="fas fa-server"></i>
                </button>
                <div id="stockPreview" class="stock-preview">
                    <!-- Preview items will be populated here -->
                </div>
            </div>
            
            <div class="date-filters">
                <label for="startDate">Start Date:</label>
                <input type="date" id="startDate" class="date-input">
                
                <label for="endDate">End Date:</label>
                <input type="date" id="endDate" class="date-input">
                
                <button id="updateDataBtn" class="search-btn">
                    <i class="fas fa-sync-alt"></i> Update Data
                </button>


                
                <div id="realTimeLoading" class="progress-container" style="display: none; margin-left: 15px; padding: 15px; margin-bottom: 0;">
                    <div class="progress-title">Fetching Real-Time Data</div>
                    <div class="progress-bar-container">
                        <div class="progress-bar" style="width: 0%"></div>
                    </div>
                    <div class="progress-text">Preparing to fetch...</div>
                    <div class="progress-details">
                        <span class="progress-current">0</span>
                        <span>of 0 stocks</span>
                    </div>
                </div>
                
                <div id="marketStatus" class="market-status" style="margin-left: 15px; color: #333; font-size: 14px; font-weight: 500; display: inline-block;">
                    <i class="fas fa-clock"></i> Loading market status...
                </div>
            </div>
        </div>

        <div class="portfolio-section">
            <div class="portfolio-header">
                <h2 class="portfolio-title">Your Portfolio</h2>
                <button id="clearPortfolio" class="clear-portfolio">
                    <i class="fas fa-trash"></i> Clear All
                </button>
            </div>
            
            <div id="portfolioGrid" class="portfolio-grid">
                <div class="empty-portfolio">
                    <i class="fas fa-briefcase"></i>
                    <h3>Your portfolio is empty</h3>
                    <p>Search for stocks above to start building your portfolio</p>
                </div>
            </div>
        </div>

        <!-- Financial Analysis Section -->
        <div class="analysis-section">
            <div class="analysis-header">
                <h2 class="analysis-title">Financial Analysis</h2>
                <div>
                    <label style="font-size:12px;margin-right:8px;">Scale:</label>
                    <select id="scaleSelect" class="date-input" style="padding:6px 10px;">
                        <option value="daily" selected>Daily</option>
                        <option value="annualized">Annualized</option>
                    </select>
                    <label style="font-size:12px;margin:0 8px 0 12px;">VaR:</label>
                    <select id="varLevelSelect" class="date-input" style="padding:6px 10px;">
                        <option value="0.01">1%</option>
                        <option value="0.05" selected>5%</option>
                        <option value="0.10">10%</option>
                    </select>
                    <label style="font-size:12px;margin:0 8px 0 12px;">Risk Free Rate:</label>
                    <select id="riskFreeInput" class="date-input" style="padding:6px 10px;">
                        <option value="0.00">0.00%</option>
                        <option value="0.01">1.00%</option>
                        <option value="0.015">1.50%</option>
                        <option value="0.04" selected>4.00%</option>
                        <option value="0.025">2.50%</option>
                        <option value="0.03">3.00%</option>
                        <option value="0.035">3.50%</option>
                        <option value="0.04">4.00%</option>
                        <option value="0.045">4.50%</option>
                        <option value="0.05">5.00%</option>
                        <option value="0.055">5.50%</option>
                        <option value="0.06">6.00%</option>
                    </select>
                </div>
                <button id="calculateBtn" class="calculate-btn" disabled>
                    <i class="fas fa-calculator"></i> Calculate Analysis
                </button>
            </div>
            
            <div id="analysisResults" class="analysis-results">
                <div class="empty-analysis">
                    <i class="fas fa-chart-bar"></i>
                    <h3>No Analysis Available</h3>
                    <p>Add stocks to your portfolio and set date range to perform financial analysis</p>
                </div>
            </div>
        </div>

        <!-- Bond Calculator Title -->
        <div class="bond-calculator-title">
            <h2>🧮 Bond Calculator & Analysis</h2>
            <p>Professional fixed income securities analysis</p>
        </div>

        <!-- Bond Calculator Section -->
        <div id="bondCalculatorSection" class="analysis-section">
            <div class="bond-calculator-section">

                <div class="bond-calculator-form">
                    <!-- Bond Information Section -->
                    <div class="form-section">
                        <h4>ℹ️ Bond Information</h4>
                        <div class="form-grid">
                            <div class="form-group">
                                <label for="bondCompany">Company:</label>
                                <input type="text" id="bondCompany" class="form-input" placeholder="Enter company name">
                            </div>
                            <div class="form-group">
                                <label for="bondCoupon">Coupon Rate (%):</label>
                                <input type="number" id="bondCoupon" class="form-input" step="0.01" min="0" max="100" placeholder="e.g., 5.25">
                            </div>
                            <div class="form-group">
                                <label for="bondIssueDate">Issue Date:</label>
                                <input type="date" id="bondIssueDate" class="form-input">
                            </div>
                            <div class="form-group">
                                <label for="bondMaturityDate">Maturity Date:</label>
                                <input type="date" id="bondMaturityDate" class="form-input">
                            </div>
                            <div class="form-group">
                                <label for="bondFrequency">Frequency:</label>
                                <select id="bondFrequency" class="form-input">
                                    <option value="quarterly">Quarterly</option>
                                    <option value="semiannual" selected>Semiannual</option>
                                    <option value="annual">Annual</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label for="bondType">Type:</label>
                                <select id="bondType" class="form-input">
                                    <option value="bullet" selected>Bullet</option>
                                    <option value="partial">Partial Amortization</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Partial Amortization Section (Hidden by default) -->
                    <div class="form-section" id="partialAmortizationSection" style="display: none;">
                        <h4>📊 Partial Amortization Schedule</h4>
                        <div class="amortization-controls">
                            <button type="button" id="addAmortizationBtn" class="add-btn">
                                ➕ Add Amortization
                            </button>
                        </div>
                        <div id="amortizationSchedule" class="amortization-schedule">
                            <!-- Amortization entries will be added here dynamically -->
                        </div>
                    </div>

                    <!-- Investment Information Section -->
                    <div class="form-section">
                        <h4>💰 Investment Information</h4>
                        <div class="form-grid">
                            <div class="form-group">
                                <label for="bondInvestmentAmount">Investment Amount ($):</label>
                                <input type="number" id="bondInvestmentAmount" class="form-input" step="0.01" min="0" placeholder="e.g., 10000">
                            </div>
                            <div class="form-group">
                                <label for="bondLiquidationDate">Liquidation Date:</label>
                                <input type="date" id="bondLiquidationDate" class="form-input">
                            </div>
                            <div class="form-group">
                                <label for="bondInitialPrice">Initial Price (%):</label>
                                <input type="number" id="bondInitialPrice" class="form-input" step="0.01" min="0" max="200" placeholder="e.g., 100.00">
                            </div>
                            <div class="form-group">
                                <label for="bondActualPrice">Actual Price (%):</label>
                                <input type="number" id="bondActualPrice" class="form-input" step="0.01" min="0" max="200" placeholder="e.g., 105.50">
                            </div>
                        </div>
                    </div>

                    <!-- Calculate Button -->
                    <div class="form-actions">
                        <button id="calculateBondBtn" class="calculate-btn">
                            🧮 Calculate Bond Metrics
                        </button>
                        <button type="button" id="addToBondPortfolioBtn" class="calculate-btn" style="background: linear-gradient(135deg, #00b894, #00a085);">
                            ➕ Add to Bond Portfolio
                        </button>
                        <button type="button" id="clearBondBtn" class="clear-btn">
                            🗑️ Clear Form
                        </button>
                    </div>
                </div>
            </div>

            <!-- Bond Results Section -->
            <div id="bondResultsSection" class="bond-results-section" style="display: none;">
                <div id="bondResults" class="bond-results">
                    <!-- Results will be displayed here -->
                </div>
            </div>

            <!-- Bond Portfolio Section -->
            <div id="bondPortfolioSection" class="bond-results-section">
                <div class="bond-results-header">
                    <h3>📊 Bond Portfolio</h3>
                    <p>Manage your bonds for comparison analysis</p>
                </div>
                
                <div id="bondPortfolioGrid" class="bond-results-content">
                    <div class="empty-bond-portfolio">
                        <i class="fas fa-briefcase"></i>
                        <h3>Your bond portfolio is empty</h3>
                        <p>Calculate bond metrics above and add them to your portfolio for comparison</p>
                    </div>
                </div>

                <!-- Bond Selection Controls -->
                <div id="bondSelectionControls" class="bond-selection-controls" style="display: none;">
                    <label for="bond1Select">Select First Bond:</label>
                    <select id="bond1Select" class="bond-select">
                        <option value="">Choose a bond...</option>
                    </select>
                    
                    <label for="bond2Select">Select Second Bond:</label>
                    <select id="bond2Select" class="bond-select">
                        <option value="">Choose a bond...</option>
                    </select>
                    
                    <button id="compareBondsBtn" class="compare-bonds-btn" disabled>
                        🔍 Compare Bonds
                    </button>
                </div>

                <!-- Bond Comparison Section -->
                <div id="bondComparisonSection" class="bond-results-section" style="display: none; margin-top: 30px;">
                    <div class="bond-results-header">
                        <h3>🔍 Bond Comparison Analysis</h3>
                        <p>Side-by-side comparison of selected bonds</p>
                    </div>
                    
                    <div id="bondComparisonContent" class="bond-results-content">
                        <!-- Comparison content will be displayed here -->
                    </div>
                </div>
            </div>
        </div>





    <script>


        class StockPortfolio {
            constructor() {
                this.portfolio = new Map();
                this.bondPortfolio = new Map(); // Bond portfolio for comparison
                this.scaleMode = 'daily';
                this.lastAnalysisResults = null;
                this.riskFreeRateAnnual = 0.04; // decimal, default 4.00%
                this.currentHeatmapIndex = 0; // 0 = variance-covariance, 1 = correlation
                this.heatmapData = null; // Store heatmap data for switching
                this.varLevel = 0.05; // 5%
                this.pyodide = null; // Shared Pyodide instance
                this.pyodideLoading = false; // Prevent multiple loading attempts
                this.isDarkMode = false; // Dark mode state
                

                
                
                this.init();
            }

                        init() {
                this.setupEventListeners();
                this.loadPortfolio();
                this.setDefaultDates();
                this.updateMarketStatus();
                this.setupBondEventListeners();
                this.setDefaultBondDates();
                this.initDarkMode();
            }

            setupEventListeners() {
                // Stock portfolio event listeners
                document.getElementById('searchBtn').addEventListener('click', () => this.searchStock());
                document.getElementById('corsHelpBtn').addEventListener('click', () => this.showCORSHelp('general'));
                document.getElementById('setupLocalServerBtn').addEventListener('click', () => this.setupLocalServer());
                document.getElementById('stockSearch').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.searchStock();
                });
                document.getElementById('stockSearch').addEventListener('input', (e) => this.handleSearchInput(e));
                document.getElementById('stockSearch').addEventListener('focus', () => this.showPreview());
                document.getElementById('stockSearch').addEventListener('blur', () => this.hidePreview());
                document.getElementById('updateDataBtn').addEventListener('click', () => this.updateAllStocks());

                // Heatmap navigation event listeners will be set up when heatmaps are rendered

                document.getElementById('clearPortfolio').addEventListener('click', () => this.clearPortfolio());
                document.getElementById('calculateBtn').addEventListener('click', async () => {
                    await this.preparePythonPackages();
                    this.calculateAnalysis();
                });
                const scaleSelect = document.getElementById('scaleSelect');
                scaleSelect.addEventListener('change', (e) => {
                    this.scaleMode = e.target.value;
                    if (this.lastAnalysisResults) {
                        this.displayAnalysisResults(this.lastAnalysisResults);
                    }
                });
                const varLevelSelect = document.getElementById('varLevelSelect');
                varLevelSelect.addEventListener('change', (e) => {
                    this.varLevel = parseFloat(e.target.value);
                    if (this.lastAnalysisResults) {
                        this.displayAnalysisResults(this.lastAnalysisResults);
                    }
                });
                const riskFreeInput = document.getElementById('riskFreeInput');
                riskFreeInput.addEventListener('change', (e) => {
                    const val = parseFloat(e.target.value);
                    this.riskFreeRateAnnual = isNaN(val) ? 0 : val;
                    if (this.lastAnalysisResults) {
                        this.displayAnalysisResults(this.lastAnalysisResults);
                    }
                });
                
                // Handle stock preview clicks using event delegation
                document.getElementById('stockPreview').addEventListener('click', (e) => {
                    const previewItem = e.target.closest('.preview-item');
                    if (previewItem && !previewItem.classList.contains('disabled')) {
                        const symbol = previewItem.getAttribute('data-symbol');
                        if (symbol) {
                            console.log('Stock selected from preview:', symbol);
                            this.selectStockFromPreview(symbol).catch(error => {
                                console.error('Error selecting stock from preview:', error);
                            });
                        }
                    }
                });
                
                // Close preview when clicking outside
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('.search-container')) {
                        this.hidePreview();
                    }
                });
                
                // Dark mode toggle
                document.getElementById('themeToggle').addEventListener('click', () => this.toggleDarkMode());
            }

            async preparePythonPackages() {
                return await this.ensurePyodideAndPackages();
            }

            setDefaultDates() {
                // Set default dates: 01/02/2020 - 07/25/2025
                const startDate = new Date('2020-01-02');
                const endDate = new Date('2025-07-25');
                
                document.getElementById('startDate').value = startDate.toISOString().split('T')[0];
                document.getElementById('endDate').value = endDate.toISOString().split('T')[0];
                
                // Add event listeners for date changes
                document.getElementById('startDate').addEventListener('change', () => this.updateCalculateButton());
                document.getElementById('endDate').addEventListener('change', () => this.updateCalculateButton());
            }

            async searchStock() {
                const symbol = document.getElementById('stockSearch').value.trim().toUpperCase();
                if (!symbol) {
                    this.showError('Please enter a stock symbol');
                    return;
                }

                if (this.portfolio.has(symbol)) {
                    this.showError('This stock is already in your portfolio');
                    return;
                }

                // Show progress bar for single stock
                this.showProgressBar('Adding Stock to Portfolio', 1);
                this.updateProgress(0, 1, `Fetching data for ${symbol}...`);
                
                try {
                    const stockData = await this.fetchStockData(symbol);
                    this.updateProgress(1, 1, `Adding ${symbol} to portfolio...`);
                    if (stockData) {
                        await this.addToPortfolio(symbol, stockData);
                        document.getElementById('stockSearch').value = '';
                        this.hidePreview();
                        this.hideProgressBar();
                        this.showSuccess(`Added ${symbol} to your portfolio`);
                    }
                } catch (error) {
                    this.hideProgressBar();
                    this.showError(`Error fetching data for ${symbol}: ${error.message}`);
                }
            }

            // Stock Preview Methods
            handleSearchInput(e) {
                const query = e.target.value.trim();
                if (query.length >= 2) {
                    this.searchStocks(query);
                } else {
                    this.hidePreview();
                }
            }

            showPreview() {
                const query = document.getElementById('stockSearch').value.trim();
                if (query.length >= 2) {
                    this.searchStocks(query);
                }
            }

            hidePreview() {
                const preview = document.getElementById('stockPreview');
                preview.classList.remove('show');
            }

            async searchStocks(query) {
                const preview = document.getElementById('stockPreview');
                preview.innerHTML = '<div class="preview-loading"><i class="fas fa-spinner fa-spin"></i> Searching...</div>';
                preview.classList.add('show');

                try {
                    const results = await this.fetchStockSuggestions(query);
                    this.displayStockSuggestions(results);
                } catch (error) {
                    preview.innerHTML = '<div class="preview-no-results">No stocks found</div>';
                }
            }

            async fetchStockSuggestions(query) {
                // Using Yahoo Finance search API
                const url = `https://query1.finance.yahoo.com/v1/finance/search?q=${encodeURIComponent(query)}&quotesCount=5&newsCount=0`;
                
                try {
                    const response = await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(url)}`);
                    const data = await response.json();
                    
                    if (!data.contents) {
                        return [];
                    }

                    const yahooData = JSON.parse(data.contents);
                    return yahooData.quotes || [];
                } catch (error) {
                    console.error('Error fetching stock suggestions:', error);
                    return [];
                }
            }

            displayStockSuggestions(stocks) {
                const preview = document.getElementById('stockPreview');
                
                if (stocks.length === 0) {
                    preview.innerHTML = '<div class="preview-no-results">No stocks found</div>';
                    return;
                }

                let html = '';
                stocks.forEach((stock, index) => {
                    const isInPortfolio = this.portfolio.has(stock.symbol);
                    const disabledClass = isInPortfolio ? 'disabled' : '';
                    const disabledText = isInPortfolio ? ' (In Portfolio)' : '';
                    
                    html += `
                        <div class="preview-item ${disabledClass}" data-symbol="${stock.symbol}">
                            <div>
                                <div class="preview-symbol">${stock.symbol}${disabledText}</div>
                                <div class="preview-company">${stock.shortname || stock.longname || 'Unknown Company'}</div>
                            </div>
                            <div class="preview-exchange">${stock.exchange || 'N/A'}</div>
                        </div>
                    `;
                });

                preview.innerHTML = html;
            }

            async selectStockFromPreview(symbol) {
                if (this.portfolio.has(symbol)) {
                    this.showError('This stock is already in your portfolio');
                    return;
                }

                // Clear the search input and hide preview immediately
                document.getElementById('stockSearch').value = '';
                this.hidePreview();
                
                // Show progress bar for single stock
                this.showProgressBar('Adding Stock to Portfolio', 1);
                this.updateProgress(0, 1, `Fetching data for ${symbol}...`);
                
                try {
                    const stockData = await this.fetchStockData(symbol);
                    this.updateProgress(1, 1, `Adding ${symbol} to portfolio...`);
                    if (stockData) {
                        await this.addToPortfolio(symbol, stockData);
                        this.hideProgressBar();
                        this.showSuccess(`Added ${symbol} to your portfolio`);
                    }
                } catch (error) {
                    this.hideProgressBar();
                    this.showError(`Error fetching data for ${symbol}: ${error.message}`);
                }
            }

            async fetchStockData(symbol) {
                const startDate = document.getElementById('startDate').value;
                const endDate = document.getElementById('endDate').value;
                
                if (!startDate || !endDate) {
                    throw new Error('Please select both start and end dates');
                }

                // Add current timestamp to avoid caching
                const currentTimestamp = Math.floor(Date.now() / 1000);
                
                // Try Yahoo Finance with multiple proxies and alternatives
                // Note: Most public CORS proxies are currently blocked
                const proxyUrls = [
                    `https://api.allorigins.win/raw?url=`,
                    `https://api.allorigins.win/get?url=`,
                    `https://thingproxy.freeboard.io/fetch/`,
                    `https://cors-anywhere.herokuapp.com/`
                ];
                
                // Alternative data sources that might work better
                const alternativeUrls = [
                    `https://query2.finance.yahoo.com/v10/finance/chart/${symbol}?period1=${this.dateToTimestamp(startDate)}&period2=${this.dateToTimestamp(endDate)}&interval=1d&includeAdjustedClose=true&includePrePost=true&_t=${currentTimestamp}`,
                    `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?period1=${this.dateToTimestamp(startDate)}&period2=${this.dateToTimestamp(endDate)}&interval=1d&includeAdjustedClose=true&includePrePost=true&_t=${currentTimestamp}`,
                    `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?period1=${this.dateToTimestamp(startDate)}&period2=${this.dateToTimestamp(endDate)}&interval=1m&includeAdjustedClose=true&includePrePost=true&_t=${currentTimestamp}`
                ];
                
                const yahooUrls = [
                    `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?period1=${this.dateToTimestamp(startDate)}&period2=${this.dateToTimestamp(endDate)}&interval=1d&includeAdjustedClose=true&includePrePost=true&_t=${currentTimestamp}`,
                    `https://query2.finance.yahoo.com/v10/finance/chart/${symbol}?period1=${this.dateToTimestamp(startDate)}&period2=${this.dateToTimestamp(endDate)}&interval=1d&includeAdjustedClose=true&includePrePost=true&_t=${currentTimestamp}`,
                    `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?period1=${this.dateToTimestamp(startDate)}&period2=${this.dateToTimestamp(endDate)}&interval=1m&includeAdjustedClose=true&includePrePost=true&_t=${currentTimestamp}`
                ];
                
                let lastError = null;
                
                // Try each Yahoo URL with each proxy
                for (const yahooUrl of yahooUrls) {
                    for (const proxyUrl of proxyUrls) {
                        try {
                            const proxyName = proxyUrl.split('//')[1].split('/')[0];
                            console.log(`Trying ${proxyName} with ${yahooUrl.split('/')[2]}...`);
                            const fullUrl = proxyUrl + encodeURIComponent(yahooUrl);
                            
                            // Add timeout promise
                            const timeoutPromise = new Promise((_, reject) => 
                                setTimeout(() => reject(new Error('Timeout')), 5000)
                            );
                            
                            const fetchPromise = fetch(fullUrl, {
                                method: 'GET',
                                headers: {
                                    'Accept': 'application/json',
                                    'Content-Type': 'application/json'
                                }
                            });
                            
                            const response = await Promise.race([fetchPromise, timeoutPromise]);
                            
                            if (response.ok) {
                                const data = await response.json();
                                
                                // Handle different proxy response formats
                                let yahooData;
                                if (data.contents) {
                                    try {
                                        yahooData = JSON.parse(data.contents);
                                    } catch (parseError) {
                                        console.warn(`Failed to parse proxy response from ${proxyName}`);
                                        continue; // Try next proxy
                                    }
                                } else if (data.chart) {
                                    yahooData = data;
                                } else {
                                    console.warn(`Unexpected response format from ${proxyName}`);
                                    continue; // Try next proxy
                                }
                                
                                if (yahooData.chart && yahooData.chart.result && yahooData.chart.result[0]) {
                                    console.log(`✅ Yahoo Finance succeeded via ${proxyName}`);
                                    return this.processYahooData(yahooData, symbol);
                                } else {
                                    console.warn(`No valid chart data from ${proxyName}`);
                                }
                            } else {
                                console.warn(`${proxyName} returned HTTP ${response.status}`);
                            }
                        } catch (error) {
                            const proxyName = proxyUrl.split('//')[1].split('/')[0];
                            console.warn(`${proxyName} failed:`, error.message);
                            lastError = error;
                            continue; // Try next proxy
                        }
                    }
                }

                
                // Try direct API call as last resort (might work in some browsers)
                console.log('Trying direct API call as last resort...');
                try {
                    const directUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?period1=${this.dateToTimestamp(startDate)}&period2=${this.dateToTimestamp(endDate)}&interval=1d&includeAdjustedClose=true&includePrePost=true&_t=${currentTimestamp}`;
                    const response = await fetch(directUrl, {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/json',
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    if (response.ok) {
                        const yahooData = await response.json();
                        if (yahooData.chart && yahooData.chart.result && yahooData.chart.result[0]) {
                            console.log('✅ Direct API call succeeded!');
                            return this.processYahooData(yahooData, symbol);
                        }
                    }
                } catch (directError) {
                    console.warn('Direct API call also failed:', directError.message);
                }
                
                // Try alternative Yahoo endpoints
                console.log('Trying alternative Yahoo endpoints...');
                const alternativeEndpoints = [
                    `https://query2.finance.yahoo.com/v10/finance/chart/${symbol}?period1=${this.dateToTimestamp(startDate)}&period2=${this.dateToTimestamp(endDate)}&interval=1d&includeAdjustedClose=true&_t=${currentTimestamp}`,
                    `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?period1=${this.dateToTimestamp(startDate)}&period2=${this.dateToTimestamp(endDate)}&interval=1m&includeAdjustedClose=true&_t=${currentTimestamp}`
                ];
                
                for (const endpoint of alternativeEndpoints) {
                    try {
                        const response = await fetch(endpoint, {
                            method: 'GET',
                            headers: {
                                'Accept': 'application/json',
                                'Content-Type': 'application/json'
                            }
                        });
                        
                        if (response.ok) {
                            const yahooData = await response.json();
                            if (yahooData.chart && yahooData.chart.result && yahooData.chart.result[0]) {
                                console.log('✅ Alternative endpoint succeeded!');
                                return this.processYahooData(yahooData, symbol);
                            }
                        }
                    } catch (altError) {
                        console.warn('Alternative endpoint failed:', altError.message);
                    }
                }
                
                // Try alternative data sources before falling back to mock data
                console.log('Trying alternative data sources...');
                
                // Try Alpha Vantage as fallback
                try {
                    const alphaVantageData = await this.fetchAlphaVantageData(symbol, startDate, endDate);
                    if (alphaVantageData) {
                        console.log(`✅ Alpha Vantage succeeded for ${symbol}`);
                        return alphaVantageData;
                    }
                } catch (alphaError) {
                    console.warn('Alpha Vantage failed:', alphaError.message);
                }
                
                // Try IEX Cloud as fallback
                try {
                    const iexData = await this.fetchIEXData(symbol, startDate, endDate);
                    if (iexData) {
                        console.log(`✅ IEX Cloud succeeded for ${symbol}`);
                        return iexData;
                    }
                } catch (iexError) {
                    console.warn('IEX Cloud failed:', iexError.message);
                }
                
                // If all methods failed, generate realistic mock data
                console.warn('All methods failed, generating realistic mock data for:', symbol);
                this.showCORSHelp(symbol);
                return this.generateRealisticStockData(symbol, startDate, endDate);
            }

            generateRealisticStockData(symbol, startDate, endDate) {
                // Generate realistic stock data for demonstration
                const start = new Date(startDate);
                const end = new Date(endDate);
                const days = Math.ceil((end - start) / (1000 * 60 * 60 * 24));
                
                // Base price varies by symbol
                const basePrice = this.getBasePriceForSymbol(symbol);
                const volatility = 0.02; // 2% daily volatility
                
                console.log(`📊 Generating realistic data for ${symbol}:`);
                console.log(`   Base Price: $${basePrice.toFixed(2)}`);
                console.log(`   Period: ${days} days`);
                console.log(`   Volatility: ${(volatility * 100).toFixed(1)}% daily`);
                
                const prices = [];
                const timestamps = [];
                const volumes = [];
                
                let currentPrice = basePrice;
                const startTimestamp = Math.floor(start.getTime() / 1000);
                
                for (let i = 0; i < days; i++) {
                    // Random walk with drift
                    const dailyReturn = (Math.random() - 0.5) * volatility;
                    currentPrice *= (1 + dailyReturn);
                    
                    prices.push(Math.max(currentPrice, 0.01)); // Ensure positive price
                    timestamps.push(startTimestamp + (i * 24 * 60 * 60));
                    volumes.push(Math.floor(Math.random() * 1000000) + 100000); // Random volume
                }
                
                const latestIndex = prices.length - 1;
                const previousIndex = Math.max(0, latestIndex - 1);

                    return {
                        symbol: symbol,
                    price: prices[latestIndex],
                    change: prices[latestIndex] - prices[previousIndex],
                    changePercent: ((prices[latestIndex] - prices[previousIndex]) / prices[previousIndex]) * 100,
                        volume: volumes[latestIndex],
                    high: Math.max(...prices),
                    low: Math.min(...prices),
                    open: prices[0],
                    close: prices[latestIndex],
                        timestamp: timestamps[latestIndex],
                    historicalData: prices,
                        timestamps: timestamps
                    };
            }

            getBasePriceForSymbol(symbol) {
                // Return realistic base prices for common symbols
                const basePrices = {
                    'AAPL': 150, 'MSFT': 300, 'GOOGL': 2500, 'AMZN': 3000,
                    'TSLA': 800, 'META': 300, 'NVDA': 500, 'NFLX': 500,
                    'PAM': 800, 'BMA': 400, 'YPF': 1200, 'GGAL': 200,
                    'TEO': 150, 'TGS': 300, 'CRESY': 10, 'EDN': 50,
                    'LOMA': 80, 'SUPV': 30, 'AGRO': 15, 'CEPU': 200,
                    'MELI': 1500, 'BBAR': 300, 'IRS': 200
                };
                return basePrices[symbol.toUpperCase()] || 100; // Default price
            }

            async fetchAlphaVantageData(symbol, startDate, endDate) {
                // Alpha Vantage API (free tier: 5 calls per minute, 500 per day)
                const apiKey = 'demo'; // Use 'demo' for testing, or get free key from alphavantage.co
                const url = `https://www.alphavantage.co/query?function=TIME_SERIES_DAILY&symbol=${symbol}&apikey=${apiKey}&outputsize=compact`;
                
                try {
                    const response = await fetch(url);
                    if (response.ok) {
                        const data = await response.json();
                        
                        if (data['Time Series (Daily)']) {
                            const timeSeries = data['Time Series (Daily)'];
                            const dates = Object.keys(timeSeries).sort();
                            const prices = [];
                            const volumes = [];
                            const timestamps = [];
                            
                            for (const date of dates) {
                                const dailyData = timeSeries[date];
                                prices.push(parseFloat(dailyData['4. close']));
                                volumes.push(parseInt(dailyData['5. volume']));
                                timestamps.push(new Date(date).getTime() / 1000);
                            }
                            
                            const latestIndex = prices.length - 1;
                            const previousIndex = Math.max(0, latestIndex - 1);
                            
                            return {
                                symbol: symbol,
                                price: prices[latestIndex],
                                change: prices[latestIndex] - prices[previousIndex],
                                changePercent: ((prices[latestIndex] - prices[previousIndex]) / prices[previousIndex]) * 100,
                                volume: volumes[latestIndex],
                                high: Math.max(...prices),
                                low: Math.min(...prices),
                                open: prices[0],
                                close: prices[latestIndex],
                                timestamp: timestamps[latestIndex],
                                historicalData: prices,
                                timestamps: timestamps,
                                lastUpdate: new Date(),
                                dataAge: 0,
                                isRealData: true,
                                isAskPrice: false
                            };
                        }
                    }
                } catch (error) {
                    console.warn('Alpha Vantage error:', error.message);
                }
                return null;
            }

            async fetchIEXData(symbol, startDate, endDate) {
                // IEX Cloud API (free tier: 50,000 messages per month)
                const apiKey = 'pk_test_'; // Use test key for demo, or get free key from iexcloud.io
                const url = `https://cloud.iexapis.com/stable/stock/${symbol}/chart/1m?token=${apiKey}`;
                
                try {
                    const response = await fetch(url);
                    if (response.ok) {
                        const data = await response.json();
                        
                        if (data && data.length > 0) {
                            const prices = data.map(item => item.close);
                            const volumes = data.map(item => item.volume);
                            const timestamps = data.map(item => new Date(item.date).getTime() / 1000);
                            
                            const latestIndex = prices.length - 1;
                            const previousIndex = Math.max(0, latestIndex - 1);
                            
                            return {
                                symbol: symbol,
                                price: prices[latestIndex],
                                change: prices[latestIndex] - prices[previousIndex],
                                changePercent: ((prices[latestIndex] - prices[previousIndex]) / prices[previousIndex]) * 100,
                                volume: volumes[latestIndex],
                                high: Math.max(...prices),
                                low: Math.min(...prices),
                                open: prices[0],
                                close: prices[latestIndex],
                                timestamp: timestamps[latestIndex],
                                historicalData: prices,
                                timestamps: timestamps,
                                lastUpdate: new Date(),
                                dataAge: 0,
                                isRealData: true,
                                isAskPrice: false
                            };
                        }
                    }
                } catch (error) {
                    console.warn('IEX Cloud error:', error.message);
                }
                return null;
            }

            showCORSHelp(symbol) {
                const isGeneral = symbol === 'general';
                const helpMessage = `
                    <div style="background: linear-gradient(135deg, #ff6b6b, #ee5a24); color: white; padding: 25px; border-radius: 15px; margin: 20px 0; box-shadow: 0 8px 32px rgba(0,0,0,0.2); border: 2px solid rgba(255,255,255,0.1);">
                        <h4 style="margin: 0 0 20px 0; font-size: 20px; text-align: center;">
                            <i class="fas fa-exclamation-triangle"></i> CORS Issue Detected - Immediate Action Required
                        </h4>
                        <p style="margin: 0 0 20px 0; opacity: 0.95; text-align: center; font-size: 16px;">
                            ${isGeneral ? 'All public CORS proxies are currently blocked. Real-time data requires immediate setup.' : `Using realistic data for <strong>${symbol}</strong>. All public CORS proxies are blocked.`}
                        </p>
                        
                        <div style="background: rgba(255,255,255,0.15); padding: 20px; border-radius: 10px; margin: 15px 0;">
                            <h5 style="margin: 0 0 15px 0; font-size: 18px; text-align: center;">🚀 IMMEDIATE SOLUTIONS (Try in order):</h5>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                                <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px;">
                                    <h6 style="margin: 0 0 10px 0; font-size: 16px; color: #fdcb6e;">1. CORS Unblock Extension</h6>
                                    <p style="margin: 0; font-size: 14px; opacity: 0.9;">
                                        Install "CORS Unblock" extension for Chrome/Firefox. 
                                        <br><strong>Most effective solution!</strong>
                                    </p>
                                </div>
                                <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px;">
                                    <h6 style="margin: 0 0 10px 0; font-size: 16px; color: #fdcb6e;">2. Local Server</h6>
                                    <p style="margin: 0; font-size: 14px; opacity: 0.9;">
                                        Open terminal in this folder and run:<br>
                                        <code style="background: rgba(0,0,0,0.3); padding: 5px; border-radius: 4px;">python -m http.server 8000</code><br>
                                        Then open: <code style="background: rgba(0,0,0,0.3); padding: 5px; border-radius: 4px;">http://localhost:8000</code>
                                    </p>
                                </div>
                                <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px;">
                                    <h6 style="margin: 0 0 10px 0; font-size: 16px; color: #fdcb6e;">3. Different Browser</h6>
                                    <p style="margin: 0; font-size: 14px; opacity: 0.9;">
                                        Try Firefox or Edge - they often have better CORS handling than Chrome.
                                    </p>
                                </div>
                                <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px;">
                                    <h6 style="margin: 0 0 10px 0; font-size: 16px; color: #fdcb6e;">4. Mobile Browser</h6>
                                    <p style="margin: 0; font-size: 14px; opacity: 0.9;">
                                        Mobile browsers often have fewer CORS restrictions. Try opening on your phone.
                                    </p>
                                </div>
                            </div>
                        </div>
                        
                        <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-top: 15px;">
                            <h6 style="margin: 0 0 10px 0; font-size: 16px;">🔧 ADVANCED SOLUTIONS:</h6>
                            <ul style="margin: 0; padding-left: 20px; opacity: 0.9; font-size: 14px;">
                                <li><strong>Chrome with disabled security:</strong> <code>chrome.exe --disable-web-security --user-data-dir="C:/temp"</code></li>
                                <li><strong>Get free API keys:</strong> Alpha Vantage (500 calls/day) or IEX Cloud (50k/month)</li>
                                <li><strong>Use VPN:</strong> Change your location to bypass restrictions</li>
                            </ul>
                        </div>
                        
                        <div style="text-align: center; margin-top: 20px; padding: 15px; background: rgba(255,255,255,0.1); border-radius: 8px;">
                            <p style="margin: 0; font-size: 14px; opacity: 0.9;">
                                <i class="fas fa-info-circle"></i> <strong>Status:</strong> All public CORS proxies are currently blocked. 
                                The app will continue working with realistic data until you implement one of the solutions above.
                            </p>
                        </div>
                    </div>
                `;
                
                // Show the help message
                this.showWarning(helpMessage);
                
                // Also log to console for developers
                console.log(`🔧 CORS Help for ${symbol}:`, {
                    message: 'Browser security restrictions prevent real-time data fetching',
                    solutions: [
                        'Install CORS Unblock extension',
                        'Use different browser',
                        'Run local server',
                        'Use mobile browser'
                    ]
                });
                
                // Test current CORS status
                this.testCORSStatus();
            }

            async testCORSStatus() {
                console.log('🔍 Testing CORS status...');
                const testUrls = [
                    'https://api.allorigins.win/raw?url=https://query1.finance.yahoo.com/v8/finance/chart/AAPL?interval=1d&range=1d',
                    'https://corsproxy.io/?https://query1.finance.yahoo.com/v8/finance/chart/AAPL?interval=1d&range=1d',
                    'https://api.codetabs.com/v1/proxy?quest=https://query1.finance.yahoo.com/v8/finance/chart/AAPL?interval=1d&range=1d'
                ];
                
                for (const url of testUrls) {
                    try {
                        const response = await fetch(url, { method: 'GET' });
                        const proxyName = url.split('//')[1].split('/')[0];
                        console.log(`✅ ${proxyName}: ${response.status} ${response.statusText}`);
                    } catch (error) {
                        const proxyName = url.split('//')[1].split('/')[0];
                        console.log(`❌ ${proxyName}: ${error.message}`);
                    }
                }
            }

            setupLocalServer() {
                const instructions = `
                    <div style="background: linear-gradient(135deg, #2ed573, #26d0aa); color: white; padding: 25px; border-radius: 15px; margin: 20px 0; box-shadow: 0 8px 32px rgba(0,0,0,0.2); border: 2px solid rgba(255,255,255,0.1);">
                        <h4 style="margin: 0 0 20px 0; font-size: 20px; text-align: center;">
                            <i class="fas fa-server"></i> Local Server Setup Guide
                        </h4>
                        
                        <div style="background: rgba(255,255,255,0.15); padding: 20px; border-radius: 10px; margin: 15px 0;">
                            <h5 style="margin: 0 0 15px 0; font-size: 18px; text-align: center;">📋 Step-by-Step Instructions:</h5>
                            
                            <div style="display: grid; grid-template-columns: 1fr; gap: 15px;">
                                <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px;">
                                    <h6 style="margin: 0 0 10px 0; font-size: 16px; color: #fdcb6e;">Step 1: Open Terminal/Command Prompt</h6>
                                    <p style="margin: 0; font-size: 14px; opacity: 0.9;">
                                        Press <code style="background: rgba(0,0,0,0.3); padding: 3px 6px; border-radius: 4px;">Win + R</code>, type <code style="background: rgba(0,0,0,0.3); padding: 3px 6px; border-radius: 4px;">cmd</code> and press Enter
                                    </p>
                                </div>
                                
                                <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px;">
                                    <h6 style="margin: 0 0 10px 0; font-size: 16px; color: #fdcb6e;">Step 2: Navigate to File Location</h6>
                                    <p style="margin: 0; font-size: 14px; opacity: 0.9;">
                                        Type: <code style="background: rgba(0,0,0,0.3); padding: 3px 6px; border-radius: 4px;">cd "C:\\Users\\REUNIONES\\Desktop"</code>
                                    </p>
                                </div>
                                
                                <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px;">
                                    <h6 style="margin: 0 0 10px 0; font-size: 16px; color: #fdcb6e;">Step 3: Start Local Server</h6>
                                    <p style="margin: 0; font-size: 14px; opacity: 0.9;">
                                        Type: <code style="background: rgba(0,0,0,0.3); padding: 3px 6px; border-radius: 4px;">python -m http.server 8000</code>
                                    </p>
                                </div>
                                
                                <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px;">
                                    <h6 style="margin: 0 0 10px 0; font-size: 16px; color: #fdcb6e;">Step 4: Open in Browser</h6>
                                    <p style="margin: 0; font-size: 14px; opacity: 0.9;">
                                        Open your browser and go to: <code style="background: rgba(0,0,0,0.3); padding: 3px 6px; border-radius: 4px;">http://localhost:8000/stock-portfolio.html</code>
                                    </p>
                                </div>
                            </div>
                        </div>
                        
                        <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-top: 15px;">
                            <h6 style="margin: 0 0 10px 0; font-size: 16px;">💡 What This Does:</h6>
                            <ul style="margin: 0; padding-left: 20px; opacity: 0.9; font-size: 14px;">
                                <li>Creates a local web server that bypasses CORS restrictions</li>
                                <li>Allows real-time data fetching from Yahoo Finance</li>
                                <li>Provides full functionality without browser extensions</li>
                                <li>Works with all browsers and doesn't require API keys</li>
                            </ul>
                        </div>
                        
                        <div style="text-align: center; margin-top: 20px; padding: 15px; background: rgba(255,255,255,0.1); border-radius: 8px;">
                            <p style="margin: 0; font-size: 14px; opacity: 0.9;">
                                <i class="fas fa-check-circle"></i> <strong>Result:</strong> Once set up, you'll have full access to real-time stock data without any CORS issues!
                            </p>
                        </div>
                    </div>
                `;
                
                this.showWarning(instructions);
            }

            dateToTimestamp(dateString) {
                return Math.floor(new Date(dateString).getTime() / 1000);
            }

            // US Market Trading Days Utilities
            toIsoDateString(date) {
                return new Date(date.getTime() - date.getTimezoneOffset() * 60000).toISOString().slice(0, 10);
            }

            getNthWeekdayOfMonth(year, monthIndex, weekdayIndex, n) {
                const date = new Date(year, monthIndex, 1);
                let count = 0;
                while (date.getMonth() === monthIndex) {
                    if (date.getDay() === weekdayIndex) {
                        count++;
                        if (count === n) return new Date(date);
                    }
                    date.setDate(date.getDate() + 1);
                }
                return null;
            }

            getLastWeekdayOfMonth(year, monthIndex, weekdayIndex) {
                const date = new Date(year, monthIndex + 1, 0);
                while (date.getMonth() === monthIndex) {
                    if (date.getDay() === weekdayIndex) return new Date(date);
                    date.setDate(date.getDate() - 1);
                }
                return null;
            }

            // Anonymous Gregorian algorithm for Easter Sunday
            getEasterSunday(year) {
                const a = year % 19;
                const b = Math.floor(year / 100);
                const c = year % 100;
                const d = Math.floor(b / 4);
                const e = b % 4;
                const f = Math.floor((b + 8) / 25);
                const g = Math.floor((b - f + 1) / 3);
                const h = (19 * a + b - d - g + 15) % 30;
                const i = Math.floor(c / 4);
                const k = c % 4;
                const l = (32 + 2 * e + 2 * i - h - k) % 7;
                const m = Math.floor((a + 11 * h + 22 * l) / 451);
                const month = Math.floor((h + l - 7 * m + 114) / 31) - 1; // 0=Jan
                const day = ((h + l - 7 * m + 114) % 31) + 1;
                return new Date(year, month, day);
            }

            getObservedDate(date) {
                const day = date.getDay();
                const observed = new Date(date);
                if (day === 6) { // Saturday -> Friday
                    observed.setDate(observed.getDate() - 1);
                } else if (day === 0) { // Sunday -> Monday
                    observed.setDate(observed.getDate() + 1);
                }
                return observed;
            }

            getUsMarketHolidays(year) {
                const holidays = new Set();
                // New Year's Day (observed)
                holidays.add(this.toIsoDateString(this.getObservedDate(new Date(year, 0, 1))));
                // Martin Luther King Jr. Day (3rd Monday in Jan)
                holidays.add(this.toIsoDateString(this.getNthWeekdayOfMonth(year, 0, 1, 3)));
                // Presidents' Day (3rd Monday in Feb)
                holidays.add(this.toIsoDateString(this.getNthWeekdayOfMonth(year, 1, 1, 3)));
                // Good Friday (Friday before Easter Sunday)
                const easter = this.getEasterSunday(year);
                const goodFriday = new Date(easter);
                goodFriday.setDate(goodFriday.getDate() - 2);
                holidays.add(this.toIsoDateString(goodFriday));
                // Memorial Day (last Monday in May)
                holidays.add(this.toIsoDateString(this.getLastWeekdayOfMonth(year, 4, 1)));
                // Juneteenth (observed)
                holidays.add(this.toIsoDateString(this.getObservedDate(new Date(year, 5, 19))));
                // Independence Day (observed)
                holidays.add(this.toIsoDateString(this.getObservedDate(new Date(year, 6, 4))));
                // Labor Day (first Monday in Sep)
                holidays.add(this.toIsoDateString(this.getNthWeekdayOfMonth(year, 8, 1, 1)));
                // Thanksgiving Day (4th Thursday in Nov)
                holidays.add(this.toIsoDateString(this.getNthWeekdayOfMonth(year, 10, 4, 4)));
                // Christmas Day (observed)
                holidays.add(this.toIsoDateString(this.getObservedDate(new Date(year, 11, 25))));
                return holidays;
            }

            isUsMarketOpenDate(date) {
                const day = date.getDay();
                if (day === 0 || day === 6) return false; // Sunday, Saturday
                const holidays = this.getUsMarketHolidays(date.getFullYear());
                return !holidays.has(this.toIsoDateString(date));
            }

            getUsTradingDaySet(startDateStr, endDateStr) {
                const start = new Date(startDateStr + 'T00:00:00');
                const end = new Date(endDateStr + 'T00:00:00');
                const set = new Set();
                const cursor = new Date(start);
                while (cursor <= end) {
                    if (this.isUsMarketOpenDate(cursor)) {
                        set.add(this.toIsoDateString(cursor));
                    }
                    cursor.setDate(cursor.getDate() + 1);
                }
                return set;
            }

            async addToPortfolio(symbol, data) {
                this.portfolio.set(symbol, data);
                this.savePortfolio();
                this.renderPortfolio();
                this.updateCalculateButton();
                
                // Auto-update all analyses when a new stock is added
                await this.autoUpdateAllAnalyses();
            }

            removeFromPortfolio(symbol) {
                this.portfolio.delete(symbol);
                this.savePortfolio();
                this.renderPortfolio();
                this.showSuccess(`Removed ${symbol} from portfolio`);
            }

            async updateAllStocks() {
                if (this.portfolio.size === 0) {
                    this.showError('No stocks in portfolio to update');
                    return;
                }

                const symbols = Array.from(this.portfolio.keys());
                this.showProgressBar('Updating Portfolio Data', symbols.length);
                
                try {
                    for (let i = 0; i < symbols.length; i++) {
                        const symbol = symbols[i];
                        this.updateProgress(i + 1, symbols.length, `Updating ${symbol}...`);
                        
                        const newData = await this.fetchStockData(symbol);
                        if (newData) {
                            this.portfolio.set(symbol, newData);
                        }
                    }
                    this.hideProgressBar();
                    this.savePortfolio();
                    this.renderPortfolio();
                    this.showSuccess('Portfolio updated successfully');
                    // Auto-update all analyses when stock data is refreshed
                    await this.autoUpdateAllAnalyses();
                } catch (error) {
                    this.hideProgressBar();
                    this.showError(`Error updating portfolio: ${error.message}`);
                }
            }

            clearPortfolio() {
                if (confirm('Are you sure you want to clear your entire portfolio?')) {
                    this.portfolio.clear();
                    this.savePortfolio();
                    this.renderPortfolio();
                    this.showSuccess('Portfolio cleared');
                    // Clear all analyses when portfolio is cleared
                    this.clearAllAnalysisSections();
                }
            }

            renderPortfolio() {
                const grid = document.getElementById('portfolioGrid');
                
                if (this.portfolio.size === 0) {
                    grid.innerHTML = `
                        <div class="empty-portfolio">
                            <i class="fas fa-briefcase"></i>
                            <h3>Your portfolio is empty</h3>
                            <p>Search for stocks above to start building your portfolio</p>
                        </div>
                    `;
                    this.updateCalculateButton();
                    return;
                }

                grid.innerHTML = '';
                
                this.portfolio.forEach((data, symbol) => {
                    const card = this.createStockCard(symbol, data);
                    grid.appendChild(card);
                });
                
                this.updateCalculateButton();
            }

            createStockCard(symbol, data) {
                const card = document.createElement('div');
                card.className = 'stock-card';
                
                // Get filtered date range
                const startDate = document.getElementById('startDate').value;
                const endDate = document.getElementById('endDate').value;
                const today = new Date().toISOString().split('T')[0];
                
                // Determine if filtered range includes today
                const includesToday = endDate >= today;
                
                // Calculate conditional price and change
                let displayPrice, displayChange, displayChangePercent, changeClass, changeIcon;
                
                if (includesToday) {
                    // Use Ask price (real-time) if range includes today
                    displayPrice = data.price; // This should be the Ask price
                    displayChange = data.change;
                    displayChangePercent = data.changePercent;
                } else {
                    // Use Adjusted Close from filtered end date
                    const historicalData = data.historicalData;
                    const timestamps = data.timestamps;
                    
                    if (historicalData && historicalData.length > 0) {
                        // Get the last price from filtered data (end date)
                        displayPrice = historicalData[historicalData.length - 1];
                        
                        // Calculate change compared to previous day
                        if (historicalData.length > 1) {
                            const previousPrice = historicalData[historicalData.length - 2];
                            displayChange = displayPrice - previousPrice;
                            displayChangePercent = (displayChange / previousPrice) * 100;
                        } else {
                            displayChange = 0;
                            displayChangePercent = 0;
                        }
                    } else {
                        // Fallback to original data
                        displayPrice = data.price;
                        displayChange = data.change;
                        displayChangePercent = data.changePercent;
                    }
                }
                
                changeClass = displayChange >= 0 ? 'change-positive' : 'change-negative';
                changeIcon = displayChange >= 0 ? 'fa-arrow-up' : 'fa-arrow-down';
                
                // Calculate period return between selected dates
                const periodReturn = this.calculatePeriodReturn(data.historicalData, data.timestamps);
                const periodReturnClass = periodReturn.returnPercent >= 0 ? 'change-positive' : 'change-negative';
                const periodReturnIcon = periodReturn.returnPercent >= 0 ? 'fa-arrow-up' : 'fa-arrow-down';
                
                // Get sector information
                const sector = this.getStockSector(symbol);
                const portfolioSize = this.portfolio.size;
                const sectorPercentage = portfolioSize > 0 ? ((1 / portfolioSize) * 100).toFixed(1) : '0.0';
                
                card.innerHTML = `
                    <div class="stock-header">
                        <div class="stock-symbol">${symbol}</div>
                        <button class="remove-stock" onclick="portfolio.removeFromPortfolio('${symbol}')">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="stock-sector-info">
                        <div class="sector-badge" style="background: ${this.getSectorColor(sector)}">
                            <i class="fas fa-industry"></i>
                            <span>${sector}</span>
                        </div>
                        <div class="portfolio-percentage">
                            <i class="fas fa-percentage"></i>
                            <span>${sectorPercentage}%</span>
                        </div>
                    </div>
                    <div class="stock-price-row">
                    <div class="stock-price">$${displayPrice.toFixed(2)}</div>
                        <div class="mini-chart" title="View price chart">
                            <i class="fas fa-chart-area"></i>
                            <div class="mini-chart-tooltip">
                                <div class="mini-chart-header">
                                    <span>${data.name || symbol}</span>
                                    <span class="${periodReturnClass}">Period Return: ${periodReturn.returnPercent.toFixed(2)}%</span>
                                </div>
                                <div class="mini-chart-meta">
                                    <span>Start: $${periodReturn.initialPrice.toFixed(2)}</span>
                                    <span>End: $${periodReturn.finalPrice.toFixed(2)}</span>
                                </div>
                                ${this.generateAreaChartSVG(data.historicalData, symbol)}
                            </div>
                        </div>
                    </div>
                    <div class="stock-change ${changeClass}">
                        <i class="fas ${changeIcon}"></i>
                        <span>${displayChange.toFixed(2)} (${displayChangePercent.toFixed(2)}%)</span>
                    </div>
                    <div class="stock-details">
                        <div class="detail-item">
                            <span class="detail-label">Volume:</span>
                            <span class="detail-value">${data.volume.toLocaleString()}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">High:</span>
                            <span class="detail-value">$${includesToday ? data.high.toFixed(2) : Math.max(...data.historicalData).toFixed(2)}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Low:</span>
                            <span class="detail-value">$${includesToday ? data.low.toFixed(2) : Math.min(...data.historicalData).toFixed(2)}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Open:</span>
                            <span class="detail-value">$${includesToday ? data.open.toFixed(2) : data.historicalData[0].toFixed(2)}</span>
                        </div>
                    </div>
                    <div class="period-details">
                        <div class="period-return ${periodReturnClass}">
                            <i class="fas ${periodReturnIcon}"></i>
                            <span>Period Return: $${periodReturn.returnValue.toFixed(2)} (${periodReturn.returnPercent.toFixed(2)}%)</span>
                        </div>
                        <div class="period-detail-item">
                            <span class="detail-label">Initial Price:</span>
                            <span class="detail-value">$${periodReturn.initialPrice.toFixed(2)}</span>
                        </div>
                        <div class="period-detail-item">
                            <span class="detail-label">Final Price:</span>
                            <span class="detail-value">$${periodReturn.finalPrice.toFixed(2)}</span>
                        </div>
                        <div class="period-detail-item">
                            <span class="detail-label">Period:</span>
                            <span class="detail-value">${periodReturn.startDate} - ${periodReturn.endDate}</span>
                        </div>

                    </div>
                `;
                
                return card;
            }

            showLoading() {
                const grid = document.getElementById('portfolioGrid');
                grid.innerHTML = `
                    <div class="loading">
                        <div class="spinner"></div>
                        <p>Loading stock data...</p>
                    </div>
                `;
            }

            showProgressBar(title, total, targetElement = 'portfolioGrid') {
                const element = document.getElementById(targetElement);
                element.innerHTML = `
                    <div class="progress-container">
                        <div class="progress-title">${title}</div>
                        <div class="progress-bar-container">
                            <div class="progress-bar" style="width: 0%"></div>
                        </div>
                        <div class="progress-text">Preparing to update...</div>
                        <div class="progress-details">
                            <span class="progress-current">0</span>
                            <span>of ${total} ${targetElement === 'analysisResults' ? 'steps' : 'stocks'}</span>
                        </div>
                    </div>
                `;
            }

            updateProgress(current, total, message) {
                const progressBar = document.querySelector('.progress-bar');
                const progressText = document.querySelector('.progress-text');
                const progressCurrent = document.querySelector('.progress-current');
                
                if (progressBar && progressText && progressCurrent) {
                    const percentage = (current / total) * 100;
                    progressBar.style.width = `${percentage}%`;
                    progressText.textContent = message;
                    progressCurrent.textContent = current;
                }
            }

            hideProgressBar() {
                const progressContainer = document.querySelector('.progress-container');
                if (progressContainer) {
                    progressContainer.remove();
                }
            }

            showError(message) {
                this.showMessage(message, 'error');
            }

            showSuccess(message) {
                this.showMessage(message, 'success');
            }

            showWarning(message) {
                this.showMessage(message, 'warning');
            }

            showMessage(message, type) {
                const existingMessage = document.querySelector('.error, .success, .warning');
                if (existingMessage) {
                    existingMessage.remove();
                }

                const messageDiv = document.createElement('div');
                messageDiv.className = type;
                
                let icon = 'check-circle';
                if (type === 'error') icon = 'exclamation-triangle';
                else if (type === 'warning') icon = 'exclamation-circle';
                
                messageDiv.innerHTML = `<i class="fas fa-${icon}"></i> ${message}`;
                
                document.querySelector('.search-section').appendChild(messageDiv);
                
                setTimeout(() => {
                    messageDiv.remove();
                }, 5000);
            }

            savePortfolio() {
                const portfolioData = Array.from(this.portfolio.entries());
                localStorage.setItem('stockPortfolio', JSON.stringify(portfolioData));
            }

            loadPortfolio() {
                const saved = localStorage.getItem('stockPortfolio');
                if (saved) {
                    try {
                        const portfolioData = JSON.parse(saved);
                        this.portfolio = new Map(portfolioData);
                        this.renderPortfolio();
                    } catch (error) {
                        console.error('Error loading portfolio:', error);
                        localStorage.removeItem('stockPortfolio');
                    }
                }
            }



            updateCalculateButton() {
                const calculateBtn = document.getElementById('calculateBtn');
                const hasStocks = this.portfolio.size > 0;
                const hasDates = document.getElementById('startDate').value && document.getElementById('endDate').value;
                
                calculateBtn.disabled = !(hasStocks && hasDates);
            }

            // Financial Analysis Methods
            async calculateAnalysis() {
                if (this.portfolio.size === 0) {
                    this.showError('No stocks in portfolio to analyze');
                    return;
                }

                const startDate = document.getElementById('startDate').value;
                const endDate = document.getElementById('endDate').value;
                
                if (!startDate || !endDate) {
                    this.showError('Please select both start and end dates');
                    return;
                }

                const symbols = Array.from(this.portfolio.keys());
                this.showProgressBar('Calculating Financial Analysis', symbols.length + 2, 'analysisResults'); // +2 for portfolio and market calculations
                
                try {
                    const analysisResults = await this.performFinancialAnalysis();
                    this.hideProgressBar();
                    this.displayAnalysisResults(analysisResults);
                } catch (error) {
                    this.hideProgressBar();
                    this.showError(`Error calculating analysis: ${error.message}`);
                }
            }

            async performFinancialAnalysis() {
                const stocks = Array.from(this.portfolio.values());
                const results = {};
                let progressStep = 0;
                const totalSteps = stocks.length + 2;
                
                // Get the current scale mode at calculation time
                const isAnnualized = this.scaleMode === 'annualized';
                const scaleFactor = isAnnualized ? 252 : 1;
                const stdScaleFactor = isAnnualized ? Math.sqrt(252) : 1;
                const riskFreeRate = isAnnualized ? this.riskFreeRateAnnual : (this.riskFreeRateAnnual / 252);

                for (let i = 0; i < stocks.length; i++) {
                    const stock = stocks[i];
                    progressStep++;
                    this.updateProgress(progressStep, totalSteps, `Analyzing ${stock.symbol}...`);

                    const logReturns = this.calculateLogReturns(stock.historicalData);
                    
                    // Calculate base daily metrics
                    const dailyMean = this.calculateMean(logReturns);
                    const dailyVariance = this.calculateVariance(logReturns);
                    const dailyStd = Math.sqrt(dailyVariance);
                    const dailyVaR = this.calculateVaR(logReturns, this.varLevel);
                    const dailyLastReturn = logReturns.length > 0 ? logReturns[logReturns.length - 1] : 0;
                    const dailyMin = logReturns.length ? Math.min(...logReturns) : 0;
                    const dailyMax = logReturns.length ? Math.max(...logReturns) : 0;
                    const dailyRange = dailyMax - dailyMin;
                    
                    // Apply scaling based on selected mode
                    // For annualized: mean_daily_log * 252, std * sqrt(252), etc.
                    const scaledMean = dailyMean * scaleFactor; // Annualized log return = mean_daily_log * 252
                    const scaledVariance = dailyVariance * scaleFactor; // Variance scales by time factor
                    const scaledStd = dailyStd * stdScaleFactor; // Std dev scales by sqrt(time factor)
                    const scaledVaR = dailyVaR * stdScaleFactor;
                    const scaledRange = dailyRange * stdScaleFactor;
                    const scaledLastReturn = dailyLastReturn * scaleFactor;
                    
                    // Calculate scaled metrics
                    const scaledSharpe = this.calculateSharpeRatio(scaledMean, scaledStd, riskFreeRate);
                    const scaledCoV = scaledStd / (Math.abs(scaledMean) || 1e-12);

                    results[stock.symbol] = {
                        returns: logReturns,
                        daily: {
                            mean: dailyMean,
                            variance: dailyVariance,
                            stdDev: dailyStd,
                            vaR: dailyVaR,
                            sharpe: this.calculateSharpeRatio(dailyMean, dailyStd, this.riskFreeRateAnnual / 252),
                            lastReturn: dailyLastReturn,
                            range: dailyRange,
                            cov: dailyStd / (Math.abs(dailyMean) || 1e-12)
                        },
                        annualized: {
                            mean: this.annualizeMeanDailyReturn(dailyMean),
                            variance: Math.pow(this.annualizeDailyStdDev(dailyStd), 2),
                            stdDev: this.annualizeDailyStdDev(dailyStd),
                            vaR: dailyVaR * Math.sqrt(252),
                            sharpe: this.calculateSharpeRatio(this.annualizeMeanDailyReturn(dailyMean), this.annualizeDailyStdDev(dailyStd), this.riskFreeRateAnnual),
                            lastReturn: dailyLastReturn * 252,
                            range: dailyRange * Math.sqrt(252),
                            cov: this.annualizeDailyStdDev(dailyStd) / (Math.abs(this.annualizeMeanDailyReturn(dailyMean)) || 1e-12)
                        },
                        // Current scaled values for immediate use
                        current: {
                            mean: scaledMean,
                            variance: scaledVariance,
                            stdDev: scaledStd,
                            vaR: scaledVaR,
                            sharpe: scaledSharpe,
                            lastReturn: scaledLastReturn,
                            range: scaledRange,
                            cov: scaledCoV
                        }
                    };
                }

                progressStep++;
                this.updateProgress(progressStep, totalSteps, 'Calculating portfolio metrics...');
                const portfolioReturns = this.calculatePortfolioReturns(stocks, results);
                const marketReturns = this.calculateMarketReturns(stocks, results); // Using first stock as market proxy

                progressStep++;
                this.updateProgress(progressStep, totalSteps, 'Finalizing analysis...');
                
                // Calculate base daily portfolio metrics
                const pDailyMean = this.calculateMean(portfolioReturns);
                const pDailyVar = this.calculateVariance(portfolioReturns);
                const pDailyStd = Math.sqrt(pDailyVar);
                const pDailyVaR = this.calculateVaR(portfolioReturns, this.varLevel);
                const rfDaily = this.riskFreeRateAnnual / 252;
                const pDailySharpe = this.calculateSharpeRatio(pDailyMean, pDailyStd, rfDaily);

                const pAnnMean = this.annualizeMeanDailyReturn(pDailyMean);
                const pAnnStd = this.annualizeDailyStdDev(pDailyStd);
                const pAnnVar = Math.pow(pAnnStd, 2);
                const pAnnVaR = pDailyVaR * Math.sqrt(252);
                const pAnnSharpe = this.calculateSharpeRatio(pAnnMean, pAnnStd, this.riskFreeRateAnnual);
                
                // Apply scaling for current mode
                // For annualized: mean_daily_log * 252, std * sqrt(252), etc.
                const pScaledMean = pDailyMean * scaleFactor; // Annualized log return = mean_daily_log * 252
                const pScaledVar = pDailyVar * scaleFactor; // Variance scales by time factor
                const pScaledStd = pDailyStd * stdScaleFactor; // Std dev scales by sqrt(time factor)
                const pScaledVaR = pDailyVaR * stdScaleFactor;
                const pScaledSharpe = this.calculateSharpeRatio(pScaledMean, pScaledStd, riskFreeRate);
                const pScaledCoV = pScaledStd / (Math.abs(pScaledMean) || 1e-12);
                
                results.portfolio = {
                    returns: portfolioReturns,
                    daily: {
                        mean: pDailyMean,
                        variance: pDailyVar,
                        stdDev: pDailyStd,
                        cov: pDailyStd / (Math.abs(pDailyMean) || 1e-12),
                        vaR: pDailyVaR,
                        sharpe: pDailySharpe,
                    },
                    annualized: {
                        mean: pAnnMean,
                        variance: pAnnVar,
                        stdDev: pAnnStd,
                        cov: pAnnStd / (Math.abs(pAnnMean) || 1e-12),
                        vaR: pAnnVaR,
                        sharpe: pAnnSharpe,
                    },
                    // Current scaled values for immediate use
                    current: {
                        mean: pScaledMean,
                        variance: pScaledVar,
                        stdDev: pScaledStd,
                        cov: pScaledCoV,
                        vaR: pScaledVaR,
                        sharpe: pScaledSharpe,
                    }
                };



                // Refine metrics using simple-statistics over log returns
                this.computeMetricsWithStats(stocks, results);

                return results;
            }

            computeMetricsWithStats(stocks, results) {
                try {
                    const symbols = stocks.map(s => s.symbol);
                    // Align lengths
                    const lengths = symbols.map(sym => (results[sym].returns || []).length).filter(n => n > 0);
                    if (lengths.length === 0) return;
                    const T = Math.min(...lengths);
                    if (T < 2) return;
                    const rfDaily = (this.riskFreeRateAnnual || 0) / 252;
                    const q = this.varLevel || 0.05;
                    // Market proxy: first symbol
                    const mkt = results[symbols[0]].returns.slice(-T);
                    const mktMean = ss.mean(mkt);
                    const mktVar = ss.variance(mkt) || 1e-12;
                    symbols.forEach(sym => {
                        const r = results[sym].returns.slice(-T);
                        const mean = ss.mean(r);
                        const variance = ss.variance(r);
                        const stdDev = Math.sqrt(variance);
                        const minV = ss.min(r);
                        const maxV = ss.max(r);
                        const range = maxV - minV;
                        const sorted = [...r].sort((a,b)=>a-b);
                        const idx = Math.floor(q * sorted.length);
                        const vaR = sorted[idx];

                        const sharpe = this.calculateSharpeRatio(mean, stdDev, rfDaily);
                        results[sym].daily.mean = mean;
                        results[sym].daily.variance = variance;
                        results[sym].daily.stdDev = stdDev;
                        results[sym].daily.range = range;
                        results[sym].daily.vaR = vaR;

                        results[sym].daily.sharpe = sharpe;
                        const annStd = this.annualizeDailyStdDev(stdDev);
                        results[sym].annualized.mean = this.annualizeMeanDailyReturn(mean);
                        results[sym].annualized.stdDev = annStd;
                        results[sym].annualized.variance = annStd * annStd;
                        results[sym].annualized.range = range * Math.sqrt(252);
                        results[sym].annualized.vaR = vaR * Math.sqrt(252);

                        results[sym].annualized.sharpe = this.calculateSharpeRatio(results[sym].annualized.mean, results[sym].annualized.stdDev, this.riskFreeRateAnnual || 0);
                        results[sym].daily.cov = stdDev / (Math.abs(mean) || 1e-12);
                        results[sym].annualized.cov = results[sym].annualized.stdDev / (Math.abs(results[sym].annualized.mean) || 1e-12);
                    });
                } catch (e) {
                    console.warn('simple-statistics unavailable or error computing metrics:', e);
                }
            }

            calculateReturns(prices) {
                const returns = [];
                for (let i = 1; i < prices.length; i++) {
                    const returnValue = (prices[i] - prices[i-1]) / prices[i-1];
                    returns.push(returnValue);
                }
                return returns;
            }

            calculateLogReturns(prices) {
                const returns = [];
                for (let i = 1; i < prices.length; i++) {
                    if (prices[i-1] > 0 && prices[i] > 0) {
                        returns.push(Math.log(prices[i] / prices[i-1]));
                    }
                }
                return returns;
            }

            calculatePeriodReturn(historicalData, timestamps) {
                if (!historicalData || historicalData.length < 2) {
                    return { 
                        returnValue: 0, 
                        returnPercent: 0, 
                        initialPrice: 0, 
                        finalPrice: 0,
                        startDate: '',
                        endDate: ''
                    };
                }
                
                const startPrice = historicalData[0];
                const endPrice = historicalData[historicalData.length - 1];
                
                if (startPrice === null || endPrice === null) {
                    return { 
                        returnValue: 0, 
                        returnPercent: 0, 
                        initialPrice: 0, 
                        finalPrice: 0,
                        startDate: '',
                        endDate: ''
                    };
                }
                
                const returnValue = endPrice - startPrice;
                const returnPercent = (returnValue / startPrice) * 100;
                
                // Convert timestamps to readable dates
                const startDate = timestamps && timestamps.length > 0 ? new Date(timestamps[0] * 1000).toLocaleDateString() : '';
                const endDate = timestamps && timestamps.length > 0 ? new Date(timestamps[timestamps.length - 1] * 1000).toLocaleDateString() : '';
                
                return { 
                    returnValue, 
                    returnPercent, 
                    initialPrice: startPrice, 
                    finalPrice: endPrice,
                    startDate,
                    endDate
                };
            }

            generateAreaChartSVG(prices, symbol, width = 320, height = 140) {
                if (!prices || prices.length < 2) {
                    return '<div style="padding:8px;color:#777;font-size:12px;">No data</div>';
                }
                const sanitizedId = `grad_${String(symbol).replace(/[^a-zA-Z0-9_-]/g, '')}`;
                const padding = 8;
                const innerWidth = width - padding * 2;
                const innerHeight = height - padding * 2;

                const minPrice = Math.min(...prices);
                const maxPrice = Math.max(...prices);
                const range = maxPrice - minPrice || 1;

                const scaleX = index => padding + (index * innerWidth) / (prices.length - 1);
                const scaleY = price => padding + innerHeight - ((price - minPrice) / range) * innerHeight;

                // Line path
                const linePoints = prices.map((p, i) => `${scaleX(i)},${scaleY(p)}`).join(' ');

                // Area path
                const firstX = scaleX(0);
                const lastX = scaleX(prices.length - 1);
                const baselineY = padding + innerHeight;
                const areaPath = `M ${firstX} ${baselineY} L ${linePoints.replace(/ /g, ' L ')} L ${lastX} ${baselineY} Z`;

                return `
<svg viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Price chart">
  <defs>
    <linearGradient id="${sanitizedId}" x1="0" y1="0" x2="0" y2="1">
      <stop offset="0%" stop-color="#667eea" stop-opacity="0.35" />
      <stop offset="100%" stop-color="#667eea" stop-opacity="0.05" />
    </linearGradient>
  </defs>
  <rect x="0" y="0" width="${width}" height="${height}" fill="#ffffff" rx="8" ry="8" />
  <path d="${areaPath}" fill="url(#${sanitizedId})" />
  <polyline points="${linePoints}" fill="none" stroke="#667eea" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
</svg>`;
            }

            calculateMean(data) {
                return data.reduce((sum, value) => sum + value, 0) / data.length;
            }

            calculateVariance(data) {
                const mean = this.calculateMean(data);
                return data.reduce((sum, value) => sum + Math.pow(value - mean, 2), 0) / data.length;
            }

            annualizeMeanDailyReturn(dailyMean) {
                const tradingDays = 252;
                return dailyMean * tradingDays;
            }

            annualizeDailyStdDev(dailyStdDev) {
                const tradingDays = 252;
                return dailyStdDev * Math.sqrt(tradingDays);
            }

            calculateSharpeRatio(mean, stdDev, riskFreeRatePerPeriod = 0) {
                if (!stdDev || stdDev === 0) return 0;
                return (mean - riskFreeRatePerPeriod) / stdDev;
            }

            calculatePortfolioReturns(stocks, results) {
                // Equal-weighted portfolio returns
                const portfolioReturns = [];
                const stockReturns = stocks.map(stock => results[stock.symbol].returns);
                
                const minLength = Math.min(...stockReturns.map(r => r.length));
                
                for (let i = 0; i < minLength; i++) {
                    let dailyReturn = 0;
                    for (let j = 0; j < stockReturns.length; j++) {
                        dailyReturn += stockReturns[j][i] / stockReturns.length;
                    }
                    portfolioReturns.push(dailyReturn);
                }
                
                return portfolioReturns;
            }

            calculateMarketReturns(stocks, results) {
                // Using the first stock as market proxy (simplified approach)
                return results[stocks[0].symbol].returns;
            }

            calculateBeta(stockReturns, marketReturns = null) {
                try {
                    // Use provided market returns for BETA calculation
                    const benchmarkReturns = marketReturns || [];
                    
                    if (!benchmarkReturns || benchmarkReturns.length === 0) {
                        console.warn('No benchmark data available for BETA calculation, using fallback');
                        return 0;
                    }
                    
                    // Align lengths
                    const minLength = Math.min(stockReturns.length, benchmarkReturns.length);
                    if (minLength < 2) {
                        return 0;
                    }
                    
                    const alignedStockReturns = stockReturns.slice(-minLength);
                    const alignedMarketReturns = benchmarkReturns.slice(-minLength);
                    
                    // Calculate covariance and variance using simple-statistics
                    const covariance = ss.sampleCovariance(alignedStockReturns, alignedMarketReturns) || 0;
                    const marketVariance = ss.variance(alignedMarketReturns) || 1;
                    
                    const beta = covariance / marketVariance;
                    
                    if (false) {
                        console.log(`BETA calculated using benchmark: ${beta.toFixed(4)}`);
                    }
                    
                    return beta;
                    
                } catch (error) {
                    console.error('Error calculating beta:', error);
                    return 0;
                }
            }

            calculateVaR(returns, confidenceLevel) {
                const sortedReturns = [...returns].sort((a, b) => a - b);
                const index = Math.floor(confidenceLevel * sortedReturns.length);
                return sortedReturns[index];
            }

            buildHistoricalReturnsTable() {
                const symbols = Array.from(this.portfolio.keys());
                if (symbols.length === 0) return '';
                const results = this.lastAnalysisResults || {};
                // Determine aligned length from returns
                const lengths = symbols.map(s => (results[s] && results[s].returns ? results[s].returns.length : 0)).filter(n => n > 0);
                if (lengths.length === 0) return '';
                const minLen = Math.min(...lengths);
                if (minLen < 1) return '';
                // Date axis from first stock timestamps; align to last minLen dates (returns correspond to end-of-period dates)
                const first = this.portfolio.get(symbols[0]);
                const ts = (first && first.timestamps) ? first.timestamps.slice(-minLen) : [];
                if (ts.length !== minLen) return '';
                const dateStrings = ts.map(t => new Date(t * 1000).toLocaleDateString());
                const isAnnual = this.scaleMode === 'annualized';

                // Header
                let thead = '<thead><tr><th>Date</th>';
                for (const s of symbols) thead += `<th>${s}</th>`;
                thead += '</tr></thead>';

                // Body with returns (log). If annualized, scale daily log return by 252
                let tbody = '<tbody>';
                for (let i = 0; i < minLen; i++) {
                    tbody += `<tr><td>${dateStrings[i]}</td>`;
                    for (const s of symbols) {
                        const rArr = (results[s] && results[s].returns) ? results[s].returns.slice(-minLen) : [];
                        // Apply proper annualization: mean_daily_log * 252 for annualized log returns
                        const r = rArr[i] != null ? (isAnnual ? rArr[i] * 252 : rArr[i]) : '';
                        tbody += `<td>${r === '' ? '' : (r * 100).toFixed(2)}%</td>`;
                    }
                    tbody += '</tr>';
                }
                tbody += '</tbody>';

                return `
                    <div class="analysis-card adj-table-card">
                        <div class="adj-table-header">
                            <h3><i class="fas fa-table"></i> Historical Log Returns (${isAnnual ? 'Annualized' : 'Daily'})</h3>
                            <button class="download-excel-btn" onclick="portfolio.downloadReturnsCSV()"><i class="fas fa-file-excel"></i> Download to Excel</button>
                        </div>
                        <div class="adj-table-wrapper">
                            <table class="adj-table">
                                ${thead}
                                ${tbody}
                            </table>
                        </div>
                    </div>
                `;
            }

            downloadReturnsCSV() {
                const symbols = Array.from(this.portfolio.keys());
                if (symbols.length === 0) return;
                const results = this.lastAnalysisResults || {};
                const lengths = symbols.map(s => (results[s] && results[s].returns ? results[s].returns.length : 0)).filter(n => n > 0);
                if (lengths.length === 0) return;
                const minLen = Math.min(...lengths);
                const first = this.portfolio.get(symbols[0]);
                const ts = (first && first.timestamps) ? first.timestamps.slice(-minLen) : [];
                if (ts.length !== minLen) return;
                const isAnnual = this.scaleMode === 'annualized';

                const header = ['Date', ...symbols];
                const rows = [header];
                for (let i = 0; i < minLen; i++) {
                    const dateStr = new Date(ts[i] * 1000).toISOString().slice(0,10);
                    const row = [dateStr];
                    for (const s of symbols) {
                        const rArr = (results[s] && results[s].returns) ? results[s].returns.slice(-minLen) : [];
                        // Apply proper annualization: mean_daily_log * 252 for annualized log returns
                        const r = rArr[i] != null ? (isAnnual ? rArr[i] * 252 : rArr[i]) : '';
                        row.push(r === '' ? '' : (r * 100).toFixed(2));
                    }
                    rows.push(row);
                }

                const csvContent = rows.map(r => r.map(cell => {
                    const str = String(cell);
                    return (str.includes(',') || str.includes('"')) ? '"' + str.replace(/\"/g, '""') + '"' : str;
                }).join(',')).join('\r\n');

                const blob = new Blob(["\uFEFF" + csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                const startDate = document.getElementById('startDate').value;
                const endDate = document.getElementById('endDate').value;
                a.href = url;
                a.download = `log_returns_${isAnnual ? 'annualized' : 'daily'}_${startDate}_to_${endDate}.csv`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            scrollAdjTable(direction) {
                const wrapper = document.querySelector('.adj-table-wrapper');
                if (!wrapper) return;
                const amount = Math.max(120, Math.floor(wrapper.clientHeight * 0.8));
                const delta = direction === 'up' ? -amount : amount;
                wrapper.scrollBy({ top: delta, behavior: 'smooth' });
            }

            showAnalysisLoading() {
                const resultsDiv = document.getElementById('analysisResults');
                resultsDiv.innerHTML = `
                    <div class="loading">
                        <div class="spinner"></div>
                        <p>Calculating financial analysis...</p>
                    </div>
                `;
            }

                         async displayAnalysisResults(results) {
                 const resultsDiv = document.getElementById('analysisResults');
                  
                  // Persist results for re-render on scale switch
                  this.lastAnalysisResults = results;
                 
                 // Get sector allocation data
                 const sectorData = await this.getSectorAllocation();
                 
                 // Use current scaled portfolio values if available
                 const portfolioScope = results.portfolio.current || results.portfolio[this.scaleMode];
                 
                 // Ensure all portfolio values have defaults
                 const safePortfolioScope = {
                     mean: portfolioScope.mean || 0,
                     stdDev: portfolioScope.stdDev || 0,
                     beta: portfolioScope.beta || 0,
                     vaR: portfolioScope.vaR || 0,
                     sharpe: portfolioScope.sharpe || 0,
                     cov: portfolioScope.cov || 0
                 };
                 
                 let html = `
                                           <div class="portfolio-summary">
                          <h3><i class="fas fa-chart-pie"></i> Portfolio Summary - Equal Weight (${this.scaleMode === 'daily' ? 'Daily' : 'Annualized'})</h3>
                         <div class="summary-grid">
                             <div class="summary-item">
                                  <div class="summary-value">${(safePortfolioScope.mean * 100).toFixed(2)}%</div>
                                 <div class="summary-label">Average Return</div>
                             </div>
                             <div class="summary-item">
                                  <div class="summary-value">${(safePortfolioScope.stdDev * 100).toFixed(2)}%</div>
                                 <div class="summary-label">Standard Deviation</div>
                             </div>

                             <div class="summary-item">
                                  <div class="summary-value">${(safePortfolioScope.vaR * 100).toFixed(2)}%</div>
                                  <div class="summary-label">VaR ${(this.varLevel * 100).toFixed(0)}%</div>
                              </div>
                              <div class="summary-item">
                                  <div class="summary-value">${safePortfolioScope.sharpe.toFixed(3)}</div>
                                  <div class="summary-label">Sharpe</div>
                             </div>
                         </div>
                     </div>
                    
                    <div class="analysis-grid">
                        <div class="sector-allocation-card">
                            <h3><i class="fas fa-chart-pie"></i> Sector Allocation - Equal Weight</h3>
                            <div class="sector-content">
                                <div class="donut-section">
                                    <div class="donut-chart-container">
                                        <div class="donut-chart" id="sectorDonutChart"></div>
                                    </div>
                                </div>
                                <div class="sector-percentages">
                                    <div class="sector-legend" id="sectorLegend"></div>
                                </div>
                            </div>
                        </div>
                        
                                                  <div class="analysis-card wide-card">
                              <h3><i class="fas fa-list"></i> Individual Stocks (${this.scaleMode === 'daily' ? 'Daily' : 'Annualized'})</h3>
                             <div class="stock-metrics-table">
                                 <div class="table-header">
                                     <div class="table-cell sortable" data-sort="symbol">Stock</div>
                                     <div class="table-cell sortable" data-sort="mean">Avg Return</div>
                                      <div class="table-cell sortable" data-sort="variance">Variance</div>
                                     <div class="table-cell sortable" data-sort="stdDev">Std Dev</div>
                                     <div class="table-cell sortable" data-sort="vaR">VaR</div>
                                     <div class="table-cell sortable" data-sort="cov">CoV</div>
                                      <div class="table-cell sortable" data-sort="sharpe">Sharpe</div>
                                 </div>
                 `;

                 // Create array of stock data for sorting
                 const stockData = [];
                 Object.keys(results).forEach(symbol => {
                     if (symbol !== 'portfolio') {
                         const stock = results[symbol];
                      const scope = stock[this.scaleMode];
                         // Use current scaled values if available, otherwise fall back to selected scope
                         const dataScope = stock.current || scope;
                         stockData.push({
                             symbol: symbol,
                          lastReturn: dataScope.lastReturn || 0,
                          mean: dataScope.mean || 0,
                          variance: dataScope.variance || 0,
                          stdDev: dataScope.stdDev || 0,
                          vaR: dataScope.vaR || 0,
                          cov: dataScope.cov || 0,
                          sharpe: dataScope.sharpe || 0,

                             html: `
                                 <div class="table-row">
                                     <div class="table-cell stock-name">${symbol}</div>
                                      <div class="table-cell ${(dataScope.mean || 0) >= 0 ? 'positive' : 'negative'}">${((dataScope.mean || 0) * 100).toFixed(2)}%</div>
                                      <div class="table-cell">${((dataScope.variance || 0) * 10000).toFixed(2)}%</div>
                                      <div class="table-cell">${((dataScope.stdDev || 0) * 100).toFixed(2)}%</div>
                                      <div class="table-cell">${((dataScope.vaR || 0) * 100).toFixed(2)}%</div>
                                      <div class="table-cell">${(dataScope.cov || 0).toFixed(2)}</div>
                                      <div class="table-cell">${(dataScope.sharpe || 0).toFixed(3)}</div>
                                 </div>
                             `
                         });
                     }
                 });

                 // Add sorted stock rows
                 stockData.forEach(stock => {
                     html += stock.html;
                 });

                 html += `
                             </div>
                         </div>
                     </div>
                     
                     <!-- Most Volatile Stock Analysis -->
                     <div class="analysis-card wide-card">
                         <h3><i class="fas fa-chart-line"></i> Most Volatile Stock Analysis</h3>
                         ${this.getMostVolatileStockAnalysis(results)}
                     </div>
                     
                     <!-- Single Index Model & CAPM Analysis -->
                     <div class="analysis-card wide-card" style="display: block !important; margin-bottom: 20px; padding: 20px; background: #e3f2fd; border: 3px solid #2196f3; border-radius: 8px; box-shadow: 0 4px 15px rgba(33, 150, 243, 0.3);">
                         <h3 style="color: #1976d2; font-weight: bold;"><i class="fas fa-chart-bar"></i> 1. Single Index Model & CAPM Analysis (SPY Benchmark) - Filtered Date Range</h3>
                         <div style="margin-bottom: 20px;">
                             <button id="calculateCAPMBtn" class="calculate-btn" style="background: linear-gradient(135deg, #667eea, #764ba2); padding: 10px 20px; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: bold;">
                                 <i class="fas fa-calculator"></i> Calculate CAPM & Single Index Model
                             </button>
                         </div>
                         <div id="capmResults" style="display: block; min-height: 100px;">
                             <div style="text-align: center; padding: 20px; color: #666;">
                                 <i class="fas fa-spinner fa-spin" style="margin-right: 10px;"></i>
                                 CAPM analysis will be calculated automatically when portfolio data is available...
                             </div>
                         </div>
                     </div>
                     
                     <!-- Normality Test Analysis -->
                     <div class="analysis-card wide-card" style="display: block !important; margin-bottom: 20px; padding: 20px; background: #e8f5e8; border: 3px solid #4caf50; border-radius: 8px; box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);">
                         <h3 style="color: #2e7d32; font-weight: bold;"><i class="fas fa-chart-line"></i> 2. Normality Test Analysis (Jarque-Bera Test)</h3>
                         <div style="margin-bottom: 20px;">
                             <button id="calculateNormalityBtn" class="calculate-btn" style="background: linear-gradient(135deg, #2ed573, #00b894); padding: 10px 20px; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: bold;">
                                 <i class="fas fa-flask"></i> Perform Normality Tests
                             </button>
                         </div>
                         <div id="normalityResults" style="display: block; min-height: 100px;">
                             <div style="text-align: center; padding: 20px; color: #666;">
                                 <i class="fas fa-spinner fa-spin" style="margin-right: 10px;"></i>
                                 Normality tests will be performed automatically when portfolio data is available...
                             </div>
                         </div>
                     </div>
                     
                     <!-- Normal Distribution Graphs Carousel -->
                     <div class="analysis-card wide-card" style="display: block !important; margin-bottom: 20px; padding: 20px; background: #fff3e0; border: 3px solid #ff9800; border-radius: 8px; box-shadow: 0 4px 15px rgba(255, 152, 0, 0.3);">
                         <h3 style="color: #e65100; font-weight: bold;"><i class="fas fa-chart-bar"></i> 3. Normal Distribution Comparison Graphs</h3>
                         <div style="margin-bottom: 20px;">
                             <button id="generateGraphsBtn" class="calculate-btn" style="background: linear-gradient(135deg, #ff6b6b, #ee5a24); padding: 10px 20px; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: bold;">
                                 <i class="fas fa-chart-area"></i> Generate Distribution Graphs
                             </button>
                         </div>
                         <div id="graphsResults" style="display: block; min-height: 100px;">
                             <div style="text-align: center; padding: 20px; color: #666;">
                                 <i class="fas fa-spinner fa-spin" style="margin-right: 10px;"></i>
                                 Distribution graphs will be generated automatically when portfolio data is available...
                             </div>
                         </div>
                     </div>
                     
                      <div class="analysis-card wide-card">
                                          <div class="heatmaps-grid">
                    <div class="heatmap-card">
                        <div class="heatmap-header">
                            <h3 class="heatmap-title" id="heatmapTitle">
                                <i class="fas fa-border-all"></i> Variance-Covariance Heatmap (${this.scaleMode === 'daily' ? 'Daily' : 'Annualized'})
                            </h3>
                            <div class="heatmap-nav">
                                <button class="heatmap-nav-btn" id="prevHeatmap">
                                    <i class="fas fa-chevron-left"></i>
                                </button>
                                <span class="heatmap-nav-indicator" id="heatmapIndicator">1 of 2</span>
                                <button class="heatmap-nav-btn" id="nextHeatmap">
                                    <i class="fas fa-chevron-right"></i>
                                </button>
                            </div>
                        </div>
                        <div id="heatmapContainer" class="cov-heatmap-container"></div>
                    </div>
                </div>
                      </div>
                      
                      <div class="analysis-card wide-card" style="display: block !important; margin-bottom: 20px; padding: 20px; background: #f3e5f5; border: 3px solid #9c27b0; border-radius: 8px; box-shadow: 0 4px 15px rgba(156, 39, 176, 0.3);">
                          <h3 style="color: #6a1b9a; font-weight: bold;"><i class="fas fa-chart-area"></i> 4. Efficient Frontier Analysis</h3>
                          <div style="margin-bottom: 15px;">
                              <label style="font-size:12px;margin-right:8px; font-weight: bold;">Number of Simulations:</label>
                              <input id="frontierSimulations" type="number" min="1000" max="100000" value="10000" 
                                     style="width: 100px; padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
                              <button id="generateFrontierBtn" style="margin-left: 10px; padding: 8px 16px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: bold;">
                                  <i class="fas fa-chart-line"></i> Generate Frontier
                              </button>
                              <button id="downloadFrontierBtn" style="margin-left: 10px; padding: 6px 12px; background: #2ed573; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; display: none;">
                                  <i class="fas fa-download"></i> Download CSV
                              </button>
                          </div>
                          <div id="frontierPlot" style="height: 500px; border: 2px solid #9c27b0; border-radius: 8px; background: #faf5ff; display: flex; align-items: center; justify-content: center; color: #6a1b9a;">
                              <div style="text-align: center;">
                                  <i class="fas fa-chart-line" style="font-size: 48px; margin-bottom: 10px; opacity: 0.7;"></i>
                                  <p style="font-weight: bold;">Efficient frontier will be generated automatically when portfolio data is available</p>
                                  <p style="font-size: 12px; margin-top: 10px; opacity: 0.8;">Or click "Generate Frontier" to recalculate manually</p>
                              </div>
                          </div>
                          <div id="frontierSummary" style="margin-top: 15px; display: none;">
                              <h4>Optimal Portfolios:</h4>
                              <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin-top: 10px;">
                                  <div id="minVariancePortfolio" class="portfolio-detail"></div>
                                  <div id="maxSharpePortfolio" class="portfolio-detail"></div>
                                  <div id="maxReturnPortfolio" class="portfolio-detail"></div>
                                  <div id="minVarianceConstrainedPortfolio" class="portfolio-detail"></div>
                                  <div id="maxSharpeConstrainedPortfolio" class="portfolio-detail"></div>
                              </div>
                          </div>
                                            </div>
                    ${this.buildHistoricalReturnsTable()}
                    

                 `;

                                 resultsDiv.innerHTML = html;
                 
                 // Render sector allocation donut chart
                 this.renderSectorDonutChart(sectorData);
                 
                 // Add sorting functionality
                 this.setupTableSorting();
                this.renderVarianceCovarianceHeatmap(results);
                

                
                // Set up efficient frontier event listeners
                const genBtn = document.getElementById('generateFrontierBtn');
                if (genBtn) genBtn.onclick = () => this.generateEfficientFrontier();
                
                const downloadBtn = document.getElementById('downloadFrontierBtn');
                if (downloadBtn) downloadBtn.onclick = () => this.downloadFrontierData();
                
                // Set up CAPM event listener
                const capmBtn = document.getElementById('calculateCAPMBtn');
                if (capmBtn) capmBtn.onclick = () => this.calculateCAPMAndSingleIndexModel();
                
                // Set up Normality Test event listener
                const normalityBtn = document.getElementById('calculateNormalityBtn');
                if (normalityBtn) normalityBtn.onclick = () => this.performNormalityTests();
                
                // Set up Distribution Graphs event listener
                const graphsBtn = document.getElementById('generateGraphsBtn');
                if (graphsBtn) graphsBtn.onclick = () => this.generateDistributionGraphs();
            }

                         getBetaRiskClass(beta) {
                 if (beta < 0.8) return 'low-risk';
                 if (beta < 1.2) return 'medium-risk';
                 return 'high-risk';
             }

             setupTableSorting() {
                 const table = document.querySelector('.stock-metrics-table');
                 if (!table) return;

                 const headers = table.querySelectorAll('.table-header .sortable');
                 let currentSort = { column: null, direction: 'asc' };

                 headers.forEach(header => {
                     header.addEventListener('click', () => {
                         const sortColumn = header.getAttribute('data-sort');
                         
                         // Update sort direction
                         if (currentSort.column === sortColumn) {
                             currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
                         } else {
                             currentSort.column = sortColumn;
                             currentSort.direction = 'asc';
                         }

                         // Update header classes
                         headers.forEach(h => {
                             h.classList.remove('sort-asc', 'sort-desc');
                         });
                         header.classList.add(`sort-${currentSort.direction}`);

                         // Sort the table
                         this.sortTable(table, sortColumn, currentSort.direction);
                     });
                 });
             }

                          sortTable(table, column, direction) {
                 const tbody = table.querySelector('.table-header').nextElementSibling;
                 if (!tbody) return;
 
                 const rows = Array.from(table.querySelectorAll('.table-row'));
                 const stockData = [];
 
                 // Extract data from rows
                 rows.forEach(row => {
                     const cells = row.querySelectorAll('.table-cell');
                     stockData.push({
                         symbol: cells[0].textContent,
                         mean: parseFloat(cells[1].textContent.replace('%', '')),
                          variance: parseFloat(cells[2].textContent.replace('%', '')),
                          stdDev: parseFloat(cells[3].textContent.replace('%', '')),
                          vaR: parseFloat(cells[4].textContent.replace('%', '')),
                          cov: parseFloat(cells[5].textContent),
  
                                                      beta: parseFloat(cells[6].textContent),
                            sharpe: parseFloat(cells[7].textContent),
                         element: row
                     });
                 });
 
                 // Sort the data
                 stockData.sort((a, b) => {
                     let aValue, bValue;
                     
                     switch (column) {
                         case 'symbol':
                             aValue = a.symbol;
                             bValue = b.symbol;
                             break;
                         case 'mean':
                             aValue = a.mean;
                             bValue = b.mean;
                             break;
                         case 'variance':
                              aValue = a.variance;
                              bValue = b.variance;
                             break;
                         case 'stdDev':
                             aValue = a.stdDev;
                             bValue = b.stdDev;
                             break;
                         case 'vaR':
                             aValue = a.vaR;
                             bValue = b.vaR;
                             break;
                         case 'cov':
                             aValue = a.cov;
                             bValue = b.cov;
                             break;
                          
                          case 'sharpe':
                              aValue = a.sharpe;
                              bValue = b.sharpe;
                              break;
                          
                         default:
                             return 0;
                     }
 
                     if (direction === 'asc') {
                         return aValue > bValue ? 1 : -1;
                     } else {
                         return aValue < bValue ? 1 : -1;
                     }
                 });
 
                 // Reorder the DOM elements
                 const container = table.querySelector('.table-header').parentNode;
                 stockData.forEach(stock => {
                     container.appendChild(stock.element);
                 });
             }

             async getSectorAllocation() {
                 const symbols = Array.from(this.portfolio.keys());
                 const sectorData = {};
                 
                 // Predefined sector mapping
                 const sectorMapping = {
                     'BBAR': 'Servicios Financieros',
                     'BMA': 'Servicios Financieros',
                     'GGAL': 'Servicios Financieros',
                     'SUPV': 'Servicios Financieros',
                     'CEPU': 'Energía',
                     'EDN': 'Energía',
                     'PAM': 'Energía',
                     'TGS': 'Energía',
                     'YPF': 'Energía',
                     'IRS': 'Bienes Raíces',
                     'LOMA': 'Materiales',
                     'TS': 'Materiales',
                     'CRESY': 'Agroindustria',
                     'MELI': 'Tecnología',
                     'TEO': 'Telecomunicaciones'
                 };
                 
                 // Predefined sector colors with fintech design
                 const sectorColors = {
                     'Servicios Financieros': '#667eea',
                     'Energía': '#ff6b6b',
                     'Bienes Raíces': '#4ecdc4',
                     'Materiales': '#45b7d1',
                     'Agroindustria': '#96ceb4',
                     'Tecnología': '#fdcb6e',
                     'Telecomunicaciones': '#e17055'
                 };
                 
                 try {
                     for (const symbol of symbols) {
                         const sector = sectorMapping[symbol] || 'Otros';
                         sectorData[sector] = (sectorData[sector] || 0) + 1;
                     }
                     
                     // Convert to array format for chart
                     const sectors = Object.keys(sectorData);
                     return sectors.map((sector) => ({
                         sector: sector,
                         count: sectorData[sector],
                         percentage: (sectorData[sector] / symbols.length) * 100,
                         color: sectorColors[sector] || '#95a5a6'
                     }));
                 } catch (error) {
                     console.error('Error calculating sector allocation:', error);
                     return [];
                 }
             }

             renderSectorDonutChart(sectorData) {
                 const donutChart = document.getElementById('sectorDonutChart');
                 const sectorLegend = document.getElementById('sectorLegend');
                 
                 if (!donutChart || !sectorLegend) return;
                 
                 // Clear previous content
                 donutChart.innerHTML = '';
                 sectorLegend.innerHTML = '';
                 
                 if (sectorData.length === 0) {
                     donutChart.innerHTML = '<p style="text-align: center; color: #666; margin-top: 100px;">No stocks selected</p>';
                     return;
                 }
                 
                 // Sort sectors by percentage in descending order
                 const sortedSectorData = [...sectorData].sort((a, b) => b.percentage - a.percentage);
                 
                 // Create SVG for donut chart
                 const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                 svg.setAttribute('width', '350');
                 svg.setAttribute('height', '350');
                 svg.setAttribute('viewBox', '0 0 350 350');
                 
                 // Calculate total percentage
                 const totalPercentage = sortedSectorData.reduce((sum, item) => sum + item.percentage, 0);
                 
                 // Create donut chart segments
                 let currentAngle = 0;
                 const centerX = 175;
                 const centerY = 175;
                 const radius = 120;
                 const innerRadius = 60;
                 
                 sortedSectorData.forEach((item, index) => {
                     const angle = (item.percentage / totalPercentage) * 2 * Math.PI;
                     const endAngle = currentAngle + angle;
                     
                     // Create path for donut segment
                     const x1 = centerX + radius * Math.cos(currentAngle);
                     const y1 = centerY + radius * Math.sin(currentAngle);
                     const x2 = centerX + radius * Math.cos(endAngle);
                     const y2 = centerY + radius * Math.sin(endAngle);
                     
                     const largeArcFlag = angle > Math.PI ? 1 : 0;
                     
                     const outerArc = `A ${radius} ${radius} 0 ${largeArcFlag} 1 ${x2} ${y2}`;
                     const innerArc = `A ${innerRadius} ${innerRadius} 0 ${largeArcFlag} 0 ${centerX + innerRadius * Math.cos(currentAngle)} ${centerY + innerRadius * Math.sin(currentAngle)}`;
                     
                     const pathData = `M ${x1} ${y1} ${outerArc} L ${centerX + innerRadius * Math.cos(endAngle)} ${centerY + innerRadius * Math.sin(endAngle)} ${innerArc} Z`;
                     
                     const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                     path.setAttribute('d', pathData);
                     path.setAttribute('fill', item.color);
                     path.setAttribute('class', 'donut-segment');
                     path.setAttribute('data-sector', item.sector);
                     
                     // Add hover effect
                     path.addEventListener('mouseenter', () => {
                         path.style.opacity = '0.8';
                         path.style.transform = 'scale(1.02)';
                     });
                     
                     path.addEventListener('mouseleave', () => {
                         path.style.opacity = '1';
                         path.style.transform = 'scale(1)';
                     });
                     
                     svg.appendChild(path);
                     
                     // Add sector label on the chart segment
                     if (item.percentage > 5) { // Only show labels for segments > 5%
                         const labelAngle = currentAngle + (angle / 2);
                         const labelRadius = radius + 20;
                         const labelX = centerX + labelRadius * Math.cos(labelAngle);
                         const labelY = centerY + labelRadius * Math.sin(labelAngle);
                         
                         // Create background for text
                         const textBackground = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                         const textWidth = item.sector.length * 6;
                         const textHeight = 16;
                         textBackground.setAttribute('x', labelX - textWidth / 2);
                         textBackground.setAttribute('y', labelY - textHeight / 2);
                         textBackground.setAttribute('width', textWidth);
                         textBackground.setAttribute('height', textHeight);
                         textBackground.setAttribute('fill', 'white');
                         textBackground.setAttribute('opacity', '0.9');
                         textBackground.setAttribute('rx', '3');
                         
                         // Create text element
                         const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                         text.setAttribute('x', labelX);
                         text.setAttribute('y', labelY + 4);
                         text.setAttribute('text-anchor', 'middle');
                         text.setAttribute('font-size', '10');
                         text.setAttribute('font-weight', '600');
                         text.setAttribute('fill', '#333');
                         text.textContent = item.sector;
                         
                         svg.appendChild(textBackground);
                         svg.appendChild(text);
                     }
                     
                     currentAngle = endAngle;
                 });
                 
                 // Add center text
                 const centerText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                 centerText.setAttribute('x', centerX);
                 centerText.setAttribute('y', centerY - 5);
                 centerText.setAttribute('text-anchor', 'middle');
                 centerText.setAttribute('font-size', '14');
                 centerText.setAttribute('font-weight', '600');
                 centerText.setAttribute('fill', '#333');
                 centerText.textContent = 'Sectors';
                 
                 const centerSubText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                 centerSubText.setAttribute('x', centerX);
                 centerSubText.setAttribute('y', centerY + 10);
                 centerSubText.setAttribute('text-anchor', 'middle');
                 centerSubText.setAttribute('font-size', '12');
                 centerSubText.setAttribute('fill', '#666');
                 centerSubText.textContent = 'Equal Weight';
                 
                 svg.appendChild(centerText);
                 svg.appendChild(centerSubText);
                 
                 donutChart.appendChild(svg);
                 
                 // Create legend with sector names and percentages
                 sortedSectorData.forEach((item, index) => {
                     const legendItem = document.createElement('div');
                     legendItem.className = 'sector-item';
                     legendItem.style.cssText = `
                         display: flex;
                         align-items: center;
                         justify-content: space-between;
                         padding: 8px 0;
                         border-bottom: 1px solid #f0f0f0;
                         font-size: 0.9rem;
                     `;
                     
                     const leftSide = document.createElement('div');
                     leftSide.style.cssText = `
                         display: flex;
                         align-items: center;
                         gap: 10px;
                     `;
                     
                     const colorDot = document.createElement('div');
                     colorDot.style.cssText = `
                         width: 12px;
                         height: 12px;
                         border-radius: 50%;
                         background: ${item.color};
                         flex-shrink: 0;
                     `;
                     
                     const sectorName = document.createElement('span');
                     sectorName.style.cssText = `
                         font-weight: 600;
                         color: #333;
                     `;
                     sectorName.textContent = item.sector;
                     
                     const rightSide = document.createElement('div');
                     rightSide.style.cssText = `
                         display: flex;
                         align-items: center;
                         gap: 8px;
                     `;
                     
                     const percentage = document.createElement('span');
                     percentage.style.cssText = `
                         font-weight: 700;
                         color: #667eea;
                         font-size: 1rem;
                     `;
                     percentage.textContent = `${item.percentage.toFixed(1)}%`;
                     
                     const count = document.createElement('span');
                     count.style.cssText = `
                         color: #666;
                         font-size: 0.8rem;
                     `;
                     count.textContent = `(${item.count} stock${item.count > 1 ? 's' : ''})`;
                     
                     leftSide.appendChild(colorDot);
                     leftSide.appendChild(sectorName);
                     rightSide.appendChild(percentage);
                     rightSide.appendChild(count);
                     
                     legendItem.appendChild(leftSide);
                     legendItem.appendChild(rightSide);
                     
                     sectorLegend.appendChild(legendItem);
                 });
             }

             getMostVolatileStockAnalysis(results) {
                 // Find the most volatile stock based on standard deviation
                 let mostVolatileStock = null;
                 let highestVolatility = -1;
                 
                 Object.keys(results).forEach(symbol => {
                     if (symbol !== 'portfolio') {
                         const stock = results[symbol];
                         const scope = stock[this.scaleMode];
                         const dataScope = stock.current || scope;
                         const volatility = dataScope.stdDev || 0;
                         
                         if (volatility > highestVolatility) {
                             highestVolatility = volatility;
                             mostVolatileStock = {
                                 symbol: symbol,
                                 volatility: volatility,
                                 mean: dataScope.mean || 0,
                                 variance: dataScope.variance || 0,
                                 vaR: dataScope.vaR || 0,
                                 cov: dataScope.cov || 0,
                                 sharpe: dataScope.sharpe || 0
                             };
                         }
                     }
                 });
                 
                 if (!mostVolatileStock) {
                     return '<p style="text-align: center; color: #666;">No stock data available for volatility analysis.</p>';
                 }
                 
                 // Determine volatility classification
                 const volatilityPercent = (mostVolatileStock.volatility * 100).toFixed(2);
                 let volatilityClass = 'low';
                 let volatilityDescription = 'Low volatility';
                 
                 if (mostVolatileStock.volatility > 0.03) { // 3% daily volatility
                     volatilityClass = 'high';
                     volatilityDescription = 'High volatility';
                 } else if (mostVolatileStock.volatility > 0.02) { // 2% daily volatility
                     volatilityClass = 'medium';
                     volatilityDescription = 'Medium volatility';
                 }
                 
                 // Generate justification
                 const justification = this.generateVolatilityJustification(mostVolatileStock, volatilityClass);
                 
                 return `
                     <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; align-items: start;">
                         <div style="background: linear-gradient(135deg, #667eea, #764ba2); color: white; padding: 25px; border-radius: 15px; text-align: center;">
                             <h4 style="margin: 0 0 15px 0; font-size: 1.3rem;">🏆 Most Volatile Stock</h4>
                             <div style="font-size: 2.5rem; font-weight: 700; margin-bottom: 10px;">${mostVolatileStock.symbol}</div>
                             <div style="font-size: 1.2rem; margin-bottom: 20px;">${volatilityDescription}</div>
                             <div style="font-size: 3rem; font-weight: 700; margin-bottom: 10px;">${volatilityPercent}%</div>
                             <div style="font-size: 0.9rem; opacity: 0.9;">Daily Standard Deviation</div>
                         </div>
                         
                         <div style="background: #f8f9fa; padding: 25px; border-radius: 15px; border-left: 4px solid #667eea;">
                             <h4 style="margin: 0 0 20px 0; color: #333; font-size: 1.2rem;">📊 Volatility Analysis</h4>
                             <div style="margin-bottom: 15px;">
                                 <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                     <span style="color: #666;">Mean Return:</span>
                                     <span style="font-weight: 600; color: ${mostVolatileStock.mean >= 0 ? '#2ed573' : '#ff4757'}">${(mostVolatileStock.mean * 100).toFixed(2)}%</span>
                                 </div>
                                 <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                     <span style="color: #666;">Variance:</span>
                                     <span style="font-weight: 600; color: #333;">${(mostVolatileStock.variance * 10000).toFixed(2)}%</span>
                                 </div>
                                 <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                     <span style="color: #666;">VaR (5%):</span>
                                     <span style="font-weight: 600; color: #ff4757;">${(mostVolatileStock.vaR * 100).toFixed(2)}%</span>
                                 </div>
                                 <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                     <span style="color: #666;">Coefficient of Variation:</span>
                                     <span style="font-weight: 600; color: #333;">${mostVolatileStock.cov.toFixed(2)}</span>
                                 </div>
                                 <div style="display: flex; justify-content: space-between;">
                                     <span style="color: #666;">Sharpe Ratio:</span>
                                     <span style="font-weight: 600; color: ${mostVolatileStock.sharpe >= 0 ? '#2ed573' : '#ff4757'}">${mostVolatileStock.sharpe.toFixed(3)}</span>
                                 </div>
                             </div>
                             
                             <div style="background: white; padding: 20px; border-radius: 10px; margin-top: 20px;">
                                 <h5 style="margin: 0 0 15px 0; color: #333; font-size: 1.1rem;">🎯 Justification</h5>
                                 <p style="margin: 0; color: #555; line-height: 1.6; font-size: 0.95rem;">${justification}</p>
                             </div>
                         </div>
                     </div>
                 `;
             }

             generateVolatilityJustification(stock, volatilityClass) {
                 const volatilityPercent = (stock.volatility * 100).toFixed(2);
                 const meanPercent = (stock.mean * 100).toFixed(2);
                 const sharpeRatio = stock.sharpe.toFixed(3);
                 
                 let justification = `${stock.symbol} exhibits the highest volatility in the portfolio with a daily standard deviation of ${volatilityPercent}%. `;
                 
                 if (volatilityClass === 'high') {
                     justification += `This represents high volatility, indicating significant price fluctuations. `;
                     if (stock.mean > 0) {
                         justification += `Despite the high volatility, the stock shows positive returns (${meanPercent}% daily mean), suggesting potential for high rewards but with elevated risk. `;
                     } else {
                         justification += `The high volatility combined with negative returns (${meanPercent}% daily mean) indicates significant downside risk. `;
                     }
                 } else if (volatilityClass === 'medium') {
                     justification += `This represents moderate volatility, indicating reasonable price movements. `;
                     if (stock.mean > 0) {
                         justification += `The moderate volatility with positive returns (${meanPercent}% daily mean) suggests a balanced risk-return profile. `;
                     } else {
                         justification += `The moderate volatility with negative returns (${meanPercent}% daily mean) indicates some downside risk. `;
                     }
                 } else {
                     justification += `This represents low volatility, indicating stable price movements. `;
                     if (stock.mean > 0) {
                         justification += `The low volatility with positive returns (${meanPercent}% daily mean) suggests a conservative investment with steady gains. `;
                     } else {
                         justification += `The low volatility with negative returns (${meanPercent}% daily mean) indicates consistent but modest losses. `;
                     }
                 }
                 
                 justification += `The Sharpe ratio of ${sharpeRatio} ${stock.sharpe >= 0 ? 'suggests reasonable risk-adjusted returns' : 'indicates poor risk-adjusted performance'}. `;
                 
                 if (stock.cov > 2) {
                     justification += `The high coefficient of variation (${stock.cov.toFixed(2)}) indicates that volatility significantly exceeds the mean return, suggesting high relative risk.`;
                 } else if (stock.cov > 1) {
                     justification += `The moderate coefficient of variation (${stock.cov.toFixed(2)}) indicates balanced volatility relative to returns.`;
                 } else {
                     justification += `The low coefficient of variation (${stock.cov.toFixed(2)}) indicates that volatility is well-controlled relative to returns.`;
                 }
                 
                 return justification;
             }

             async calculateCAPMAndSingleIndexModel() {
                 try {
                     // Show loading state
                     const capmResultsDiv = document.getElementById('capmResults');
                     capmResultsDiv.innerHTML = '<div style="text-align: center; padding: 40px;"><div class="spinner"></div><p>Calculating CAPM and Single Index Model with SPY benchmark...</p></div>';
                     capmResultsDiv.style.display = 'block';
                     
                     // Get SPY data as benchmark
                     const spyData = await this.fetchSPYData();
                     if (!spyData) {
                         throw new Error('Failed to fetch SPY benchmark data');
                     }
                     
                     // Calculate CAPM for each stock
                     const capmAnalysisResults = await this.performCAPMAnalysis(spyData);
                     
                     // Display results
                     this.displayCAPMResults(capmAnalysisResults);
                     
                 } catch (error) {
                     console.error('CAPM calculation error:', error);
                     const capmResultsDiv = document.getElementById('capmResults');
                     capmResultsDiv.innerHTML = `<div style="text-align: center; padding: 40px; color: #ff4757;"><i class="fas fa-exclamation-triangle"></i><p>Error calculating CAPM: ${error.message}</p></div>`;
                     capmResultsDiv.style.display = 'block';
                 }
             }

             async fetchSPYData() {
                 const startDate = document.getElementById('startDate').value;
                 const endDate = document.getElementById('endDate').value;
                 
                 if (!startDate || !endDate) {
                     throw new Error('Please select both start and end dates');
                 }
                 
                 // Try to fetch SPY data using the same methods as other stocks
                 try {
                     const spyData = await this.fetchStockData('SPY');
                     return spyData;
                 } catch (error) {
                     console.warn('Failed to fetch real SPY data, using simulated data');
                     return this.generateSPYBenchmarkData(startDate, endDate);
                 }
             }

             generateSPYBenchmarkData(startDate, endDate) {
                 // Generate realistic SPY benchmark data
                 const start = new Date(startDate);
                 const end = new Date(endDate);
                 const days = Math.ceil((end - start) / (1000 * 60 * 60 * 24));
                 
                 const basePrice = 400; // Realistic SPY price
                 const volatility = 0.015; // 1.5% daily volatility for SPY
                 const drift = 0.0005; // Slight positive drift
                 
                 const prices = [];
                 const timestamps = [];
                 
                 let currentPrice = basePrice;
                 const startTimestamp = Math.floor(start.getTime() / 1000);
                 
                 for (let i = 0; i < days; i++) {
                     // Random walk with drift
                     const dailyReturn = (Math.random() - 0.5) * volatility + drift;
                     currentPrice *= (1 + dailyReturn);
                     
                     prices.push(Math.max(currentPrice, 0.01));
                     timestamps.push(startTimestamp + (i * 24 * 60 * 60));
                 }
                 
                 const latestIndex = prices.length - 1;
                 const previousIndex = Math.max(0, latestIndex - 1);
                 
                 return {
                     symbol: 'SPY',
                     name: 'SPDR S&P 500 ETF Trust',
                     price: prices[latestIndex],
                     change: prices[latestIndex] - prices[previousIndex],
                     changePercent: ((prices[latestIndex] - prices[previousIndex]) / prices[previousIndex]) * 100,
                     volume: 100000000, // High volume for SPY
                     high: Math.max(...prices),
                     low: Math.min(...prices),
                     open: prices[0],
                     close: prices[latestIndex],
                     timestamp: timestamps[latestIndex],
                     historicalData: prices,
                     timestamps: timestamps,
                     lastUpdate: new Date(),
                     dataAge: 0,
                     isRealData: true,
                     isAskPrice: false
                 };
             }

             async performCAPMAnalysis(spyData) {
                 const results = {};
                 const spyReturns = this.calculateReturns(spyData.historicalData);
                 const spyMean = spyReturns.reduce((sum, r) => sum + r, 0) / spyReturns.length;
                 const spyVariance = spyReturns.reduce((sum, r) => sum + Math.pow(r - spyMean, 2), 0) / spyReturns.length;
                 const spyStdDev = Math.sqrt(spyVariance);
                 
                 // Calculate risk-free rate (using current rate from the form)
                 const riskFreeRate = this.riskFreeRateAnnual / 252; // Convert to daily
                 
                 // Calculate market risk premium
                 const marketRiskPremium = spyMean - riskFreeRate;
                 
                 // Analyze each stock in portfolio
                 for (const [symbol, stockData] of this.portfolio) {
                     const stockReturns = this.calculateReturns(stockData.historicalData);
                     
                     // Align returns (use minimum length)
                     const minLength = Math.min(stockReturns.length, spyReturns.length);
                     const alignedStockReturns = stockReturns.slice(-minLength);
                     const alignedSpyReturns = spyReturns.slice(-minLength);
                     
                     // Calculate beta using covariance method
                     const stockMean = alignedStockReturns.reduce((sum, r) => sum + r, 0) / alignedStockReturns.length;
                     const covariance = this.calculateCovariance(alignedStockReturns, alignedSpyReturns, stockMean, spyMean);
                     const beta = covariance / spyVariance;
                     
                     // Calculate alpha (Jensen's Alpha)
                     const expectedReturn = riskFreeRate + beta * marketRiskPremium;
                     const actualReturn = stockMean;
                     const alpha = actualReturn - expectedReturn;
                     
                     // Calculate R-squared
                     const rSquared = this.calculateRSquared(alignedStockReturns, alignedSpyReturns, stockMean, spyMean);
                     
                     // Calculate residual standard error
                     const residualStdError = this.calculateResidualStdError(alignedStockReturns, alignedSpyReturns, alpha, beta);
                     
                     // Calculate Historic VaR (5%)
                     const historicVaR = this.calculateHistoricVaR(alignedStockReturns, 0.05);
                     
                     // Calculate Delta Normal VaR
                     const deltaNormalVaR = this.calculateDeltaNormalVaR(alignedStockReturns, 0.05);
                     
                     results[symbol] = {
                         symbol: symbol,
                         beta: beta,
                         alpha: alpha,
                         rSquared: rSquared,
                         expectedReturn: expectedReturn,
                         actualReturn: actualReturn,
                         historicVaR: historicVaR,
                         deltaNormalVaR: deltaNormalVaR,
                         residualStdError: residualStdError,
                         marketRiskPremium: marketRiskPremium,
                         riskFreeRate: riskFreeRate,
                         spyData: {
                             mean: spyMean,
                             stdDev: spyStdDev,
                             variance: spyVariance
                         }
                     };
                 }
                 
                 return results;
             }

             calculateReturns(prices) {
                 const returns = [];
                 for (let i = 1; i < prices.length; i++) {
                     returns.push((prices[i] - prices[i-1]) / prices[i-1]);
                 }
                 return returns;
             }

             calculateCovariance(returns1, returns2, mean1, mean2) {
                 let sum = 0;
                 for (let i = 0; i < returns1.length; i++) {
                     sum += (returns1[i] - mean1) * (returns2[i] - mean2);
                 }
                 return sum / returns1.length;
             }

             calculateRSquared(returns1, returns2, mean1, mean2) {
                 const covariance = this.calculateCovariance(returns1, returns2, mean1, mean2);
                 const variance1 = returns1.reduce((sum, r) => sum + Math.pow(r - mean1, 2), 0) / returns1.length;
                 const variance2 = returns2.reduce((sum, r) => sum + Math.pow(r - mean2, 2), 0) / returns2.length;
                 
                 return Math.pow(covariance / Math.sqrt(variance1 * variance2), 2);
             }

             calculateResidualStdError(returns1, returns2, alpha, beta) {
                 let sumSquaredResiduals = 0;
                 for (let i = 0; i < returns1.length; i++) {
                     const predicted = alpha + beta * returns2[i];
                     const residual = returns1[i] - predicted;
                     sumSquaredResiduals += residual * residual;
                 }
                 return Math.sqrt(sumSquaredResiduals / (returns1.length - 2));
             }

             calculateHistoricVaR(returns, confidenceLevel) {
                 // Sort returns in ascending order
                 const sortedReturns = [...returns].sort((a, b) => a - b);
                 
                 // Find the index for the VaR percentile
                 const varIndex = Math.floor(confidenceLevel * sortedReturns.length);
                 
                 // Return the VaR (negative because VaR represents a loss)
                 return -sortedReturns[varIndex];
             }

             calculateDeltaNormalVaR(returns, confidenceLevel) {
                 // Calculate mean and standard deviation
                 const mean = returns.reduce((sum, r) => sum + r, 0) / returns.length;
                 const variance = returns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / returns.length;
                 const stdDev = Math.sqrt(variance);
                 
                 // Z-score for normal distribution (approximation for 5% = 1.645)
                 const zScore = confidenceLevel === 0.05 ? 1.645 : 1.96; // 1.96 for 2.5%
                 
                 // Delta Normal VaR = mean - (z-score * standard deviation)
                 return mean - (zScore * stdDev);
             }

             displayCAPMResults(capmResults) {
                 const capmResultsDiv = document.getElementById('capmResults');
                 
                 let html = `
                     <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-bottom: 30px;">
                         <div style="background: linear-gradient(135deg, #667eea, #764ba2); color: white; padding: 25px; border-radius: 15px;">
                             <h4 style="margin: 0 0 20px 0; font-size: 1.3rem;">📊 Market Benchmark (SPY)</h4>
                             <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                                 <div>
                                     <div style="font-size: 0.9rem; opacity: 0.9;">Daily Mean Return</div>
                                     <div style="font-size: 1.5rem; font-weight: 700;">${(capmResults[Object.keys(capmResults)[0]].spyData.mean * 100).toFixed(3)}%</div>
                                 </div>
                                 <div>
                                     <div style="font-size: 0.9rem; opacity: 0.9;">Daily Std Dev</div>
                                     <div style="font-size: 1.5rem; font-weight: 700;">${(capmResults[Object.keys(capmResults)[0]].spyData.stdDev * 100).toFixed(3)}%</div>
                                 </div>
                                 <div>
                                     <div style="font-size: 0.9rem; opacity: 0.9;">Risk-Free Rate</div>
                                     <div style="font-size: 1.5rem; font-weight: 700;">${(capmResults[Object.keys(capmResults)[0]].riskFreeRate * 100).toFixed(3)}%</div>
                                 </div>
                                 <div>
                                     <div style="font-size: 0.9rem; opacity: 0.9;">Market Risk Premium</div>
                                     <div style="font-size: 1.5rem; font-weight: 700;">${(capmResults[Object.keys(capmResults)[0]].marketRiskPremium * 100).toFixed(3)}%</div>
                                 </div>
                             </div>
                         </div>
                         
                         <div style="background: #f8f9fa; padding: 25px; border-radius: 15px; border-left: 4px solid #667eea;">
                             <h4 style="margin: 0 0 20px 0; color: #333; font-size: 1.3rem;">📈 CAPM Summary</h4>
                             <p style="margin: 0; color: #555; line-height: 1.6;">
                                 The Capital Asset Pricing Model (CAPM) analyzes each stock's systematic risk (beta) 
                                 relative to the S&P 500 (SPY). Beta measures how much a stock moves with the market. 
                                 Alpha represents excess return beyond what CAPM predicts.
                             </p>
                         </div>
                     </div>
                     
                     <div style="background: white; border-radius: 15px; overflow: hidden; box-shadow: 0 4px 20px rgba(0,0,0,0.1);">
                         <div style="background: linear-gradient(135deg, #667eea, #764ba2); color: white; padding: 15px 20px;">
                             <h4 style="margin: 0; font-size: 1.2rem;">📋 Individual Stock CAPM Analysis</h4>
                         </div>
                         <div style="overflow-x: auto;">
                             <table style="width: 100%; border-collapse: collapse;">
                                 <thead>
                                     <tr style="background: #f8f9fa;">
                                         <th style="padding: 12px; text-align: left; border-bottom: 1px solid #e1e5e9; font-weight: 600;">Stock</th>
                                         <th style="padding: 12px; text-align: center; border-bottom: 1px solid #e1e5e9; font-weight: 600;">Beta</th>
                                         <th style="padding: 12px; text-align: center; border-bottom: 1px solid #e1e5e9; font-weight: 600;">Alpha</th>
                                         <th style="padding: 12px; text-align: center; border-bottom: 1px solid #e1e5e9; font-weight: 600;">R²</th>
                                         <th style="padding: 12px; text-align: center; border-bottom: 1px solid #e1e5e9; font-weight: 600;">Expected Return</th>
                                         <th style="padding: 12px; text-align: center; border-bottom: 1px solid #e1e5e9; font-weight: 600;">Actual Return</th>
                                         <th style="padding: 12px; text-align: center; border-bottom: 1px solid #e1e5e9; font-weight: 600;">Historic VaR (5%)</th>
                                         <th style="padding: 12px; text-align: center; border-bottom: 1px solid #e1e5e9; font-weight: 600;">Delta Normal VaR</th>
                                     </tr>
                                 </thead>
                                 <tbody>
                 `;
                 
                 Object.keys(capmResults).forEach(symbol => {
                     const result = capmResults[symbol];
                     const betaClass = result.beta > 1.2 ? 'high-risk' : result.beta < 0.8 ? 'low-risk' : 'medium-risk';
                     const alphaClass = result.alpha > 0 ? 'positive' : 'negative';
                     
                     html += `
                         <tr style="border-bottom: 1px solid #f0f0f0;">
                             <td style="padding: 12px; font-weight: 600; color: #333;">${symbol}</td>
                             <td style="padding: 12px; text-align: center; font-weight: 600; color: ${result.beta > 1.2 ? '#ff4757' : result.beta < 0.8 ? '#2ed573' : '#ffa502'};">${result.beta.toFixed(3)}</td>
                             <td style="padding: 12px; text-align: center; font-weight: 600; color: ${result.alpha > 0 ? '#2ed573' : '#ff4757'};">${(result.alpha * 100).toFixed(3)}%</td>
                             <td style="padding: 12px; text-align: center; font-weight: 600; color: #333;">${(result.rSquared * 100).toFixed(1)}%</td>
                             <td style="padding: 12px; text-align: center; font-weight: 600; color: #333;">${(result.expectedReturn * 100).toFixed(3)}%</td>
                             <td style="padding: 12px; text-align: center; font-weight: 600; color: ${result.actualReturn > 0 ? '#2ed573' : '#ff4757'};">${(result.actualReturn * 100).toFixed(3)}%</td>
                             <td style="padding: 12px; text-align: center; font-weight: 600; color: #ff4757;">${(result.historicVaR * 100).toFixed(3)}%</td>
                             <td style="padding: 12px; text-align: center; font-weight: 600; color: #ff4757;">${(result.deltaNormalVaR * 100).toFixed(3)}%</td>
                         </tr>
                     `;
                 });
                 
                 html += `
                                 </tbody>
                             </table>
                         </div>
                     </div>
                     
                     <div style="margin-top: 30px; background: #f8f9fa; padding: 25px; border-radius: 15px; border-left: 4px solid #667eea;">
                         <h4 style="margin: 0 0 20px 0; color: #333; font-size: 1.3rem;">📚 Interpretation Guide</h4>
                         <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px;">
                             <div>
                                 <h5 style="margin: 0 0 10px 0; color: #333;">Beta (β)</h5>
                                 <ul style="margin: 0; padding-left: 20px; color: #555;">
                                     <li><strong>β > 1.2:</strong> High systematic risk, moves more than market</li>
                                     <li><strong>0.8 ≤ β ≤ 1.2:</strong> Moderate systematic risk</li>
                                     <li><strong>β < 0.8:</strong> Low systematic risk, defensive stock</li>
                                 </ul>
                             </div>
                             <div>
                                 <h5 style="margin: 0 0 10px 0; color: #333;">Alpha (α)</h5>
                                 <ul style="margin: 0; padding-left: 20px; color: #555;">
                                     <li><strong>α > 0:</strong> Outperforms CAPM prediction</li>
                                     <li><strong>α < 0:</strong> Underperforms CAPM prediction</li>
                                     <li><strong>R²:</strong> % of variance explained by market</li>
                                 </ul>
                             </div>
                             <div>
                                 <h5 style="margin: 0 0 10px 0; color: #333;">Value at Risk (VaR)</h5>
                                 <ul style="margin: 0; padding-left: 20px; color: #555;">
                                     <li><strong>Historic VaR:</strong> Based on actual historical returns</li>
                                     <li><strong>Delta Normal VaR:</strong> Assumes normal distribution</li>
                                     <li><strong>5% VaR:</strong> Maximum expected loss with 95% confidence</li>
                                 </ul>
                             </div>
                         </div>
                     </div>
                 `;
                 
                 capmResultsDiv.innerHTML = html;
                 capmResultsDiv.style.display = 'block';
             }

             getCAPMAnalysis(results) {
                 return '<p style="text-align: center; color: #666;">Click "Calculate CAPM & Single Index Model" to perform the analysis.</p>';
             }

             async performNormalityTests() {
                 try {
                     // Show loading state
                     const normalityResultsDiv = document.getElementById('normalityResults');
                     normalityResultsDiv.innerHTML = '<div style="text-align: center; padding: 40px;"><div class="spinner"></div><p>Performing Jarque-Bera normality tests...</p></div>';
                     normalityResultsDiv.style.display = 'block';
                     
                     // Calculate normality tests for each stock
                     const normalityResults = this.calculateNormalityTests();
                     
                     // Display results
                     this.displayNormalityResults(normalityResults);
                     
                 } catch (error) {
                     console.error('Normality test error:', error);
                     const normalityResultsDiv = document.getElementById('normalityResults');
                     normalityResultsDiv.innerHTML = `<div style="text-align: center; padding: 40px; color: #ff4757;"><i class="fas fa-exclamation-triangle"></i><p>Error performing normality tests: ${error.message}</p></div>`;
                     normalityResultsDiv.style.display = 'block';
                 }
             }

             calculateNormalityTests() {
                 const results = {};
                 
                 // Analyze each stock in portfolio
                 for (const [symbol, stockData] of this.portfolio) {
                     const returns = this.calculateReturns(stockData.historicalData);
                     
                     // Calculate Jarque-Bera test statistics
                     const jarqueBeraResult = this.calculateJarqueBeraTest(returns);
                     
                     // Calculate additional normality statistics
                     const skewness = this.calculateSkewness(returns);
                     const kurtosis = this.calculateKurtosis(returns);
                     
                     // Perform Shapiro-Wilk test (simplified version)
                     const shapiroWilkResult = this.calculateShapiroWilkTest(returns);
                     
                     results[symbol] = {
                         symbol: symbol,
                         jarqueBera: jarqueBeraResult,
                         skewness: skewness,
                         kurtosis: kurtosis,
                         shapiroWilk: shapiroWilkResult,
                         sampleSize: returns.length,
                         isNormal: jarqueBeraResult.pValue > 0.05 && shapiroWilkResult.pValue > 0.05
                     };
                 }
                 
                 return results;
             }

             calculateJarqueBeraTest(returns) {
                 const n = returns.length;
                 const mean = returns.reduce((sum, r) => sum + r, 0) / n;
                 
                 // Calculate variance
                 const variance = returns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / n;
                 const stdDev = Math.sqrt(variance);
                 
                 // Calculate skewness
                 const skewness = returns.reduce((sum, r) => sum + Math.pow((r - mean) / stdDev, 3), 0) / n;
                 
                 // Calculate kurtosis
                 const kurtosis = returns.reduce((sum, r) => sum + Math.pow((r - mean) / stdDev, 4), 0) / n;
                 
                 // Jarque-Bera test statistic
                 const jbStatistic = n * (Math.pow(skewness, 2) / 6 + Math.pow(kurtosis - 3, 2) / 24);
                 
                 // Degrees of freedom = 2 (for skewness and kurtosis)
                 const degreesOfFreedom = 2;
                 
                 // Calculate p-value using chi-square distribution approximation
                 const pValue = this.calculateChiSquarePValue(jbStatistic, degreesOfFreedom);
                 
                 return {
                     statistic: jbStatistic,
                     pValue: pValue,
                     skewness: skewness,
                     kurtosis: kurtosis,
                     degreesOfFreedom: degreesOfFreedom
                 };
             }

             calculateSkewness(returns) {
                 const n = returns.length;
                 const mean = returns.reduce((sum, r) => sum + r, 0) / n;
                 const variance = returns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / n;
                 const stdDev = Math.sqrt(variance);
                 
                 return returns.reduce((sum, r) => sum + Math.pow((r - mean) / stdDev, 3), 0) / n;
             }

             calculateKurtosis(returns) {
                 const n = returns.length;
                 const mean = returns.reduce((sum, r) => sum + r, 0) / n;
                 const variance = returns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / n;
                 const stdDev = Math.sqrt(variance);
                 
                 return returns.reduce((sum, r) => sum + Math.pow((r - mean) / stdDev, 4), 0) / n;
             }

             calculateChiSquarePValue(statistic, degreesOfFreedom) {
                 // Simplified chi-square p-value calculation
                 // For degrees of freedom = 2, we can use a lookup table approximation
                 if (degreesOfFreedom === 2) {
                     if (statistic < 0.103) return 0.95;
                     if (statistic < 0.211) return 0.90;
                     if (statistic < 0.575) return 0.75;
                     if (statistic < 1.386) return 0.50;
                     if (statistic < 2.773) return 0.25;
                     if (statistic < 4.605) return 0.10;
                     if (statistic < 5.991) return 0.05;
                     if (statistic < 7.378) return 0.025;
                     if (statistic < 9.210) return 0.01;
                     return 0.005;
                 }
                 
                 // For other degrees of freedom, use a rough approximation
                 return Math.exp(-statistic / 2) / Math.sqrt(2 * Math.PI * statistic);
             }

             calculateShapiroWilkTest(returns) {
                 // Simplified Shapiro-Wilk test implementation
                 // For large samples, we can use a simplified approach
                 const n = returns.length;
                 
                 if (n < 3) {
                     return { statistic: 0, pValue: 1, isValid: false };
                 }
                 
                 // Sort returns
                 const sortedReturns = [...returns].sort((a, b) => a - b);
                 
                 // Calculate simplified W statistic (approximation)
                 const mean = sortedReturns.reduce((sum, r) => sum + r, 0) / n;
                 const variance = sortedReturns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / n;
                 
                 // Simplified W statistic calculation
                 let numerator = 0;
                 let denominator = variance * (n - 1);
                 
                 // Use simplified coefficients for W statistic
                 for (let i = 0; i < Math.floor(n / 2); i++) {
                     const ai = this.getShapiroWilkCoefficient(n, i + 1);
                     numerator += ai * (sortedReturns[n - 1 - i] - sortedReturns[i]);
                 }
                 
                 const wStatistic = Math.pow(numerator, 2) / denominator;
                 
                 // Approximate p-value (simplified)
                 const pValue = this.approximateShapiroWilkPValue(wStatistic, n);
                 
                 return {
                     statistic: wStatistic,
                     pValue: pValue,
                     isValid: true
                 };
             }

             getShapiroWilkCoefficient(n, i) {
                 // Simplified coefficients for Shapiro-Wilk test
                 // These are approximate values for common sample sizes
                 const coefficients = {
                     10: [0.5739, 0.3291, 0.2141, 0.1224, 0.0399],
                     20: [0.4643, 0.3185, 0.2578, 0.2119, 0.1730, 0.1370, 0.1030, 0.0710, 0.0400, 0.0100],
                     50: [0.3754, 0.2778, 0.2347, 0.2034, 0.1787, 0.1580, 0.1400, 0.1240, 0.1090, 0.0950, 0.0820, 0.0700, 0.0580, 0.0470, 0.0360, 0.0250, 0.0140, 0.0030]
                 };
                 
                 // Find closest sample size
                 const sampleSizes = Object.keys(coefficients).map(Number).sort((a, b) => a - b);
                 let closestSize = sampleSizes[0];
                 
                 for (const size of sampleSizes) {
                     if (n >= size) {
                         closestSize = size;
                     }
                 }
                 
                 return coefficients[closestSize][i - 1] || 0.1; // Default coefficient
             }

             approximateShapiroWilkPValue(wStatistic, n) {
                 // Simplified p-value approximation for Shapiro-Wilk test
                 // This is a rough approximation based on typical W statistic distributions
                 
                 if (wStatistic > 0.99) return 0.99;
                 if (wStatistic > 0.95) return 0.90;
                 if (wStatistic > 0.90) return 0.70;
                 if (wStatistic > 0.85) return 0.50;
                 if (wStatistic > 0.80) return 0.30;
                 if (wStatistic > 0.75) return 0.10;
                 if (wStatistic > 0.70) return 0.05;
                 if (wStatistic > 0.65) return 0.01;
                 
                 return 0.001; // Very low p-value for very low W statistics
             }

             calculateChiSquarePValue(statistic, degreesOfFreedom) {
                 // Simplified chi-square p-value calculation
                 // This is an approximation using the chi-square distribution
                 
                 // For degrees of freedom = 2, we can use a simplified approach
                 if (degreesOfFreedom === 2) {
                     if (statistic < 0.103) return 0.95;
                     if (statistic < 0.211) return 0.90;
                     if (statistic < 0.446) return 0.80;
                     if (statistic < 0.713) return 0.70;
                     if (statistic < 1.386) return 0.50;
                     if (statistic < 2.773) return 0.25;
                     if (statistic < 4.605) return 0.10;
                     if (statistic < 5.991) return 0.05;
                     if (statistic < 9.210) return 0.01;
                     
                     return 0.001; // Very low p-value for high statistics
                 }
                 
                 return 0.05; // Default p-value
             }

             displayNormalityResults(normalityResults) {
                 const normalityResultsDiv = document.getElementById('normalityResults');
                 
                 let html = `
                     <div style="background: #f8f9fa; padding: 25px; border-radius: 15px; border-left: 4px solid #2ed573; margin-bottom: 30px;">
                         <h4 style="margin: 0 0 20px 0; color: #333; font-size: 1.3rem;">📊 Normality Test Overview</h4>
                         <p style="margin: 0; color: #555; line-height: 1.6;">
                             The Jarque-Bera test evaluates whether stock returns follow a normal distribution by testing skewness and kurtosis. 
                             A p-value > 0.05 suggests normal distribution. The Shapiro-Wilk test provides additional validation.
                         </p>
                     </div>
                     
                     <div style="background: white; border-radius: 15px; overflow: hidden; box-shadow: 0 4px 20px rgba(0,0,0,0.1);">
                         <div style="background: linear-gradient(135deg, #2ed573, #00b894); color: white; padding: 15px 20px;">
                             <h4 style="margin: 0; font-size: 1.2rem;">📋 Normality Test Results</h4>
                         </div>
                         <div style="overflow-x: auto;">
                             <table style="width: 100%; border-collapse: collapse;">
                                 <thead>
                                     <tr style="background: #f8f9fa;">
                                         <th style="padding: 12px; text-align: left; border-bottom: 1px solid #e1e5e9; font-weight: 600;">Stock</th>
                                         <th style="padding: 12px; text-align: center; border-bottom: 1px solid #e1e5e9; font-weight: 600;">Skewness</th>
                                         <th style="padding: 12px; text-align: center; border-bottom: 1px solid #e1e5e9; font-weight: 600;">Kurtosis</th>
                                         <th style="padding: 12px; text-align: center; border-bottom: 1px solid #e1e5e9; font-weight: 600;">JB p-value</th>
                                         <th style="padding: 12px; text-align: center; border-bottom: 1px solid #e1e5e9; font-weight: 600;">Normality</th>
                                     </tr>
                                 </thead>
                                 <tbody>
                 `;
                 
                 Object.keys(normalityResults).forEach(symbol => {
                     const result = normalityResults[symbol];
                     const normalityClass = result.isNormal ? 'normal' : 'not-normal';
                     const normalityText = result.isNormal ? 'Normal' : 'Not Normal';
                     const normalityColor = result.isNormal ? '#2ed573' : '#ff4757';
                     
                     html += `
                         <tr style="border-bottom: 1px solid #f0f0f0;">
                             <td style="padding: 12px; font-weight: 600; color: #333;">${symbol}</td>
                             <td style="padding: 12px; text-align: center; font-weight: 600; color: ${Math.abs(result.skewness) > 1 ? '#ff4757' : '#2ed573'};">${result.skewness.toFixed(3)}</td>
                             <td style="padding: 12px; text-align: center; font-weight: 600; color: ${Math.abs(result.kurtosis - 3) > 2 ? '#ff4757' : '#2ed573'};">${result.kurtosis.toFixed(3)}</td>
                             <td style="padding: 12px; text-align: center; font-weight: 600; color: ${result.jarqueBera.pValue > 0.05 ? '#2ed573' : '#ff4757'};">${result.jarqueBera.pValue.toFixed(4)}</td>
                             <td style="padding: 12px; text-align: center; font-weight: 600; color: ${normalityColor};">${normalityText}</td>
                         </tr>
                     `;
                 });
                 
                 html += `
                                 </tbody>
                             </table>
                         </div>
                     </div>
                     
                     <div style="margin-top: 30px; background: #f8f9fa; padding: 25px; border-radius: 15px; border-left: 4px solid #2ed573;">
                         <h4 style="margin: 0 0 20px 0; color: #333; font-size: 1.3rem;">📚 Normality Test Interpretation</h4>
                         <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                             <div>
                                 <h5 style="margin: 0 0 10px 0; color: #333;">Jarque-Bera Test</h5>
                                 <ul style="margin: 0; padding-left: 20px; color: #555;">
                                     <li><strong>H₀:</strong> Returns follow normal distribution</li>
                                     <li><strong>H₁:</strong> Returns do not follow normal distribution</li>
                                     <li><strong>p-value > 0.05:</strong> Fail to reject H₀ (normal)</li>
                                     <li><strong>p-value ≤ 0.05:</strong> Reject H₀ (not normal)</li>
                                 </ul>
                             </div>
                             <div>
                                 <h5 style="margin: 0 0 10px 0; color: #333;">Distribution Characteristics</h5>
                                 <ul style="margin: 0; padding-left: 20px; color: #555;">
                                     <li><strong>Skewness = 0:</strong> Symmetric distribution</li>
                                     <li><strong>Kurtosis = 3:</strong> Normal kurtosis</li>
                                     <li><strong>Skewness ≠ 0:</strong> Asymmetric distribution</li>
                                     <li><strong>Kurtosis > 3:</strong> Heavy tails (leptokurtic)</li>
                                 </ul>
                             </div>
                         </div>
                     </div>
                 `;
                 
                 normalityResultsDiv.innerHTML = html;
                 normalityResultsDiv.style.display = 'block';
             }

             getNormalityAnalysis(results) {
                 return '<p style="text-align: center; color: #666;">Click "Perform Normality Tests" to test the normality of stock returns.</p>';
             }

             async generateDistributionGraphs() {
                 try {
                     // Show loading state
                     const graphsResultsDiv = document.getElementById('graphsResults');
                     graphsResultsDiv.innerHTML = '<div style="text-align: center; padding: 40px;"><div class="spinner"></div><p>Generating distribution graphs...</p></div>';
                     graphsResultsDiv.style.display = 'block';
                     
                     // Generate graphs for each stock
                     const graphsHTML = this.createDistributionGraphsCarousel();
                     
                     // Display results
                     graphsResultsDiv.innerHTML = graphsHTML;
                     
                     // Initialize carousel functionality
                     this.initializeCarousel();
                     
                 } catch (error) {
                     console.error('Graph generation error:', error);
                     const graphsResultsDiv = document.getElementById('graphsResults');
                     graphsResultsDiv.innerHTML = `<div style="text-align: center; padding: 40px; color: #ff4757;"><i class="fas fa-exclamation-triangle"></i><p>Error generating graphs: ${error.message}</p></div>`;
                     graphsResultsDiv.style.display = 'block';
                 }
             }

             createDistributionGraphsCarousel() {
                 const stocks = Array.from(this.portfolio.keys());
                 
                 if (stocks.length === 0) {
                     return '<p style="text-align: center; color: #666;">No stocks in portfolio to generate graphs.</p>';
                 }
                 
                 let carouselHTML = `
                     <div class="graphs-carousel">
                         <div class="carousel-container" id="carouselContainer">
                 `;
                 
                 stocks.forEach((symbol, index) => {
                     const stockData = this.portfolio.get(symbol);
                     const returns = this.calculateReturns(stockData.historicalData);
                     
                     carouselHTML += `
                         <div class="graph-slide" data-index="${index}">
                             <div class="graph-title">${symbol} - Return Distribution vs Normal</div>
                             <div class="graph-container" id="graph-${symbol}">
                                 ${this.generateDistributionGraph(returns, symbol)}
                             </div>
                             <div class="distribution-legend">
                                 <div class="legend-item">
                                     <div class="legend-color legend-actual"></div>
                                     <span>Actual Returns</span>
                                 </div>
                                 <div class="legend-item">
                                     <div class="legend-color legend-normal"></div>
                                     <span>Normal Distribution</span>
                                 </div>
                             </div>
                         </div>
                     `;
                 });
                 
                 carouselHTML += `
                         </div>
                         <div class="carousel-nav">
                             <button class="carousel-btn" id="prevBtn" onclick="portfolio.prevSlide()">
                                 <i class="fas fa-chevron-left"></i>
                             </button>
                             <span id="slideCounter" style="font-weight: 600; color: #333; min-width: 80px; text-align: center;">1 / ${stocks.length}</span>
                             <button class="carousel-btn" id="nextBtn" onclick="portfolio.nextSlide()">
                                 <i class="fas fa-chevron-right"></i>
                             </button>
                         </div>
                         <div class="carousel-indicators" id="indicators">
                 `;
                 
                 stocks.forEach((_, index) => {
                     carouselHTML += `
                         <div class="indicator ${index === 0 ? 'active' : ''}" onclick="portfolio.goToSlide(${index})"></div>
                     `;
                 });
                 
                 carouselHTML += `
                         </div>
                     </div>
                 `;
                 
                 return carouselHTML;
             }

             generateDistributionGraph(returns, symbol) {
                 // Calculate statistics for the actual returns
                 var mean = returns.reduce(function(sum, r) { return sum + r; }, 0) / returns.length;
                 var variance = returns.reduce(function(sum, r) { return sum + Math.pow(r - mean, 2); }, 0) / returns.length;
                 var stdDev = Math.sqrt(variance);
                 
                 // Create histogram data with optimal number of bins
                 var optimalBins = Math.min(25, Math.max(15, Math.floor(returns.length / 10)));
                 var histogram = this.createHistogram(returns, optimalBins);
                 
                 // Generate normal distribution curve
                 var normalCurve = this.generateNormalCurve(mean, stdDev, histogram.min, histogram.max, 150);
                 
                 // Create SVG visualization
                 return this.createDistributionSVG(histogram, normalCurve, mean, stdDev);
             }

             createHistogram(returns, bins) {
                 var min = Math.min(...returns);
                 var max = Math.max(...returns);
                 var binWidth = (max - min) / bins;
                 
                 var histogram = new Array(bins).fill(0);
                 var binCenters = [];
                 
                 // Create bin centers for better visualization
                 for (var i = 0; i < bins; i++) {
                     binCenters.push(min + (i + 0.5) * binWidth);
                 }
                 
                 returns.forEach(function(return_) {
                     var binIndex = Math.min(Math.floor((return_ - min) / binWidth), bins - 1);
                     histogram[binIndex]++;
                 });
                 
                 return {
                     bins: histogram,
                     binWidth: binWidth,
                     min: min,
                     max: max,
                     binCenters: binCenters,
                     totalSamples: returns.length
                 };
             }

             generateNormalCurve(mean, stdDev, min, max, points) {
                 var curve = [];
                 var step = (max - min) / (points - 1);
                 
                 // Extend the range slightly for better curve visualization
                 var extendedMin = min - (max - min) * 0.1;
                 var extendedMax = max + (max - min) * 0.1;
                 var extendedStep = (extendedMax - extendedMin) / (points - 1);
                 
                 for (var i = 0; i < points; i++) {
                     var x = extendedMin + i * extendedStep;
                     var y = this.normalPDF(x, mean, stdDev);
                     curve.push({x: x, y: y});
                 }
                 
                 return curve;
             }

             normalPDF(x, mean, stdDev) {
                 const coefficient = 1 / (stdDev * Math.sqrt(2 * Math.PI));
                 const exponent = -Math.pow(x - mean, 2) / (2 * Math.pow(stdDev, 2));
                 return coefficient * Math.exp(exponent);
             }

             createDistributionSVG(histogram, normalCurve, mean, stdDev) {
                 var width = 600;
                 var height = 400;
                 var padding = { top: 50, right: 60, bottom: 60, left: 60 };
                 var chartWidth = width - padding.left - padding.right;
                 var chartHeight = height - padding.top - padding.bottom;
                 
                 // Calculate scaling factors
                 var maxHistogram = Math.max(...histogram.bins);
                 var maxNormal = Math.max(...normalCurve.map(function(p) { return p.y; }));
                 var scale = Math.max(maxHistogram, maxNormal * histogram.binWidth * histogram.bins.length);
                 
                 // Create SVG with enhanced styling
                 var svg = '<svg width="' + width + '" height="' + height + '" style="border: 2px solid #e1e5e9; border-radius: 12px; background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);">';
                 
                 // Add title
                 svg += '<text x="' + (width/2) + '" y="25" text-anchor="middle" font-size="16" font-weight="bold" fill="#333">Return Distribution vs Normal</text>';
                 
                 // Add grid lines with better styling
                 for (var i = 0; i <= 5; i++) {
                     var y = padding.top + (chartHeight / 5) * i;
                     svg += '<line x1="' + padding.left + '" y1="' + y + '" x2="' + (width - padding.right) + '" y2="' + y + '" stroke="#e9ecef" stroke-width="1" opacity="0.6"/>';
                 }
                 
                 // Add vertical grid lines
                 for (var i = 0; i <= 10; i++) {
                     var x = padding.left + (chartWidth / 10) * i;
                     svg += '<line x1="' + x + '" y1="' + padding.top + '" x2="' + x + '" y2="' + (height - padding.bottom) + '" stroke="#e9ecef" stroke-width="1" opacity="0.4"/>';
                 }
                 
                 // Plot histogram bars with gradient and better styling
                 var barWidth = chartWidth / histogram.bins.length;
                 histogram.bins.forEach(function(count, i) {
                     var barHeight = (count / scale) * chartHeight;
                     var x = padding.left + i * barWidth;
                     var y = height - padding.bottom - barHeight;
                     
                     // Create gradient for bars
                     var gradientId = 'barGradient' + i;
                     svg += '<defs>';
                     svg += '<linearGradient id="' + gradientId + '" x1="0%" y1="0%" x2="0%" y2="100%">';
                     svg += '<stop offset="0%" style="stop-color:#667eea;stop-opacity:0.9" />';
                     svg += '<stop offset="100%" style="stop-color:#667eea;stop-opacity:0.6" />';
                     svg += '</linearGradient>';
                     svg += '</defs>';
                     
                     // Add bar with rounded corners effect
                     var barX = x + barWidth * 0.1;
                     var barW = barWidth * 0.8;
                     svg += '<rect x="' + barX + '" y="' + y + '" width="' + barW + '" height="' + barHeight + '" fill="url(#' + gradientId + ')" stroke="#4a5568" stroke-width="1" rx="3"/>';
                     
                     // Add value label on top of significant bars
                     if (count > maxHistogram * 0.1) {
                         svg += '<text x="' + (barX + barW/2) + '" y="' + (y - 5) + '" text-anchor="middle" font-size="10" fill="#4a5568" font-weight="bold">' + count + '</text>';
                     }
                 });
                 
                 // Plot normal distribution curve with enhanced styling
                 var curvePath = normalCurve.map(function(point, i) {
                     var x = padding.left + (point.x - histogram.min) / (histogram.max - histogram.min) * chartWidth;
                     var y = height - padding.bottom - (point.y / maxNormal) * chartHeight;
                     return (i === 0 ? 'M' : 'L') + ' ' + x + ' ' + y;
                 }).join(' ');
                 
                 // Add curve with gradient and shadow effect
                 svg += '<defs>';
                 svg += '<filter id="curveShadow" x="-20%" y="-20%" width="140%" height="140%">';
                 svg += '<feDropShadow dx="2" dy="2" stdDeviation="3" flood-color="#000000" flood-opacity="0.2"/>';
                 svg += '</filter>';
                 svg += '</defs>';
                 
                 svg += '<path d="' + curvePath + '" stroke="url(#curveGradient)" stroke-width="3" fill="none" filter="url(#curveShadow)"/>';
                 
                 // Add curve gradient
                 svg += '<defs>';
                 svg += '<linearGradient id="curveGradient" x1="0%" y1="0%" x2="100%" y2="0%">';
                 svg += '<stop offset="0%" style="stop-color:#ff4757;stop-opacity:0.8" />';
                 svg += '<stop offset="50%" style="stop-color:#ff6b35;stop-opacity:0.9" />';
                 svg += '<stop offset="100%" style="stop-color:#ff4757;stop-opacity:0.8" />';
                 svg += '</linearGradient>';
                 svg += '</defs>';
                 
                 // Add mean line with enhanced styling
                 var meanX = padding.left + (mean - histogram.min) / (histogram.max - histogram.min) * chartWidth;
                 svg += '<line x1="' + meanX + '" y1="' + padding.top + '" x2="' + meanX + '" y2="' + (height - padding.bottom) + '" stroke="#2ed573" stroke-width="3" stroke-dasharray="8,4" opacity="0.8"/>';
                 
                 // Add mean line label with background
                 svg += '<rect x="' + (meanX + 10) + '" y="' + (padding.top + 10) + '" width="120" height="25" fill="#2ed573" opacity="0.9" rx="5"/>';
                 svg += '<text x="' + (meanX + 70) + '" y="' + (padding.top + 25) + '" text-anchor="middle" font-size="11" fill="white" font-weight="bold">Mean: ' + (mean * 100).toFixed(2) + '%</text>';
                 
                 // Add standard deviation lines
                 var stdDev1X = padding.left + ((mean + stdDev) - histogram.min) / (histogram.max - histogram.min) * chartWidth;
                 var stdDev2X = padding.left + ((mean - stdDev) - histogram.min) / (histogram.max - histogram.min) * chartWidth;
                 
                 svg += '<line x1="' + stdDev1X + '" y1="' + padding.top + '" x2="' + stdDev1X + '" y2="' + (height - padding.bottom) + '" stroke="#ffa726" stroke-width="2" stroke-dasharray="4,4" opacity="0.6"/>';
                 svg += '<line x1="' + stdDev2X + '" y1="' + padding.top + '" x2="' + stdDev2X + '" y2="' + (height - padding.bottom) + '" stroke="#ffa726" stroke-width="2" stroke-dasharray="4,4" opacity="0.6"/>';
                 
                 // Add axis labels with better styling
                 svg += '<text x="' + (width/2) + '" y="' + (height - 15) + '" text-anchor="middle" font-size="14" font-weight="bold" fill="#333">Return Values (%)</text>';
                 svg += '<text x="15" y="' + (height/2) + '" text-anchor="middle" font-size="14" font-weight="bold" fill="#333" transform="rotate(-90, 15, ' + (height/2) + ')">Frequency</text>';
                 
                 // Add legend
                 var legendY = padding.top - 10;
                 svg += '<rect x="' + padding.left + '" y="' + legendY + '" width="12" height="12" fill="url(#barGradient0)" stroke="#4a5568" stroke-width="1" rx="2"/>';
                 svg += '<text x="' + (padding.left + 20) + '" y="' + (legendY + 9) + '" font-size="12" fill="#333">Actual Returns</text>';
                 
                 svg += '<rect x="' + (padding.left + 120) + '" y="' + legendY + '" width="12" height="12" fill="url(#curveGradient)" stroke="#ff4757" stroke-width="1" rx="2"/>';
                 svg += '<text x="' + (padding.left + 140) + '" y="' + (legendY + 9) + '" font-size="12" fill="#333">Normal Distribution</text>';
                 
                 // Add statistics box
                 var statsX = width - padding.right - 180;
                 var statsY = padding.top + 10;
                 svg += '<rect x="' + statsX + '" y="' + statsY + '" width="170" height="80" fill="rgba(255,255,255,0.95)" stroke="#e1e5e9" stroke-width="1" rx="8"/>';
                 svg += '<text x="' + (statsX + 85) + '" y="' + (statsY + 20) + '" text-anchor="middle" font-size="12" font-weight="bold" fill="#333">Statistics</text>';
                 svg += '<text x="' + (statsX + 10) + '" y="' + (statsY + 35) + '" font-size="10" fill="#666">Mean: ' + (mean * 100).toFixed(3) + '%</text>';
                 svg += '<text x="' + (statsX + 10) + '" y="' + (statsY + 50) + '" font-size="10" fill="#666">Std Dev: ' + (stdDev * 100).toFixed(3) + '%</text>';
                 svg += '<text x="' + (statsX + 10) + '" y="' + (statsY + 65) + '" font-size="10" fill="#666">Samples: ' + histogram.bins.reduce(function(sum, bin) { return sum + bin; }, 0) + '</text>';
                 
                 svg += '</svg>';
                 
                 return svg;
             }

             createHistogram(returns, numBins) {
                 var min = Math.min(...returns);
                 var max = Math.max(...returns);
                 var binWidth = (max - min) / numBins;
                 
                 var bins = [];
                 for (var i = 0; i < numBins; i++) {
                     var start = min + i * binWidth;
                     var end = min + (i + 1) * binWidth;
                     var count = returns.filter(function(r) { return r >= start && r < end; }).length;
                     bins.push({ start: start, end: end, count: count });
                 }
                 
                 return {
                     bins: bins,
                     min: min,
                     max: max,
                     values: bins.map(function(b) { return b.count; })
                 };
             }

             generateNormalCurve(mean, stdDev, min, max, numPoints) {
                 var points = [];
                 var step = (max - min) / (numPoints - 1);
                 
                 for (var i = 0; i < numPoints; i++) {
                     var x = min + i * step;
                     const y = this.normalPDF(x, mean, stdDev);
                     points.push({ x, y });
                 }
                 
                 return points;
             }

             normalPDF(x, mean, stdDev) {
                 var coefficient = 1 / (stdDev * Math.sqrt(2 * Math.PI));
                 var exponent = -Math.pow(x - mean, 2) / (2 * Math.pow(stdDev, 2));
                 return coefficient * Math.exp(exponent);
             }

             generateGridLines(width, height, margin, numLines) {
                 var gridLines = '';
                 
                 // Vertical grid lines
                 for (var i = 0; i <= numLines; i++) {
                     var x = margin.left + (width / numLines) * i;
                     gridLines += '<line x1="' + x + '" y1="' + margin.top + '" x2="' + x + '" y2="' + (margin.top + height) + '" />';
                 }
                 
                 // Horizontal grid lines
                 for (var i = 0; i <= numLines; i++) {
                     var y = margin.top + (height / numLines) * i;
                     gridLines += '<line x1="' + margin.left + '" y1="' + y + '" x2="' + (margin.left + width) + '" y2="' + y + '" />';
                 }
                 
                 return gridLines;
             }

             initializeCarousel() {
                 this.currentSlide = 0;
                 this.totalSlides = document.querySelectorAll('.graph-slide').length;
                 
                 // Update carousel state
                 this.updateCarousel();
             }

             updateCarousel() {
                 var container = document.getElementById('carouselContainer');
                 var counter = document.getElementById('slideCounter');
                 var prevBtn = document.getElementById('prevBtn');
                 var nextBtn = document.getElementById('nextBtn');
                 var indicators = document.querySelectorAll('.indicator');
                 
                 if (container && counter && prevBtn && nextBtn) {
                     // Update container position
                     container.style.transform = 'translateX(-' + (this.currentSlide * 100) + '%)';
                     
                     // Update counter
                     counter.textContent = (this.currentSlide + 1) + ' / ' + this.totalSlides;
                     
                     // Update button states
                     prevBtn.disabled = this.currentSlide === 0;
                     nextBtn.disabled = this.currentSlide === this.totalSlides - 1;
                     
                     // Update indicators
                     indicators.forEach(function(indicator, index) {
                         indicator.classList.toggle('active', index === this.currentSlide);
                     }.bind(this));
                 }
             }

             prevSlide() {
                 if (this.currentSlide > 0) {
                     this.currentSlide--;
                     this.updateCarousel();
                 }
             }

             nextSlide() {
                 if (this.currentSlide < this.totalSlides - 1) {
                     this.currentSlide++;
                     this.updateCarousel();
                 }
             }

             goToSlide(index) {
                 if (index >= 0 && index < this.totalSlides) {
                     this.currentSlide = index;
                     this.updateCarousel();
                 }
             }

             getDistributionGraphs(results) {
                 return '<p style="text-align: center; color: #666;">Click "Generate Distribution Graphs" to create visual comparisons.</p>';
             }

             // Auto-update methods for automatic analysis refresh
             async autoUpdateAllAnalyses() {
                 if (this.portfolio.size === 0) {
                     this.clearAllAnalysisSections();
                     return;
                 }

                 try {
                     // Check if we have valid dates for analysis
                     const startDate = document.getElementById('startDate').value;
                     const endDate = document.getElementById('endDate').value;
                     
                     if (!startDate || !endDate) {
                         // If no dates set, just clear analyses
                         this.clearAllAnalysisSections();
                         return;
                     }

                     console.log('Starting auto-update of all analyses...');

                     // First, perform and display financial analysis to create all containers
                     const analysisResults = await this.performFinancialAnalysis();
                     this.displayAnalysisResults(analysisResults);
                     
                     // Now auto-update CAPM analysis (always show and calculate)
                     await this.autoUpdateCAPMAnalysis();
                     
                     // Auto-update normality analysis (always show and calculate)
                     await this.autoUpdateNormalityAnalysis();
                     
                     // Auto-update distribution graphs (always show and calculate)
                     await this.autoUpdateDistributionGraphs();
                     
                     // Auto-update efficient frontier with 500,000 portfolios
                     await this.autoUpdateEfficientFrontier();
                     
                     console.log('All analyses updated successfully');
                     
                 } catch (error) {
                     console.error('Auto-update error:', error);
                     // Don't show error to user for auto-updates
                 }
             }

             async autoUpdateFinancialAnalysis() {
                 try {
                     const analysisResults = await this.performFinancialAnalysis();
                     this.displayAnalysisResults(analysisResults);
                 } catch (error) {
                     console.error('Financial analysis auto-update error:', error);
                 }
             }

             async autoUpdateCAPMAnalysis() {
                 try {
                     const capmResultsDiv = document.getElementById('capmResults');
                     if (capmResultsDiv) {
                         // Always show and calculate CAPM analysis
                         capmResultsDiv.style.display = 'block';
                         await this.calculateCAPMAndSingleIndexModel();
                     }
                 } catch (error) {
                     console.error('CAPM analysis auto-update error:', error);
                 }
             }

             async autoUpdateNormalityAnalysis() {
                 try {
                     const normalityResultsDiv = document.getElementById('normalityResults');
                     if (normalityResultsDiv) {
                         // Always show and calculate normality analysis
                         normalityResultsDiv.style.display = 'block';
                         await this.performNormalityTests();
                     }
                 } catch (error) {
                     console.error('Normality analysis auto-update error:', error);
                 }
             }

             async autoUpdateDistributionGraphs() {
                 try {
                     const graphsResultsDiv = document.getElementById('graphsResults');
                     if (graphsResultsDiv) {
                         // Always show and calculate distribution graphs
                         graphsResultsDiv.style.display = 'block';
                         await this.generateDistributionGraphs();
                     }
                 } catch (error) {
                     console.error('Distribution graphs auto-update error:', error);
                 }
             }



             async autoUpdateEfficientFrontier() {
                 try {
                     // Check if we have analysis results to work with
                     if (!this.lastAnalysisResults) {
                         return;
                     }
                     
                     // Set the number of simulations to 500,000
                     const frontierSimulationsInput = document.getElementById('frontierSimulations');
                     if (frontierSimulationsInput) {
                         frontierSimulationsInput.value = '500000';
                     }
                     
                     // Generate efficient frontier with 500,000 portfolios
                     await this.generateEfficientFrontier();
                     
                 } catch (error) {
                     console.error('Efficient frontier auto-update error:', error);
                 }
             }

             clearAllAnalysisSections() {
                 // Clear financial analysis
                 const analysisResultsDiv = document.getElementById('analysisResults');
                 if (analysisResultsDiv) {
                     analysisResultsDiv.innerHTML = '<p style="text-align: center; color: #666;">Add stocks to your portfolio to see analysis results.</p>';
                 }

                 // Clear CAPM analysis
                 const capmResultsDiv = document.getElementById('capmResults');
                 if (capmResultsDiv) {
                     capmResultsDiv.style.display = 'none';
                 }

                 // Clear normality analysis
                 const normalityResultsDiv = document.getElementById('normalityResults');
                 if (normalityResultsDiv) {
                     normalityResultsDiv.style.display = 'none';
                 }

                 // Clear distribution graphs
                 const graphsResultsDiv = document.getElementById('graphsResults');
                 if (graphsResultsDiv) {
                     graphsResultsDiv.style.display = 'none';
                 }
             }

             // Efficient Frontier Constrained Portfolio Methods
             findMinVarianceConstrained(portfolios, targetReturn) {
                 // Filter portfolios that meet the return constraint (no shorts already enforced)
                 const validPortfolios = portfolios.filter(p => p.expected_return >= targetReturn);
                 
                 if (validPortfolios.length === 0) {
                     return null; // No portfolios meet the constraint
                 }
                 
                 // Find the one with minimum variance
                 let minVariancePortfolio = validPortfolios[0];
                 for (const portfolio of validPortfolios) {
                     if (portfolio.variance < minVariancePortfolio.variance) {
                         minVariancePortfolio = portfolio;
                     }
                 }
                 
                 return {
                     ...minVariancePortfolio,
                     is_min_variance_constrained: true,
                     constraint_type: 'Min Variance with Return >= 12%'
                 };
             }

             findMaxSharpeConstrained(portfolios, targetReturn) {
                 // Filter portfolios that meet the return constraint (no shorts already enforced)
                 const validPortfolios = portfolios.filter(p => p.expected_return >= targetReturn);
                 
                 if (validPortfolios.length === 0) {
                     return null; // No portfolios meet the constraint
                 }
                 
                 // Find the one with maximum Sharpe ratio
                 let maxSharpePortfolio = validPortfolios[0];
                 for (const portfolio of validPortfolios) {
                     if (portfolio.sharpe > maxSharpePortfolio.sharpe) {
                         maxSharpePortfolio = portfolio;
                     }
                 }
                 
                 return {
                     ...maxSharpePortfolio,
                     is_max_sharpe_constrained: true,
                     constraint_type: 'Max Sharpe with Return >= 12%'
                 };
             }

             // Sector helper methods
             getStockSector(symbol) {
                 // Predefined sector mapping
                 const sectorMapping = {
                     'BBAR': 'Servicios Financieros',
                     'BMA': 'Servicios Financieros',
                     'GGAL': 'Servicios Financieros',
                     'SUPV': 'Servicios Financieros',
                     'CEPU': 'Energía',
                     'EDN': 'Energía',
                     'PAM': 'Energía',
                     'TGS': 'Energía',
                     'YPF': 'Energía',
                     'IRS': 'Bienes Raíces',
                     'LOMA': 'Materiales',
                     'TS': 'Materiales',
                     'CRESY': 'Agroindustria',
                     'MELI': 'Tecnología',
                     'TEO': 'Telecomunicaciones'
                 };
                 
                 return sectorMapping[symbol] || 'Otros';
             }

             getSectorColor(sector) {
                 // Predefined sector colors with fintech design
                 const sectorColors = {
                     'Servicios Financieros': '#667eea',
                     'Energía': '#ff6b6b',
                     'Bienes Raíces': '#4ecdc4',
                     'Materiales': '#45b7d1',
                     'Agroindustria': '#96ceb4',
                     'Tecnología': '#fdcb6e',
                     'Telecomunicaciones': '#e17055',
                     'Otros': '#95a5a6'
                 };
                 
                 return sectorColors[sector] || '#95a5a6';
             }



             async getStockSectorFromAPI(symbol) {
                 try {
                     // Using investing.com to get sector information from the profile section
                     const investingUrl = `https://www.investing.com/equities/${symbol.toLowerCase()}`;
                     const response = await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(investingUrl)}`);
                     const data = await response.json();
                     
                     if (data.contents) {
                         const htmlContent = data.contents.toLowerCase();
                         
                         // Look for sector information in the profile section
                         // Common patterns in investing.com profile pages
                         const sectorPatterns = [
                             { pattern: /sector[:\s]*([^<>\n]+)/i, fallback: null },
                             { pattern: /industry[:\s]*([^<>\n]+)/i, fallback: null },
                             { pattern: /sector.*?>(.*?)</i, fallback: null },
                             { pattern: /industry.*?>(.*?)</i, fallback: null }
                         ];
                         
                         for (const { pattern, fallback } of sectorPatterns) {
                             const match = htmlContent.match(pattern);
                             if (match && match[1]) {
                                 const sector = match[1].trim();
                                 if (sector && sector !== 'n/a' && sector !== 'unknown') {
                                     return sector.charAt(0).toUpperCase() + sector.slice(1);
                                 }
                             }
                         }
                         
                         // Fallback: Look for common sector keywords in the profile content
                         const sectors = [
                             'technology', 'healthcare', 'financial', 'consumer discretionary',
                             'consumer staples', 'energy', 'materials', 'industrials',
                             'utilities', 'real estate', 'communication services', 'telecommunications'
                         ];
                         
                         for (const sector of sectors) {
                             if (htmlContent.includes(sector)) {
                                 return sector.charAt(0).toUpperCase() + sector.slice(1);
                             }
                         }
                         
                         // Look for specific sector indicators
                         if (htmlContent.includes('tech') || htmlContent.includes('software') || htmlContent.includes('internet')) {
                             return 'Technology';
                         }
                         if (htmlContent.includes('health') || htmlContent.includes('medical') || htmlContent.includes('pharmaceutical')) {
                             return 'Healthcare';
                         }
                         if (htmlContent.includes('bank') || htmlContent.includes('insurance') || htmlContent.includes('financial')) {
                             return 'Financial';
                         }
                         if (htmlContent.includes('retail') || htmlContent.includes('automotive') || htmlContent.includes('entertainment')) {
                             return 'Consumer Discretionary';
                         }
                         if (htmlContent.includes('food') || htmlContent.includes('beverage') || htmlContent.includes('household')) {
                             return 'Consumer Staples';
                         }
                         if (htmlContent.includes('oil') || htmlContent.includes('gas') || htmlContent.includes('energy')) {
                             return 'Energy';
                         }
                         if (htmlContent.includes('mining') || htmlContent.includes('chemical') || htmlContent.includes('materials')) {
                             return 'Materials';
                         }
                         if (htmlContent.includes('manufacturing') || htmlContent.includes('aerospace') || htmlContent.includes('industrial')) {
                             return 'Industrials';
                         }
                         if (htmlContent.includes('utility') || htmlContent.includes('electric') || htmlContent.includes('water')) {
                             return 'Utilities';
                         }
                         if (htmlContent.includes('real estate') || htmlContent.includes('property')) {
                             return 'Real Estate';
                         }
                         if (htmlContent.includes('telecom') || htmlContent.includes('communication')) {
                             return 'Communication Services';
                         }
                     }
                     return 'Unknown';
                 } catch (error) {
                     console.error(`Error fetching sector for ${symbol}:`, error);
                     return 'Unknown';
                 }
             }

            renderCovarianceHeatmap(results) {
                const symbols = Object.keys(results).filter(k => k !== 'portfolio');
                if (symbols.length === 0) return;
                const series = symbols.map(s => results[s].returns);
                const minLen = Math.min(...series.map(arr => arr.length));
                const aligned = series.map(arr => arr.slice(-minLen));
                const cov = (a, b) => {
                    const n = a.length;
                    const meanA = this.calculateMean(a);
                    const meanB = this.calculateMean(b);
                    let sum = 0;
                    for (let i = 0; i < n; i++) sum += (a[i] - meanA) * (b[i] - meanB);
                    return sum / n;
                };
                const matrix = aligned.map(row => aligned.map(col => cov(row, col)));
                const z = this.scaleMode === 'annualized' ? matrix.map(r => r.map(v => v * 252)) : matrix;
                this.renderSeabornHeatmap(symbols, z);
            }

            async ensureSeabornReady() {
                return await this.ensurePyodideAndPackages();
            }

            loadPyodideScript() {
                const sources = [
                    { src: 'pyodide/pyodide.js', indexURL: 'pyodide/' },
                    { src: 'https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js', indexURL: 'https://cdn.jsdelivr.net/pyodide/v0.24.1/full/' },
                    { src: 'https://unpkg.com/pyodide@0.24.1/full/pyodide.js', indexURL: 'https://unpkg.com/pyodide@0.24.1/full/' }
                ];
                return new Promise(resolve => {
                    if (typeof loadPyodide === 'function') return resolve(sources[1].indexURL);
                    const tryNext = (i) => {
                        if (i >= sources.length) return resolve(null);
                        const { src, indexURL } = sources[i];
                        const script = document.createElement('script');
                        script.src = src;
                        script.async = true;
                        script.onload = () => resolve(indexURL);
                        script.onerror = () => {
                            script.remove();
                            tryNext(i + 1);
                        };
                        document.head.appendChild(script);
                    };
                    tryNext(0);
                });
            }

            async renderSeabornHeatmap(labels, z) {
                const el = document.getElementById('covHeatmap');
                if (!el) return;
                try {
                    el.textContent = 'Loading Seaborn (Pyodide)...';
                    const ok = await this.ensureSeabornReady();
                    if (!ok || !this.pyodide) {
                        el.textContent = 'Seaborn heatmap unavailable (Pyodide not loaded).';
                        return;
                    }
                    // Set variables into Python
                    this.pyodide.globals.set('labels', labels);
                    this.pyodide.globals.set('z', z);
                    let pyCode = `
import numpy as np
import matplotlib
matplotlib.use('AGG')
import matplotlib.pyplot as plt
import seaborn as sns
import io, base64

arr = np.array(z)
# Use larger size for better visibility
fig_w = 16
fig_h = 14
fig, ax = plt.subplots(figsize=(fig_w, fig_h))
sns.heatmap(arr, xticklabels=labels, yticklabels=labels, cmap='RdBu_r', center=0, square=False, cbar=True, annot=True, fmt='.2%', annot_kws={'size':14})
plt.tight_layout()
buf = io.BytesIO()
fig.savefig(buf, format='png', dpi=150, bbox_inches='tight')
buf.seek(0)
base64.b64encode(buf.read()).decode('ascii')
 `;
                    pyCode = this.dedentPython(pyCode);
                    const b64 = await this.pyodide.runPythonAsync(pyCode);
                    el.innerHTML = `<img src=\"data:image/png;base64,${b64}\" style=\"max-width:100%;max-height:100%;width:100%;height:100%;object-fit:contain;\" />`;
                } catch (e) {
                    console.error('Seaborn heatmap error:', e);
                    el.textContent = `Error rendering Seaborn heatmap: ${e && (e.message || e.toString())}`;
                }
            }

            dedentPython(code) {
                // Remove leading blank line
                if (code.startsWith('\n')) code = code.slice(1);
                const lines = code.split('\n');
                let minIndent = Infinity;
                for (const line of lines) {
                    if (line.trim().length === 0) continue;
                    const m = line.match(/^\s+/);
                    if (m) minIndent = Math.min(minIndent, m[0].length);
                    else { minIndent = 0; break; }
                }
                if (!isFinite(minIndent) || minIndent <= 0) return code;
                return lines.map(l => (l.length >= minIndent ? l.slice(minIndent) : l)).join('\n');
            }

            resetHeatmap() {
                // Reset Pyodide instance
                this.pyodide = null;
                // Remove any existing pyodide script tags to force fresh load next time
                document.querySelectorAll('script[src*="pyodide"]').forEach(s => s.remove());
                // Remove any previous heatmap content if present
                const existing = document.getElementById('covHeatmap');
                if (existing) existing.innerHTML = '';
            }

            renderPlotlyHeatmap(labels, z) {
                const el = document.getElementById('covHeatmap');
                if (!el) return;
                if (!window.Plotly) {
                    el.textContent = 'Heatmap renderer unavailable.';
                    return;
                }
                const text = z.map(row => row.map(v => (typeof v === 'number' ? v.toFixed(3) : '')));
                const data = [{
                    z: z,
                    x: labels,
                    y: labels,
                    type: 'heatmap',
                    colorscale: 'RdBu',
                    reversescale: true,
                    hovertemplate: '%{y} / %{x}: %{z:.6f}<extra></extra>',
                    text: text,
                    texttemplate: '%{text}',
                    textfont: { size: 10 }
                }];
                const layout = {
                    margin: { l: 60, r: 10, t: 10, b: 60 },
                    xaxis: { side: 'bottom' },
                    yaxis: { autorange: 'reversed' },
                    height: 400
                };
                window.Plotly.newPlot(el, data, layout, { displayModeBar: false });
            }

            switchHeatmap(direction) {
                if (!this.heatmapData) return;
                
                const newIndex = this.currentHeatmapIndex + direction;
                if (newIndex < 0 || newIndex > 1) return;
                
                this.currentHeatmapIndex = newIndex;
                this.updateHeatmapNavigation();
                this.renderCurrentHeatmap();
            }

            updateHeatmapNavigation() {
                const prevBtn = document.getElementById('prevHeatmap');
                const nextBtn = document.getElementById('nextHeatmap');
                const indicator = document.getElementById('heatmapIndicator');
                const title = document.getElementById('heatmapTitle');
                
                if (prevBtn && nextBtn && indicator && title) {
                    prevBtn.disabled = this.currentHeatmapIndex === 0;
                    nextBtn.disabled = this.currentHeatmapIndex === 1;
                    indicator.textContent = `${this.currentHeatmapIndex + 1} of 2`;
                    
                    if (this.currentHeatmapIndex === 0) {
                        title.innerHTML = `<i class="fas fa-border-all"></i> Variance-Covariance Heatmap (${this.scaleMode === 'daily' ? 'Daily' : 'Annualized'})`;
                    } else {
                        title.innerHTML = `<i class="fas fa-th"></i> Correlation Heatmap`;
                    }
                }
            }

            renderCurrentHeatmap() {
                if (!this.heatmapData) return;
                
                if (this.currentHeatmapIndex === 0) {
                    this.renderVarianceCovarianceHeatmapContent(this.heatmapData);
                } else {
                    this.renderCorrelationHeatmapContent(this.heatmapData);
                }
            }

            setupHeatmapEventListeners() {
                const prevHeatmapBtn = document.getElementById('prevHeatmap');
                const nextHeatmapBtn = document.getElementById('nextHeatmap');
                
                if (prevHeatmapBtn) {
                    // Remove existing listener to prevent duplicates
                    prevHeatmapBtn.removeEventListener('click', this.prevHeatmapHandler);
                    this.prevHeatmapHandler = () => this.switchHeatmap(-1);
                    prevHeatmapBtn.addEventListener('click', this.prevHeatmapHandler);
                }
                
                if (nextHeatmapBtn) {
                    // Remove existing listener to prevent duplicates
                    nextHeatmapBtn.removeEventListener('click', this.nextHeatmapHandler);
                    this.nextHeatmapHandler = () => this.switchHeatmap(1);
                    nextHeatmapBtn.addEventListener('click', this.nextHeatmapHandler);
                }
            }

            async renderVarianceCovarianceHeatmap(results) {
                try {
                    // Store data for switching
                    this.heatmapData = results;
                    this.currentHeatmapIndex = 0;
                    
                    // Update navigation
                    this.updateHeatmapNavigation();
                    
                    // Set up event listeners for heatmap navigation
                    this.setupHeatmapEventListeners();
                    
                    // Render the first heatmap
                    this.renderVarianceCovarianceHeatmapContent(results);
                } catch (e) {
                    console.error('Error in renderVarianceCovarianceHeatmap:', e);
                }
            }

            async renderVarianceCovarianceHeatmapContent(results) {
                try {
                    const el = document.getElementById('heatmapContainer');
                    if (!el) return;
                    const symbols = Object.keys(results).filter(k => k !== 'portfolio');
                    if (!symbols.length) return;
                    const lengths = symbols.map(sym => (results[sym].returns || []).length).filter(n => n > 0);
                    if (!lengths.length) return;
                    const T = Math.min(...lengths);
                    if (T < 2) return;
                    const series = symbols.map(sym => results[sym].returns.slice(-T));
                    el.textContent = 'Loading Seaborn (Pyodide)...';
                    const ok = await this.ensurePyodideAndPackages();
                    if (!ok || !this.pyodide) {
                        el.textContent = 'Unable to load numpy/matplotlib/seaborn in Pyodide.';
                        return;
                    }
                    // Pass data to Python
                    this.pyodide.globals.set('labels', symbols);
                    this.pyodide.globals.set('arr_js', series);
                    const annualize = this.scaleMode === 'annualized';
                    this.pyodide.globals.set('annualize_js', annualize);
                    const pyCode = [
                        'import numpy as np',
                        'import matplotlib',
                        "matplotlib.use('AGG')",
                        'import matplotlib.pyplot as plt',
                        'import seaborn as sns',
                        'import io, base64',
                        'arr = np.array(arr_js, dtype=float)',
                        'cov = np.cov(arr, bias=False)',
                        'if annualize_js: cov = cov * 252.0',
                        'fig, ax = plt.subplots(figsize=(16, 14))',
                        "sns.heatmap(cov, xticklabels=labels, yticklabels=labels, cmap='viridis', square=False, cbar=True, annot=True, fmt='.2%', annot_kws={'size':14})",
                        'plt.tight_layout()',
                        'buf = io.BytesIO()',
                        "fig.savefig(buf, format='png', dpi=150)",
                        'buf.seek(0)',
                        'base64.b64encode(buf.read()).decode("ascii")'
                    ].join('\n');
                    const b64 = await this.pyodide.runPythonAsync(pyCode);
                    el.innerHTML = `<img src="data:image/png;base64,${b64}" style="max-width:100%;max-height:100%;width:100%;height:100%;object-fit:contain;" />`;
                } catch (e) {
                    const el = document.getElementById('covHeatmap');
                    if (el) el.textContent = `Error rendering Seaborn heatmap: ${e && (e.message || e.toString())}`;
                    console.warn('Unable to render variance-covariance heatmap (Seaborn):', e);
                }
            }

            async ensurePyodideAndPackages() {
                try {
                    // If already loaded and working, return true
                    if (this.pyodide) {
                        try {
                            // Quick test to ensure it's still working
                            await this.pyodide.runPythonAsync('import numpy');
                            return true;
                        } catch (e) {
                            console.warn('Existing Pyodide instance failed, reloading:', e);
                            this.pyodide = null;
                        }
                    }
                    
                    // Prevent multiple simultaneous loading attempts
                    if (this.pyodideLoading) {
                        // Wait for ongoing load
                        while (this.pyodideLoading) {
                            await new Promise(resolve => setTimeout(resolve, 100));
                        }
                        return this.pyodide !== null;
                    }
                    
                    this.pyodideLoading = true;
                    
                    try {
                        console.log('Loading Pyodide and packages...');
                        
                        // Load Pyodide
                        const pyodide = await loadPyodide({
                            indexURL: 'https://cdn.jsdelivr.net/pyodide/v0.24.1/full/'
                        });
                        
                        console.log('Pyodide loaded, installing packages...');
                        
                        // Load packages in correct order
                        await pyodide.loadPackage(['micropip']);
                        await pyodide.loadPackage(['numpy']);
                        await pyodide.loadPackage(['matplotlib']);
                        await pyodide.loadPackage(['pandas']);
                        
                        console.log('Core packages loaded, installing seaborn...');
                        
                        // Install seaborn via micropip
                        await pyodide.runPythonAsync(`
import micropip
await micropip.install(['seaborn==0.12.2'])
print("Seaborn installed successfully")
`);
                        
                        console.log('Installing Plotly...');
                        
                        // Install plotly via micropip
                        await pyodide.runPythonAsync(`
import micropip
await micropip.install(['plotly==5.17.0'])
print("Plotly installed successfully")
`);
                        
                        // Verify all imports work
                        await pyodide.runPythonAsync(`
import numpy as np
import matplotlib
matplotlib.use('AGG')
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
import plotly.graph_objects as go
import plotly.offline as pyo
import io
import base64
print("All packages imported successfully")
`);
                        
                        this.pyodide = pyodide;
                        console.log('All Python packages loaded successfully');
                        return true;
                        
                    } catch (error) {
                        console.error('Failed to load Pyodide/packages:', error);
                        this.pyodide = null;
                        return false;
                    } finally {
                        this.pyodideLoading = false;
                    }
                    
                } catch (e) {
                    console.error('Error in ensurePyodideAndPackages:', e);
                    this.pyodideLoading = false;
                    return false;
                }
            }

            async generateEfficientFrontier() {
                try {
                    const results = this.lastAnalysisResults || {};
                    const symbols = Object.keys(results).filter(k => k !== 'portfolio');
                    
                    // Validation
                    if (symbols.length < 2) {
                        alert('Add at least two stocks to build the efficient frontier');
                        return;
                    }
                    
                    const lengths = symbols.map(s => (results[s].returns || []).length).filter(n => n > 0);
                    if (!lengths.length) {
                        alert('Insufficient return history');
                        return;
                    }
                    
                    const T = Math.min(...lengths);
                    if (T < 2) {
                        alert('Insufficient aligned returns for analysis');
                        return;
                    }

                    // Get number of simulations from user input
                    const N = Math.max(1000, Math.min(100000, parseInt(document.getElementById('frontierSimulations').value, 10) || 10000));
                    
                    // Show progress
                    const plotEl = document.getElementById('frontierPlot');
                    plotEl.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #666;"><i class="fas fa-spinner fa-spin" style="margin-right: 10px;"></i>Generating ' + N.toLocaleString() + ' portfolio simulations...</div>';

                    // Get aligned log returns data
                    const series = symbols.map(s => results[s].returns.slice(-T));
                    
                    // Calculate mean vector μ and covariance matrix Σ (daily)
                    const mu = series.map(r => ss.mean(r));
                    const n = symbols.length;
                    
                    // Build covariance matrix using simple-statistics
                    const Sigma = Array.from({ length: n }, (_, i) => 
                        Array.from({ length: n }, (_, j) => {
                            if (i === j) {
                                return ss.variance(series[i]) || 1e-6;
                            } else {
                                return ss.sampleCovariance(series[i], series[j]) || 0;
                            }
                        })
                    );

                    // Ridge regularization for numerical stability
                    const ridge = 1e-6;
                    for (let i = 0; i < n; i++) {
                        Sigma[i][i] += ridge;
                    }
                    
                    // Scale to match selected mode (daily vs annualized)
                    const isAnnual = this.scaleMode === 'annualized';
                    const muUse = isAnnual ? mu.map(m => m * 252) : mu;
                    const SigmaUse = isAnnual ? Sigma.map(row => row.map(v => v * 252)) : Sigma;
                    const rf = this.riskFreeRateAnnual || 0;
                    const rfUse = isAnnual ? rf : (rf / 252);

                    // Generate random long-only weights using Dirichlet distribution
                    const generateDirichletWeights = () => {
                        const alpha = Array(n).fill(1); // Uniform Dirichlet
                        const samples = alpha.map(() => {
                            // Generate Gamma random variable (approximation using rejection sampling)
                            let x, y;
                            do {
                                x = Math.random();
                                y = Math.random();
                            } while (x === 0 || y === 0);
                            return -Math.log(x);
                        });
                        const sum = samples.reduce((a, b) => a + b, 0);
                        return samples.map(s => s / sum);
                    };

                    // Portfolio calculations
                    const portfolioReturn = (w) => w.reduce((acc, wi, i) => acc + wi * muUse[i], 0);
                    const portfolioVariance = (w) => {
                        let variance = 0;
                        for (let i = 0; i < n; i++) {
                            for (let j = 0; j < n; j++) {
                                variance += w[i] * SigmaUse[i][j] * w[j];
                            }
                        }
                        return Math.max(variance, 1e-12); // Ensure positive
                    };

                    // Simulate portfolios
                    const portfolios = [];
                    let maxReturn = { r: -Infinity };
                    let maxSharpe = { sharpe: -Infinity };
                    let minVariance = { v: Infinity };

                    for (let k = 0; k < N; k++) {
                        const weights = generateDirichletWeights();
                        const expectedReturn = portfolioReturn(weights);
                        const variance = portfolioVariance(weights);
                        const stdDev = Math.sqrt(variance);
                        const sharpe = stdDev > 0 ? (expectedReturn - rfUse) / stdDev : -Infinity;

                        const portfolio = {
                            weights,
                            expected_return: expectedReturn,
                            variance,
                            std_dev: stdDev,
                            sharpe,
                            is_min_variance: false,
                            is_max_sharpe: false,
                            is_max_return: false
                        };

                        portfolios.push(portfolio);

                        // Track optimal portfolios
                        if (expectedReturn > maxReturn.r) {
                            maxReturn = { ...portfolio, r: expectedReturn };
                        }
                        if (sharpe > maxSharpe.sharpe) {
                            maxSharpe = { ...portfolio };
                        }
                        if (variance < minVariance.v) {
                            minVariance = { ...portfolio, v: variance };
                        }
                    }

                    // Mark optimal portfolios
                    portfolios.forEach(p => {
                        p.is_max_return = Math.abs(p.expected_return - maxReturn.r) < 1e-10;
                        p.is_max_sharpe = Math.abs(p.sharpe - maxSharpe.sharpe) < 1e-10;
                        p.is_min_variance = Math.abs(p.variance - minVariance.v) < 1e-10;
                    });

                    // Calculate additional constrained portfolios
                    const targetReturn = 0.12; // 12% annual return
                    const targetReturnDaily = isAnnual ? targetReturn : targetReturn / 252;
                    
                    // Find minimum variance portfolio with return >= 12% (no shorts)
                    const minVarianceConstrained = this.findMinVarianceConstrained(portfolios, targetReturnDaily);
                    
                    // Find maximum Sharpe ratio portfolio with return >= 12% (no shorts)
                    const maxSharpeConstrained = this.findMaxSharpeConstrained(portfolios, targetReturnDaily);

                    // Store simulation data for download
                    this.frontierSimulationData = {
                        portfolios,
                        symbols,
                        scale: this.scaleMode,
                        riskFreeRate: rfUse,
                        maxReturn,
                        maxSharpe,
                        minVariance,
                        minVarianceConstrained,
                        maxSharpeConstrained
                    };

                    // Build efficient frontier (upper envelope)
                    const sortedPortfolios = [...portfolios].sort((a, b) => a.std_dev - b.std_dev);
                    const efficientFrontier = [];
                    let maxReturnSoFar = -Infinity;
                    
                    for (const portfolio of sortedPortfolios) {
                        if (portfolio.expected_return > maxReturnSoFar) {
                            efficientFrontier.push(portfolio);
                            maxReturnSoFar = portfolio.expected_return;
                        }
                    }

                    // Plot with matplotlib via Pyodide
                    await this.renderEfficientFrontierWithMatplotlib(
                        portfolios, 
                        efficientFrontier, 
                        maxReturn, 
                        maxSharpe, 
                        minVariance, 
                        minVarianceConstrained,
                        maxSharpeConstrained,
                        N, 
                        isAnnual, 
                        plotEl
                    );

                    // Show portfolio details
                    this.displayOptimalPortfolios(maxReturn, maxSharpe, minVariance, minVarianceConstrained, maxSharpeConstrained, symbols, isAnnual);
                    
                    // Show download button
                    document.getElementById('downloadFrontierBtn').style.display = 'inline-block';

                } catch (error) {
                    console.error('Error generating efficient frontier:', error);
                    const plotEl = document.getElementById('frontierPlot');
                    plotEl.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #ff4757;"><i class="fas fa-exclamation-triangle" style="margin-right: 10px;"></i>Error: ' + (error.message || error.toString()) + '</div>';
                }
            }

            async renderEfficientFrontierWithMatplotlib(portfolios, efficientFrontier, maxReturn, maxSharpe, minVariance, minVarianceConstrained, maxSharpeConstrained, N, isAnnual, plotEl) {
                try {
                    plotEl.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #666;"><i class="fas fa-spinner fa-spin" style="margin-right: 10px;"></i>Rendering chart with matplotlib...</div>';
                    
                    // Ensure Pyodide and matplotlib are ready
                    var ok = await this.ensurePyodideAndPackages();
                    if (!ok || !this.pyodide) {
                        // Fallback to simple HTML chart if matplotlib fails
                        this.renderSimpleEfficientFrontier(portfolios, efficientFrontier, maxReturn, maxSharpe, minVariance, minVarianceConstrained, maxSharpeConstrained, N, isAnnual, plotEl);
                        return;
                    }

                    // Prepare data for Python
                    const allX = portfolios.map(p => p.std_dev * 100);
                    const allY = portfolios.map(p => p.expected_return * 100);
                    const frontierX = efficientFrontier.map(p => p.std_dev * 100);
                    const frontierY = efficientFrontier.map(p => p.expected_return * 100);
                    
                    // Set data in Python globals
                    this.pyodide.globals.set('all_x', allX);
                    this.pyodide.globals.set('all_y', allY);
                    this.pyodide.globals.set('all_sharpe', portfolios.map(p => p.sharpe));
                    this.pyodide.globals.set('frontier_x', frontierX);
                    this.pyodide.globals.set('frontier_y', frontierY);
                    this.pyodide.globals.set('max_return_x', maxReturn.std_dev * 100);
                    this.pyodide.globals.set('max_return_y', maxReturn.expected_return * 100);
                    this.pyodide.globals.set('max_sharpe_x', maxSharpe.std_dev * 100);
                    this.pyodide.globals.set('max_sharpe_y', maxSharpe.expected_return * 100);
                    this.pyodide.globals.set('min_var_x', minVariance.std_dev * 100);
                    this.pyodide.globals.set('min_var_y', minVariance.expected_return * 100);
                    this.pyodide.globals.set('n_sims', N);
                    this.pyodide.globals.set('is_annual', isAnnual);
                    this.pyodide.globals.set('max_return_sharpe', maxReturn.sharpe);
                    this.pyodide.globals.set('max_sharpe_sharpe', maxSharpe.sharpe);
                    this.pyodide.globals.set('min_var_sharpe', minVariance.sharpe);
                    
                    // Add constrained portfolio data
                    if (minVarianceConstrained) {
                        this.pyodide.globals.set('min_var_constrained_x', minVarianceConstrained.std_dev * 100);
                        this.pyodide.globals.set('min_var_constrained_y', minVarianceConstrained.expected_return * 100);
                        this.pyodide.globals.set('min_var_constrained_sharpe', minVarianceConstrained.sharpe);
                    } else {
                        this.pyodide.globals.set('min_var_constrained_x', null);
                        this.pyodide.globals.set('min_var_constrained_y', null);
                        this.pyodide.globals.set('min_var_constrained_sharpe', null);
                    }
                    
                    if (maxSharpeConstrained) {
                        this.pyodide.globals.set('max_sharpe_constrained_x', maxSharpeConstrained.std_dev * 100);
                        this.pyodide.globals.set('max_sharpe_constrained_y', maxSharpeConstrained.expected_return * 100);
                        this.pyodide.globals.set('max_sharpe_constrained_sharpe', maxSharpeConstrained.sharpe);
                    } else {
                        this.pyodide.globals.set('max_sharpe_constrained_x', null);
                        this.pyodide.globals.set('max_sharpe_constrained_y', null);
                        this.pyodide.globals.set('max_sharpe_constrained_sharpe', null);
                    }

                    const pyCode = `
import matplotlib
matplotlib.use('AGG')
import matplotlib.pyplot as plt
import numpy as np
import io
import base64

# Create figure with high DPI for crisp display
fig, ax = plt.subplots(figsize=(12, 8), dpi=120)

# Plot all simulated portfolios as scatter with inferno colormap based on Sharpe ratio
scatter = ax.scatter(all_x, all_y, alpha=0.6, s=15, c=all_sharpe, cmap='inferno', 
                    label=f'Simulated Portfolios ({n_sims:,})')

# Add colorbar for Sharpe ratio
cbar = plt.colorbar(scatter, ax=ax, shrink=0.8, aspect=20, pad=0.02)
cbar.set_label('Sharpe Ratio', rotation=270, labelpad=15, fontsize=10, fontweight='bold')

# Plot efficient frontier as line with inferno colormap
import matplotlib.cm as cm
n_points = len(frontier_x)
colors = cm.inferno(np.linspace(0, 1, n_points))

# Plot line segments with gradient colors
for i in range(len(frontier_x)-1):
    ax.plot(frontier_x[i:i+2], frontier_y[i:i+2], color=colors[i], linewidth=3, zorder=5)

# Add a single label for the legend
ax.plot([], [], color=cm.inferno(0.5), linewidth=3, label='Efficient Frontier', zorder=5)

# Plot optimal portfolios with distinct markers
ax.scatter(min_var_x, min_var_y, s=150, c='#ff4757', marker='o', 
          edgecolors='white', linewidth=2, label=f'Min Variance (Sharpe: {min_var_sharpe:.3f})', zorder=10)

ax.scatter(max_sharpe_x, max_sharpe_y, s=150, c='#2ed573', marker='^', 
          edgecolors='white', linewidth=2, label=f'Max Sharpe (Sharpe: {max_sharpe_sharpe:.3f})', zorder=10)

ax.scatter(max_return_x, max_return_y, s=150, c='#ff6b35', marker='*', 
          edgecolors='white', linewidth=2, label=f'Max Return (Sharpe: {max_return_sharpe:.3f})', zorder=10)

# Plot constrained portfolios if they exist
if min_var_constrained_x is not None:
    ax.scatter(min_var_constrained_x, min_var_constrained_y, s=150, c='#8e44ad', marker='s', 
              edgecolors='white', linewidth=2, label=f'Min Variance >=12% (Sharpe: {min_var_constrained_sharpe:.3f})', zorder=10)

if max_sharpe_constrained_x is not None:
    ax.scatter(max_sharpe_constrained_x, max_sharpe_constrained_y, s=150, c='#f39c12', marker='D', 
              edgecolors='white', linewidth=2, label=f'Max Sharpe >=12% (Sharpe: {max_sharpe_constrained_sharpe:.3f})', zorder=10)

# Customize the plot
temporality = 'Annualized' if is_annual else 'Daily'
ax.set_xlabel(f'Risk (Standard Deviation %) - {temporality}', fontsize=12, fontweight='bold')
ax.set_ylabel(f'Expected Return (%) - {temporality}', fontsize=12, fontweight='bold')
ax.set_title(f'Efficient Frontier Analysis\\n{n_sims:,} Portfolio Simulations ({temporality})', 
             fontsize=14, fontweight='bold', pad=20)

# Add grid for better readability
ax.grid(True, alpha=0.3, linestyle='--')

# Add legend with better positioning
ax.legend(loc='upper left', fontsize=10, frameon=True, fancybox=True, 
         shadow=True, framealpha=0.9, bbox_to_anchor=(0.02, 0.98))

# Format axes
ax.tick_params(axis='both', which='major', labelsize=10)

# Add annotations for optimal portfolios
ax.annotate(f'Min Variance\\n({min_var_x:.2f}%, {min_var_y:.2f}%)', 
           xy=(min_var_x, min_var_y), xytext=(10, 20), 
           textcoords='offset points', fontsize=8, ha='left',
           bbox=dict(boxstyle='round,pad=0.3', facecolor='#ff4757', alpha=0.7, edgecolor='white'),
           arrowprops=dict(arrowstyle='->', connectionstyle='arc3,rad=0', color='#ff4757'))

ax.annotate(f'Max Sharpe\\n({max_sharpe_x:.2f}%, {max_sharpe_y:.2f}%)', 
           xy=(max_sharpe_x, max_sharpe_y), xytext=(10, -30), 
           textcoords='offset points', fontsize=8, ha='left',
           bbox=dict(boxstyle='round,pad=0.3', facecolor='#2ed573', alpha=0.7, edgecolor='white'),
           arrowprops=dict(arrowstyle='->', connectionstyle='arc3,rad=0', color='#2ed573'))

ax.annotate(f'Max Return\\n({max_return_x:.2f}%, {max_return_y:.2f}%)', 
           xy=(max_return_x, max_return_y), xytext=(-50, 10), 
           textcoords='offset points', fontsize=8, ha='right',
           bbox=dict(boxstyle='round,pad=0.3', facecolor='#ff6b35', alpha=0.7, edgecolor='white'),
           arrowprops=dict(arrowstyle='->', connectionstyle='arc3,rad=0', color='#ff6b35'))

# Add annotations for constrained portfolios if they exist
if min_var_constrained_x is not None:
    ax.annotate(f'Min Var >=12%\\n({min_var_constrained_x:.2f}%, {min_var_constrained_y:.2f}%)', 
               xy=(min_var_constrained_x, min_var_constrained_y), xytext=(10, 10), 
               textcoords='offset points', fontsize=8, ha='left',
               bbox=dict(boxstyle='round,pad=0.3', facecolor='#8e44ad', alpha=0.7, edgecolor='white'),
               arrowprops=dict(arrowstyle='->', connectionstyle='arc3,rad=0', color='#8e44ad'))

if max_sharpe_constrained_x is not None:
    ax.annotate(f'Max Sharpe >=12%\\n({max_sharpe_constrained_x:.2f}%, {max_sharpe_constrained_y:.2f}%)', 
               xy=(max_sharpe_constrained_x, max_sharpe_constrained_y), xytext=(-50, -20), 
               textcoords='offset points', fontsize=8, ha='right',
               bbox=dict(boxstyle='round,pad=0.3', facecolor='#f39c12', alpha=0.7, edgecolor='white'),
               arrowprops=dict(arrowstyle='->', connectionstyle='arc3,rad=0', color='#f39c12'))

# Tight layout to prevent clipping
plt.tight_layout()

# Convert to base64
buf = io.BytesIO()
fig.savefig(buf, format='png', dpi=120, bbox_inches='tight', facecolor='white')
buf.seek(0)
img_base64 = base64.b64encode(buf.read()).decode('ascii')
plt.close(fig)

img_base64
`;

                    const b64 = await this.pyodide.runPythonAsync(this.dedentPython(pyCode));
                    plotEl.innerHTML = `<img src="data:image/png;base64,${b64}" style="max-width:100%;max-height:100%;width:auto;height:auto;object-fit:contain;" />`;

                } catch (error) {
                    console.error('Error rendering efficient frontier with matplotlib:', error);
                    plotEl.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #ff4757;"><i class="fas fa-exclamation-triangle" style="margin-right: 10px;"></i>Error rendering chart: ' + (error.message || error.toString()) + '</div>';
                }
            }

            renderSimpleEfficientFrontier(portfolios, efficientFrontier, maxReturn, maxSharpe, minVariance, minVarianceConstrained, maxSharpeConstrained, N, isAnnual, plotEl) {
                // Create a simple HTML-based efficient frontier visualization
                var html = '<div style="padding: 20px; text-align: center;">';
                html += '<h4>Efficient Frontier Analysis (' + N.toLocaleString() + ' simulations)</h4>';
                html += '<div style="margin: 20px 0; padding: 20px; background: #f8f9fa; border-radius: 8px;">';
                html += '<p><strong>Note:</strong> Advanced matplotlib visualization unavailable. Showing summary data.</p>';
                html += '</div>';
                
                // Show optimal portfolios summary
                html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-top: 20px;">';
                
                html += '<div style="background: #fff3cd; padding: 15px; border-radius: 8px; border-left: 4px solid #ffc107;">';
                html += '<h5>Minimum Variance Portfolio</h5>';
                html += '<p>Return: ' + (minVariance.expected_return * 100).toFixed(2) + '%</p>';
                html += '<p>Risk: ' + (minVariance.std_dev * 100).toFixed(2) + '%</p>';
                html += '<p>Sharpe: ' + minVariance.sharpe.toFixed(3) + '</p>';
                html += '</div>';
                
                html += '<div style="background: #d1ecf1; padding: 15px; border-radius: 8px; border-left: 4px solid #17a2b8;">';
                html += '<h5>Maximum Sharpe Portfolio</h5>';
                html += '<p>Return: ' + (maxSharpe.expected_return * 100).toFixed(2) + '%</p>';
                html += '<p>Risk: ' + (maxSharpe.std_dev * 100).toFixed(2) + '%</p>';
                html += '<p>Sharpe: ' + maxSharpe.sharpe.toFixed(3) + '</p>';
                html += '</div>';
                
                html += '<div style="background: #f8d7da; padding: 15px; border-radius: 8px; border-left: 4px solid #dc3545;">';
                html += '<h5>Maximum Return Portfolio</h5>';
                html += '<p>Return: ' + (maxReturn.expected_return * 100).toFixed(2) + '%</p>';
                html += '<p>Risk: ' + (maxReturn.std_dev * 100).toFixed(2) + '%</p>';
                html += '<p>Sharpe: ' + maxReturn.sharpe.toFixed(3) + '</p>';
                html += '</div>';
                
                html += '</div>';
                
                if (minVarianceConstrained) {
                    html += '<div style="background: #e2e3e5; padding: 15px; border-radius: 8px; border-left: 4px solid #6c757d; margin-top: 15px;">';
                    html += '<h5>Min Variance Portfolio (Return ≥ 12%)</h5>';
                    html += '<p>Return: ' + (minVarianceConstrained.expected_return * 100).toFixed(2) + '%</p>';
                    html += '<p>Risk: ' + (minVarianceConstrained.std_dev * 100).toFixed(2) + '%</p>';
                    html += '<p>Sharpe: ' + minVarianceConstrained.sharpe.toFixed(3) + '</p>';
                    html += '</div>';
                }
                
                if (maxSharpeConstrained) {
                    html += '<div style="background: #d4edda; padding: 15px; border-radius: 8px; border-left: 4px solid #28a745; margin-top: 15px;">';
                    html += '<h5>Max Sharpe Portfolio (Return ≥ 12%)</h5>';
                    html += '<p>Return: ' + (maxSharpeConstrained.expected_return * 100).toFixed(2) + '%</p>';
                    html += '<p>Risk: ' + (maxSharpeConstrained.std_dev * 100).toFixed(2) + '%</p>';
                    html += '<p>Sharpe: ' + maxSharpeConstrained.sharpe.toFixed(3) + '</p>';
                    html += '</div>';
                }
                
                html += '</div>';
                
                plotEl.innerHTML = html;
            }

            displayOptimalPortfolios(maxReturn, maxSharpe, minVariance, minVarianceConstrained, maxSharpeConstrained, symbols, isAnnual) {
                const formatPortfolio = (portfolio, title, color) => {
                    const weightsHtml = symbols.map((symbol, i) => 
                        `<div class="weight-item">
                            <span>${symbol}:</span>
                            <span>${(portfolio.weights[i] * 100).toFixed(1)}%</span>
                        </div>`
                    ).join('');
                 
                 return `
                        <div class="portfolio-detail" style="border-left: 4px solid ${color};">
                            <h5>${title}</h5>
                            <div class="metric">
                                <span class="label">Expected Return:</span>
                                <span class="value">${(portfolio.expected_return * 100).toFixed(2)}%</span>
                                 </div>
                            <div class="metric">
                                <span class="label">Risk (Std Dev):</span>
                                <span class="value">${(portfolio.std_dev * 100).toFixed(2)}%</span>
                             </div>
                            <div class="metric">
                                <span class="label">Sharpe Ratio:</span>
                                <span class="value">${portfolio.sharpe.toFixed(3)}</span>
                         </div>
                            <div class="metric">
                                <span class="label">Variance:</span>
                                <span class="value">${(portfolio.variance * 10000).toFixed(4)}%</span>
                            </div>
                            <div class="weights">
                                <strong>Portfolio Weights:</strong>
                                ${weightsHtml}
                         </div>
                     </div>
                 `;
                };

                document.getElementById('minVariancePortfolio').innerHTML = formatPortfolio(minVariance, 'Minimum Variance Portfolio', '#ff4757');
                document.getElementById('maxSharpePortfolio').innerHTML = formatPortfolio(maxSharpe, 'Maximum Sharpe Ratio Portfolio', '#2ed573');
                document.getElementById('maxReturnPortfolio').innerHTML = formatPortfolio(maxReturn, 'Maximum Return Portfolio', '#ff6b35');
                
                // Display constrained portfolios if they exist
                if (minVarianceConstrained) {
                    document.getElementById('minVarianceConstrainedPortfolio').innerHTML = formatPortfolio(minVarianceConstrained, 'Min Variance Portfolio (Return ≥ 12%)', '#8e44ad');
                    document.getElementById('minVarianceConstrainedPortfolio').style.display = 'block';
                } else {
                    document.getElementById('minVarianceConstrainedPortfolio').style.display = 'none';
                }
                
                if (maxSharpeConstrained) {
                    document.getElementById('maxSharpeConstrainedPortfolio').innerHTML = formatPortfolio(maxSharpeConstrained, 'Max Sharpe Portfolio (Return ≥ 12%)', '#f39c12');
                    document.getElementById('maxSharpeConstrainedPortfolio').style.display = 'block';
                } else {
                    document.getElementById('maxSharpeConstrainedPortfolio').style.display = 'none';
                }
                
                document.getElementById('frontierSummary').style.display = 'block';
            }

            downloadFrontierData() {
                if (!this.frontierSimulationData) {
                    alert('No frontier data available. Please generate the efficient frontier first.');
                    return;
                }

                const { portfolios, symbols, scale, riskFreeRate } = this.frontierSimulationData;
                
                // Create CSV header
                const weightColumns = symbols.map(s => `Weight_${s}`);
                const header = [
                    'Portfolio_ID',
                    ...weightColumns,
                    'Expected_Return',
                    'Variance', 
                    'Standard_Deviation',
                    'Sharpe_Ratio',
                    'Is_Min_Variance',
                    'Is_Max_Sharpe',
                    'Is_Max_Return'
                ];

                // Create CSV rows
                const rows = [header];
                portfolios.forEach((portfolio, index) => {
                    const row = [
                        index + 1,
                        ...portfolio.weights.map(w => (w * 100).toFixed(2) + '%'),
                        (portfolio.expected_return * 100).toFixed(2) + '%',
                        (portfolio.variance * 10000).toFixed(2) + '%',
                        (portfolio.std_dev * 100).toFixed(2) + '%',
                        portfolio.sharpe.toFixed(2),
                        portfolio.is_min_variance ? '1' : '0',
                        portfolio.is_max_sharpe ? '1' : '0',
                        portfolio.is_max_return ? '1' : '0'
                    ];
                    rows.push(row);
                });

                // Convert to CSV string
                const csvContent = rows.map(row => 
                    row.map(cell => {
                        const str = String(cell);
                        return (str.includes(',') || str.includes('"')) ? '"' + str.replace(/"/g, '""') + '"' : str;
                    }).join(',')
                ).join('\r\n');

                // Add metadata as comments
                const metadata = [
                    `# Efficient Frontier Simulation Results`,
                    `# Generated: ${new Date().toISOString()}`,
                    `# Scale: ${scale}`,
                    `# Risk-Free Rate: ${(riskFreeRate * 100).toFixed(4)}%`,
                    `# Number of Simulations: ${portfolios.length.toLocaleString()}`,
                    `# Symbols: ${symbols.join(', ')}`,
                    `# `,
                    csvContent
                ].join('\r\n');

                // Download file
                const blob = new Blob(["\uFEFF" + metadata], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                const startDate = document.getElementById('startDate').value;
                const endDate = document.getElementById('endDate').value;
                a.href = url;
                a.download = `efficient_frontier_${scale}_${startDate}_to_${endDate}_${portfolios.length}sims.csv`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            async renderCorrelationHeatmap(results) {
                // This method is now called internally by renderCurrentHeatmap
                // The actual rendering is done in renderCorrelationHeatmapContent
            }

            async renderCorrelationHeatmapContent(results) {
                try {
                    const el = document.getElementById('heatmapContainer');
                    if (!el) return;
                    const symbols = Object.keys(results).filter(k => k !== 'portfolio');
                    if (!symbols.length) return;
                    const lengths = symbols.map(sym => (results[sym].returns || []).length).filter(n => n > 0);
                    if (!lengths.length) return;
                    const T = Math.min(...lengths);
                    if (T < 2) return;
                    const series = symbols.map(sym => results[sym].returns.slice(-T));
                    el.textContent = 'Loading Seaborn (Pyodide)...';
                    const ok = await this.ensurePyodideAndPackages();
                    if (!ok || !this.pyodide) {
                        el.textContent = 'Unable to load numpy/matplotlib/seaborn in Pyodide.';
                        return;
                    }
                    this.pyodide.globals.set('labels', symbols);
                    this.pyodide.globals.set('arr_js', series);
                    const pyCode = [
                        'import numpy as np',
                        'import matplotlib',
                        "matplotlib.use('AGG')",
                        'import matplotlib.pyplot as plt',
                        'import seaborn as sns',
                        'import io, base64',
                        'arr = np.array(arr_js, dtype=float)',
                        'corr = np.corrcoef(arr)',
                        'fig, ax = plt.subplots(figsize=(16, 14))',
                        "sns.heatmap(corr, vmin=-1, vmax=1, xticklabels=labels, yticklabels=labels, cmap='viridis', square=False, cbar=True, annot=True, fmt='.3f', annot_kws={'size':14})",
                        'plt.tight_layout()',
                        'buf = io.BytesIO()',
                        "fig.savefig(buf, format='png', dpi=150, bbox_inches='tight')",
                        'buf.seek(0)',
                        'base64.b64encode(buf.read()).decode("ascii")'
                    ].join('\n');
                    const b64 = await this.pyodide.runPythonAsync(pyCode);
                    el.innerHTML = `<img src="data:image/png;base64,${b64}" style="max-width:100%;max-height:100%;width:100%;height:100%;object-fit:contain;" />`;
                } catch (e) {
                    const el = document.getElementById('corrHeatmap');
                    if (el) el.textContent = `Error rendering Correlation heatmap: ${e && (e.message || e.toString())}`;
                    console.warn('Unable to render correlation heatmap (Seaborn):', e);
                }
            }


            
            isUSMarketDay(date) {
                const day = date.getDay();
                // Monday = 1, Tuesday = 2, ..., Friday = 5, Saturday = 6, Sunday = 0
                return day >= 1 && day <= 5; // Monday to Friday
            }
            














            processData912Data(data, symbol, sourceName, type) {
                try {
                    console.log(`Processing Data912 data for ${symbol}...`);
                    
                    let price, change, changePercent, volume, timestamp, historicalData, timestamps;
                    
                    if (type === 'data912') {
                        if (sourceName.includes('Real-time')) {
                            // Real-time quote data
                            price = data.price || data.close || data.last;
                            change = data.change || data.price_change;
                            changePercent = data.change_percent || data.price_change_percent;
                            volume = data.volume || data.trading_volume;
                            timestamp = data.timestamp || Math.floor(Date.now() / 1000);
                            
                            // For real-time, create minimal historical data
                            historicalData = [price];
                            timestamps = [timestamp];
                        } else {
                            // Historical data
                            const prices = data.prices || data.close || [];
                            const volumes = data.volumes || data.volume || [];
                            const dates = data.dates || data.timestamps || [];
                            
                            if (prices.length === 0) {
                                console.warn('No historical data available from Data912');
                                return null;
                            }
                            
                            historicalData = prices;
                            timestamps = dates.map(d => typeof d === 'string' ? Math.floor(new Date(d).getTime() / 1000) : d);
                            
                            const latestIndex = historicalData.length - 1;
                            const previousIndex = Math.max(0, latestIndex - 1);
                            
                            price = historicalData[latestIndex];
                            const previousPrice = historicalData[previousIndex];
                            change = price - previousPrice;
                            changePercent = (change / previousPrice) * 100;
                            volume = volumes[latestIndex] || 0;
                            timestamp = timestamps[latestIndex];
                        }
                    } else {
                        console.warn('Unknown data type for Data912:', type);
                        return null;
                    }
                    
                    // Validate data
                    if (!price || isNaN(price) || price <= 0) {
                        console.warn('Invalid price data from Data912:', price);
                        return null;
                    }
                    
                    const lastUpdateTime = new Date(timestamp * 1000);
                    const currentTime = new Date();
                    const timeDiff = currentTime - lastUpdateTime;
                    const hoursDiff = Math.floor(timeDiff / (1000 * 60 * 60));
                    
                    console.log(`✅ Data912 data processed for ${symbol}:`);
                    console.log(`   Current Price: $${price.toFixed(2)}`);
                    console.log(`   Last Update: ${lastUpdateTime.toLocaleString()}`);
                    console.log(`   Data Age: ${hoursDiff} hours ago`);
                    console.log(`   Data Points: ${historicalData.length}`);
                    
                    return {
                        symbol: symbol,
                        price: price,
                        change: change,
                        changePercent: changePercent,
                        volume: volume,
                        timestamp: timestamp,
                        historicalData: historicalData,
                        timestamps: timestamps,
                        lastUpdate: lastUpdateTime,
                        dataAge: hoursDiff,
                        isRealData: true,
                        source: sourceName
                    };
                    
                } catch (error) {
                    console.error('Error processing Data912 data:', error);
                    return null;
                }
            }

            async processYahooData(yahooData, symbol) {
                try {
                    const result = yahooData.chart.result[0];
                    const timestamps = result.timestamp;
                    const adjcloseNode = result.indicators && result.indicators.adjclose && result.indicators.adjclose[0] ? result.indicators.adjclose[0].adjclose : null;
                    const closeNode = result.indicators && result.indicators.quote && result.indicators.quote[0] ? result.indicators.quote[0].close : null;
                    const pricesSeries = (adjcloseNode && adjcloseNode.length ? adjcloseNode : closeNode);
                    const volumes = result.indicators.quote[0].volume;
                    
                    // Get real-time quote data for ask price
                    let askPrice = null;
                    try {
                        const quoteData = await this.getRealTimeQuote(symbol);
                        if (quoteData && quoteData.ask) {
                            askPrice = quoteData.ask;
                            console.log(`✅ Got ask price for ${symbol}: $${askPrice.toFixed(2)}`);
                        }
                    } catch (quoteError) {
                        console.warn(`Could not get ask price for ${symbol}:`, quoteError.message);
                    }

                    // Align series by removing null prices and matching timestamps/volumes
                    const filteredPrices = [];
                    const filteredTimestamps = [];
                    const filteredVolumes = [];
                    for (let i = 0; i < pricesSeries.length; i++) {
                        const price = pricesSeries[i];
                        if (price !== null) {
                            filteredPrices.push(price);
                            filteredTimestamps.push(timestamps[i]);
                            filteredVolumes.push(volumes[i]);
                        }
                    }

                    const startDate = document.getElementById('startDate').value;
                    const endDate = document.getElementById('endDate').value;
                    
                    // Filter to US market available days
                    const usTradingSet = this.getUsTradingDaySet(startDate, endDate);
                    const usPrices = [];
                    const usTimestamps = [];
                    const usVolumes = [];
                    for (let i = 0; i < filteredTimestamps.length; i++) {
                        const iso = new Date(filteredTimestamps[i] * 1000).toISOString().slice(0, 10);
                        if (usTradingSet.has(iso)) {
                            usPrices.push(filteredPrices[i]);
                            usTimestamps.push(filteredTimestamps[i]);
                            usVolumes.push(filteredVolumes[i]);
                        }
                    }

                    const seriesPrices = usPrices.length >= 2 ? usPrices : filteredPrices;
                    const seriesTimestamps = usTimestamps.length >= 2 ? usTimestamps : filteredTimestamps;
                    const seriesVolumes = usVolumes.length >= 2 ? usVolumes : filteredVolumes;

                    const latestIndex = seriesPrices.length - 1;
                    const previousIndex = Math.max(0, latestIndex - 1);

                    const currentPrice = askPrice || seriesPrices[latestIndex];
                    const previousPrice = seriesPrices[previousIndex];
                    const change = currentPrice - previousPrice;
                    const changePercent = (change / previousPrice) * 100;

                    // Add data freshness information
                    const lastUpdateTime = new Date(seriesTimestamps[latestIndex] * 1000);
                    const currentTime = new Date();
                    const timeDiff = currentTime - lastUpdateTime;
                    const hoursDiff = Math.floor(timeDiff / (1000 * 60 * 60));
                    
                    console.log(`✅ Real data fetched for ${symbol}:`);
                    console.log(`   Current Price: $${currentPrice.toFixed(2)} ${askPrice ? '(ASK PRICE)' : '(CLOSE PRICE)'}`);
                    console.log(`   Last Update: ${lastUpdateTime.toLocaleString()}`);
                    console.log(`   Data Age: ${hoursDiff} hours ago`);
                    console.log(`   Data Points: ${seriesPrices.length}`);
                    
                    return {
                        symbol: symbol,
                        price: currentPrice,
                        change: change,
                        changePercent: changePercent,
                        volume: seriesVolumes[latestIndex],
                        high: Math.max(...seriesPrices),
                        low: Math.min(...seriesPrices),
                        open: seriesPrices[0],
                        close: currentPrice,
                        ask: askPrice,
                        bid: askPrice ? askPrice * 0.998 : null,
                        timestamp: seriesTimestamps[latestIndex],
                        historicalData: seriesPrices,
                        timestamps: seriesTimestamps,
                        lastUpdate: lastUpdateTime,
                        dataAge: hoursDiff,
                        isRealData: true,
                        isAskPrice: !!askPrice
                    };
                    
                } catch (error) {
                    console.error('Error processing Yahoo data:', error);
                    throw error;
                }
            }

            // Get real-time quote data including ask price
            async getRealTimeQuote(symbol) {
                try {
                    const proxyUrls = [
                        `https://corsproxy.io/?`,
                        `https://api.codetabs.com/v1/proxy?quest=`,
                        `https://cors.bridged.cc/?`,
                        `https://api.allorigins.win/raw?url=`
                    ];
                    
                    const quoteUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?interval=1m&range=1d&includePrePost=true&_t=${Date.now()}`;
                    
                    for (const proxyUrl of proxyUrls) {
                        try {
                            const fullUrl = proxyUrl + encodeURIComponent(quoteUrl);
                            const response = await fetch(fullUrl, {
                                method: 'GET',
                                headers: {
                                    'Accept': 'application/json',
                                    'Content-Type': 'application/json'
                                },
                                timeout: 5000
                            });
                            
                            if (response.ok) {
                                const data = await response.json();
                                let yahooData;
                                
                                if (data.contents) {
                                    yahooData = JSON.parse(data.contents);
                                } else if (data.chart) {
                                    yahooData = data;
                                } else {
                                    continue;
                                }
                                
                                if (yahooData.chart && yahooData.chart.result && yahooData.chart.result[0]) {
                                    const result = yahooData.chart.result[0];
                                    const meta = result.meta;
                                    
                                    // Extract ask price from meta data
                                    if (meta && meta.regularMarketPrice) {
                                        // For most stocks, we'll use the regular market price as ask
                                        // In a real implementation, you might want to add a small spread
                                        const askPrice = meta.regularMarketPrice * 1.001; // Add 0.1% spread as estimate
                                        
                                        return {
                                            ask: askPrice,
                                            bid: meta.regularMarketPrice * 0.999, // Subtract 0.1% spread as estimate
                                            last: meta.regularMarketPrice,
                                            volume: meta.regularMarketVolume || 0,
                                            timestamp: meta.regularMarketTime
                                        };
                                    }
                                }
                            }
                        } catch (error) {
                            console.warn(`Quote proxy failed:`, error.message);
                            continue;
                        }
                    }
                    
                    return null;
                } catch (error) {
                    console.error('Error getting real-time quote:', error);
                    return null;
                }
            }

            updateMarketStatus() {
                try {
                    const now = new Date();
                    const dayOfWeek = now.getDay();
                    const hour = now.getHours();
                    const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
                    const isMarketHours = hour >= 9 && hour <= 16;
                    
                    const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                    const dayName = dayNames[dayOfWeek];
                    
                    let statusText = '';
                    let statusIcon = '';
                    let statusColor = '';
                    
                    if (isWeekend) {
                        statusText = `Markets closed (${dayName}) - Data from Friday`;
                        statusIcon = 'fa-calendar-times';
                        statusColor = '#ffa502';
                    } else if (hour < 9) {
                        statusText = `Markets not open yet (${dayName}) - Data from yesterday`;
                        statusIcon = 'fa-clock';
                        statusColor = '#ffa502';
                    } else if (hour > 16) {
                        statusText = `Markets closed for the day (${dayName}) - Data from today`;
                        statusIcon = 'fa-calendar-check';
                        statusColor = '#2ed573';
                    } else {
                        statusText = `Markets open (${dayName}) - Real-time data available`;
                        statusIcon = 'fa-chart-line';
                        statusColor = '#2ed573';
                    }
                    
                    const marketStatusElement = document.getElementById('marketStatus');
                    if (marketStatusElement) {
                        // Calculate average data age for portfolio
                        let avgDataAge = 0;
                        let realDataCount = 0;
                        let simulatedDataCount = 0;
                        
                        if (this.portfolio.size > 0) {
                            this.portfolio.forEach((data) => {
                                if (data.isRealData) {
                                    avgDataAge += data.dataAge || 0;
                                    realDataCount++;
                                } else {
                                    simulatedDataCount++;
                                }
                            });
                            
                            if (realDataCount > 0) {
                                avgDataAge = Math.round(avgDataAge / realDataCount);
                            }
                        }
                        
                        const dataStatusText = this.portfolio.size > 0 ? 
                            `<br><small style="color: #555; font-weight: 400;">Data: ${realDataCount > 0 ? 
                                `<span style="color: #2ed573;"><i class="fas fa-check-circle"></i> Real-time</span>` : 
                                `<span style="color: #ffa502;"><i class="fas fa-exclamation-triangle"></i> Simulated</span>`
                            }</small>` : '';
                        
                        marketStatusElement.innerHTML = `
                            <i class="fas ${statusIcon}" style="color: ${statusColor}; margin-right: 8px;"></i>
                            <strong style="color: #333;">${statusText}</strong>
                            <br><small style="color: #555; font-weight: 400;">Current time: ${now.toLocaleString()}</small>
                            ${dataStatusText}
                        `;
                    }
                    
                } catch (error) {
                    console.error('Error updating market status:', error);
                }
            }

            // Fetch real-time data from multiple sources
            async fetchRealTimeData(symbol) {
                try {
                    console.log(`🔄 Fetching real-time data for ${symbol}...`);
                    
                    // Enhanced proxy list for real-time data
                    const proxyUrls = [
                        `https://api.allorigins.win/get?url=`,
                        `https://cors-anywhere.herokuapp.com/`,
                        `https://thingproxy.freeboard.io/fetch/`,
                        `https://corsproxy.io/?`,
                        `https://api.codetabs.com/v1/proxy?quest=`,
                        `https://cors.bridged.cc/?`
                    ];
                    
                    // Try multiple real-time sources with proxies
                    const sources = [
                        { 
                            name: 'Yahoo Finance Real-time', 
                            url: `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?interval=1m&range=1d&_t=${Date.now()}`,
                            type: 'yahoo'
                        },
                        { 
                            name: 'Yahoo Finance Daily (fallback)', 
                            url: `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?interval=1d&range=5d&_t=${Date.now()}`,
                            type: 'yahoo'
                        },
                        { 
                            name: 'Alpha Vantage Real-time', 
                            url: `https://www.alphavantage.co/query?function=GLOBAL_QUOTE&symbol=${symbol}&apikey=demo`,
                            type: 'alpha'
                        }
                    ];
                    
                    // Try each source with each proxy
                    for (const source of sources) {
                        for (const proxyUrl of proxyUrls) {
                            try {
                                console.log(`Trying ${source.name} with ${proxyUrl.split('//')[1].split('/')[0]}...`);
                                const fullUrl = proxyUrl + encodeURIComponent(source.url);
                                const response = await fetch(fullUrl, {
                                    method: 'GET',
                                    headers: {
                                        'Accept': 'application/json',
                                        'Content-Type': 'application/json'
                                    },
                                    timeout: 8000
                                });
                                
                                if (response.ok) {
                                    const data = await response.json();
                                    
                                    // Handle different proxy response formats
                                    let processedData;
                                    if (data.contents) {
                                        processedData = JSON.parse(data.contents);
                                    } else if (data.chart || data['Global Quote']) {
                                        processedData = data;
                                    } else {
                                        continue; // Try next proxy
                                    }
                                    
                                    const result = this.processRealTimeData(processedData, symbol, source.name, source.type);
                                    if (result) {
                                        console.log(`✅ ${source.name} succeeded via ${proxyUrl.split('//')[1].split('/')[0]}`);
                                        return result;
                                    }
                                }
                            } catch (error) {
                                console.warn(`${source.name} failed with ${proxyUrl.split('//')[1].split('/')[0]}:`, error.message);
                                continue; // Try next proxy
                            }
                        }
                    }
                    
                    // Try direct API call as last resort
                    try {
                        console.log('Trying direct API call as last resort...');
                        const directUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?interval=1m&range=1d&_t=${Date.now()}`;
                        const response = await fetch(directUrl, {
                            method: 'GET',
                                                    headers: {
                            'Accept': 'application/json',
                            'Content-Type': 'application/json'
                        }
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            const result = this.processRealTimeData(data, symbol, 'Yahoo Finance Direct', 'yahoo');
                            if (result) {
                                console.log('✅ Direct API call succeeded!');
                                return result;
                            }
                        }
                    } catch (directError) {
                        console.warn('Direct API call also failed:', directError.message);
                    }
                    
                    console.warn(`No real-time data available for ${symbol}, trying recent historical data...`);
                    
                    // Fallback to recent historical data
                    try {
                        const recentData = await this.fetchStockData(symbol);
                        if (recentData && recentData.isRealData && recentData.dataAge < 48) {
                            console.log(`✅ Using recent historical data for ${symbol} (${recentData.dataAge}h ago)`);
                            return {
                                ...recentData,
                                source: 'Recent Historical Data',
                                isRealTime: false
                            };
                        }
                    } catch (fallbackError) {
                        console.warn('Fallback to historical data also failed:', fallbackError.message);
                    }
                    
                    return null;
                    
                } catch (error) {
                    console.error('Error fetching real-time data:', error);
                    return null;
                }
            }

            processRealTimeData(data, symbol, sourceName, type) {
                try {
                    let price, change, changePercent, volume, timestamp;
                    
                    if (type === 'yahoo') {
                        const result = data.chart.result[0];
                        const meta = result.meta;
                        price = meta.regularMarketPrice;
                        change = meta.regularMarketPrice - meta.previousClose;
                        changePercent = (change / meta.previousClose) * 100;
                        volume = meta.regularMarketVolume;
                        timestamp = meta.regularMarketTime;
                    } else if (type === 'alpha') {
                        const quote = data['Global Quote'];
                        if (!quote || !quote['05. price']) {
                            console.warn('Invalid Alpha Vantage data format');
                            return null;
                        }
                        price = parseFloat(quote['05. price']);
                        change = parseFloat(quote['09. change']);
                        changePercent = parseFloat(quote['10. change percent'].replace('%', ''));
                        volume = parseInt(quote['06. volume']);
                        timestamp = Date.now() / 1000;
                    } else {
                        console.warn('Unknown data type:', type);
                        return null;
                    }
                    
                    // Validate data
                    if (!price || isNaN(price) || price <= 0) {
                        console.warn('Invalid price data:', price);
                        return null;
                    }
                    
                    return {
                        symbol: symbol,
                        price: price,
                        change: change,
                        changePercent: changePercent,
                        volume: volume,
                        timestamp: timestamp,
                        lastUpdate: new Date(timestamp * 1000),
                        dataAge: 0, // Real-time data
                        isRealData: true,
                        source: sourceName
                    };
                    
                } catch (error) {
                    console.error('Error processing real-time data:', error);
                    return null;
                }
            }

            // Get real-time data for current portfolio
            async getRealTimeData() {
                try {
                    console.log('⚡ Getting real-time data for portfolio...');
                    
                    if (this.portfolio.size === 0) {
                        this.showWarning('No stocks in portfolio. Add some stocks first.');
                        return;
                    }
                    
                    // Show progress bar
                    const loadingContainer = document.getElementById('realTimeLoading');
                    const realTimeBtn = document.getElementById('realTimeBtn');
                    
                    loadingContainer.style.display = 'block';
                    realTimeBtn.disabled = true;
                    
                    const symbols = Array.from(this.portfolio.keys());
                    const results = [];
                    
                    // Initialize progress bar
                    const progressBar = loadingContainer.querySelector('.progress-bar');
                    const progressText = loadingContainer.querySelector('.progress-text');
                    const progressCurrent = loadingContainer.querySelector('.progress-current');
                    const progressTotal = loadingContainer.querySelector('.progress-details span:last-child');
                    
                    progressTotal.textContent = `of ${symbols.length} stocks`;
                    
                    for (let i = 0; i < symbols.length; i++) {
                        const symbol = symbols[i];
                        const progress = ((i + 1) / symbols.length) * 100;
                        
                        // Update progress bar
                        progressBar.style.width = `${progress}%`;
                        progressText.textContent = `Fetching ${symbol}...`;
                        progressCurrent.textContent = i + 1;
                        
                        console.log(`\n🔍 Getting real-time data for ${symbol}...`);
                        try {
                            const realTimeData = await this.fetchRealTimeData(symbol);
                            if (realTimeData) {
                                results.push(realTimeData);
                                const dataType = realTimeData.isRealTime === false ? 'Recent' : 'Real-time';
                                console.log(`✅ ${symbol}: $${realTimeData.price.toFixed(2)} (${realTimeData.change >= 0 ? '+' : ''}${realTimeData.change.toFixed(2)} ${realTimeData.changePercent.toFixed(2)}%)`);
                                console.log(`   📡 Source: ${realTimeData.source} (${dataType})`);
                                console.log(`   ⏰ Last Update: ${realTimeData.lastUpdate.toLocaleString()}`);
                            } else {
                                console.log(`❌ ${symbol}: No data available`);
                            }
                        } catch (error) {
                            console.log(`❌ ${symbol}: Error - ${error.message}`);
                        }
                    }
                    
                    // Hide progress bar
                    loadingContainer.style.display = 'none';
                    realTimeBtn.disabled = false;
                    
                    if (results.length > 0) {
                        this.showSuccess(`Got real-time data for ${results.length} stocks!`);
                        console.log(`\n📊 Real-time summary:`);
                        results.forEach(data => {
                            console.log(`${data.symbol}: $${data.price.toFixed(2)} (${data.change >= 0 ? '+' : ''}${data.changePercent.toFixed(2)}%)`);
                        });
                    } else {
                        this.showWarning('No real-time data available. Try again during market hours.');
                    }
                    
                } catch (error) {
                    console.error('Error getting real-time data:', error);
                    this.showError('Error fetching real-time data');
                    
                    // Hide progress bar on error
                    const loadingContainer = document.getElementById('realTimeLoading');
                    const realTimeBtn = document.getElementById('realTimeBtn');
                    loadingContainer.style.display = 'none';
                    realTimeBtn.disabled = false;
                }
            }

            // Test function to check data freshness
            async testDataFreshness() {
                try {
                    console.log('🧪 Testing data freshness...');
                    
                    // Check current market status
                    const now = new Date();
                    const dayOfWeek = now.getDay(); // 0 = Sunday, 1 = Monday, etc.
                    const hour = now.getHours();
                    const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
                    const isMarketHours = hour >= 9 && hour <= 16; // Simplified US market hours
                    
                    console.log(`📅 Current time: ${now.toLocaleString()}`);
                    console.log(`🏢 Market status: ${isWeekend ? 'Weekend' : isMarketHours ? 'Market Open' : 'Market Closed'}`);
                    console.log(`📊 Day of week: ${['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][dayOfWeek]}`);
                    
                    // Test current date range
                    const startDate = document.getElementById('startDate').value;
                    const endDate = document.getElementById('endDate').value;
                    
                    console.log(`📅 Testing period: ${startDate} to ${endDate}`);
                    
                    // Test a few key symbols
                    const testSymbols = ['AAPL', 'MSFT', 'GOOGL', 'TSLA'];
                    
                    for (const symbol of testSymbols) {
                        console.log(`\n🔍 Testing ${symbol}...`);
                        try {
                            const data = await this.fetchStockData(symbol);
                            const dataAgeText = data.dataAge >= 24 ? 
                                `${Math.floor(data.dataAge / 24)}d ${data.dataAge % 24}h ago` : 
                                `${data.dataAge}h ago`;
                            
                            console.log(`✅ ${symbol}: $${data.price.toFixed(2)} (${data.isRealData ? 'Real' : 'Simulated'} data, ${dataAgeText})`);
                            
                            if (data.lastUpdate) {
                                console.log(`   📅 Last update: ${data.lastUpdate.toLocaleString()}`);
                            }
                            
                            // Explain why data might be old
                            if (data.dataAge > 24) {
                                if (isWeekend) {
                                    console.log(`   ℹ️  Data is from Friday (markets closed on weekends)`);
                                } else if (hour < 9) {
                                    console.log(`   ℹ️  Data is from yesterday (markets not open yet)`);
                                } else if (hour > 16) {
                                    console.log(`   ℹ️  Data is from yesterday (markets closed for the day)`);
                                } else {
                                    console.log(`   ℹ️  Data might be delayed due to API limitations`);
                                }
                            }
                        } catch (error) {
                            console.log(`❌ ${symbol}: Error - ${error.message}`);
                        }
                    }
                    

                    
                } catch (error) {
                    console.error('Error testing data freshness:', error);
                }
            }

            // Tab Navigation Methods
            setupTabNavigation() {
                console.log('Setting up tab navigation...');
                const tabButtons = document.querySelectorAll('.tab-btn');
                const tabContents = document.querySelectorAll('.tab-content');
                
                console.log('Found tab buttons:', tabButtons.length);
                console.log('Found tab contents:', tabContents.length);

                tabButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        const targetTab = button.getAttribute('data-tab');
                        console.log('Tab clicked:', targetTab);

                        // Remove active class from all buttons and contents
                        tabButtons.forEach(btn => btn.classList.remove('active'));
                        tabContents.forEach(content => content.classList.remove('active'));

                        // Add active class to clicked button and target content
                        button.classList.add('active');
                        const targetContent = document.getElementById(targetTab);
                        
                        if (targetContent) {
                            targetContent.classList.add('active');
                            console.log('Tab content activated:', targetTab);
                        } else {
                            console.error('Target tab content not found:', targetTab);
                        }
                    });
                });

                console.log('Tab navigation setup complete');
            }

            // Bond Analysis Methods
            setupBondEventListeners() {
                console.log('Setting up bond event listeners...');
                
                // Bond calculator form event listeners
                const calculateBtn = document.getElementById('calculateBondBtn');
                const clearBtn = document.getElementById('clearBondBtn');
                const addToPortfolioBtn = document.getElementById('addToBondPortfolioBtn');
                const bondTypeSelect = document.getElementById('bondType');
                const addAmortizationBtn = document.getElementById('addAmortizationBtn');
                
                if (calculateBtn) {
                    calculateBtn.addEventListener('click', () => this.calculateBondMetrics());
                    console.log('Calculate button event listener added');
                } else {
                    console.error('Calculate button not found!');
                }
                
                if (addToPortfolioBtn) {
                    addToPortfolioBtn.addEventListener('click', () => this.addBondToPortfolio());
                    console.log('Add to portfolio button event listener added');
                } else {
                    console.error('Add to portfolio button not found!');
                }
                
                if (clearBtn) {
                    clearBtn.addEventListener('click', () => this.clearBondForm());
                    console.log('Clear button event listener added');
                } else {
                    console.error('Clear button not found!');
                }
                
                if (bondTypeSelect) {
                    bondTypeSelect.addEventListener('change', () => this.toggleAmortizationSection());
                    console.log('Bond type select event listener added');
                } else {
                    console.error('Bond type select not found!');
                }
                
                if (addAmortizationBtn) {
                    addAmortizationBtn.addEventListener('click', () => this.addAmortizationEntry());
                    console.log('Add amortization button event listener added');
                } else {
                    console.error('Add amortization button not found!');
                }
                
                // Bond comparison event listeners
                const compareBondsBtn = document.getElementById('compareBondsBtn');
                const bond1Select = document.getElementById('bond1Select');
                const bond2Select = document.getElementById('bond2Select');
                
                if (compareBondsBtn) {
                    compareBondsBtn.addEventListener('click', () => this.compareBonds());
                    console.log('Compare bonds button event listener added');
                }
                
                if (bond1Select && bond2Select) {
                    bond1Select.addEventListener('change', () => this.updateCompareButton());
                    bond2Select.addEventListener('change', () => this.updateCompareButton());
                    console.log('Bond selection event listeners added');
                }
                
                // Set default dates for bond calculator
                this.setDefaultBondDates();
                
                // Load bond portfolio
                this.loadBondPortfolio();
                this.renderBondPortfolio();
                
                console.log('Bond event listeners setup complete');
            }

            setDefaultBondDates() {
                console.log('Setting default bond dates...');
                const today = new Date();
                const oneYearAgo = new Date(today.getTime() - (365 * 24 * 60 * 60 * 1000));
                const fiveYearsFromNow = new Date(today.getTime() + (5 * 365 * 24 * 60 * 60 * 1000));
                
                // Set default dates for bond calculator
                const issueDateInput = document.getElementById('bondIssueDate');
                const maturityDateInput = document.getElementById('bondMaturityDate');
                const liquidationDateInput = document.getElementById('bondLiquidationDate');
                
                if (issueDateInput) {
                    issueDateInput.value = oneYearAgo.toISOString().split('T')[0];
                    console.log('Issue date set:', issueDateInput.value);
                } else {
                    console.error('Issue date input not found!');
                }
                
                if (maturityDateInput) {
                    maturityDateInput.value = fiveYearsFromNow.toISOString().split('T')[0];
                    console.log('Maturity date set:', maturityDateInput.value);
                } else {
                    console.error('Maturity date input not found!');
                }
                
                if (liquidationDateInput) {
                    liquidationDateInput.value = today.toISOString().split('T')[0];
                    console.log('Liquidation date set:', liquidationDateInput.value);
                } else {
                    console.error('Liquidation date input not found!');
                }
                
                console.log('Default bond dates set successfully');
            }

            toggleAmortizationSection() {
                const bondType = document.getElementById('bondType').value;
                const amortizationSection = document.getElementById('partialAmortizationSection');
                
                if (bondType === 'partial') {
                    amortizationSection.style.display = 'block';
                } else {
                    amortizationSection.style.display = 'none';
                    // Clear amortization schedule when switching to bullet
                    document.getElementById('amortizationSchedule').innerHTML = '';
                }
            }

            addAmortizationEntry() {
                const schedule = document.getElementById('amortizationSchedule');
                const entryId = Date.now(); // Unique ID for each entry
                
                const entryHTML = `
                    <div class="amortization-entry" data-entry-id="${entryId}">
                        <div class="form-group">
                            <label>Amortization Date:</label>
                            <input type="date" class="form-input amortization-date" required>
                        </div>
                        <div class="form-group">
                            <label>Amortization Percentage (%):</label>
                            <input type="number" class="form-input amortization-percentage" step="0.01" min="0" max="100" placeholder="e.g., 25.00" required>
                        </div>
                        <button type="button" class="remove-btn" onclick="portfolio.removeAmortizationEntry(${entryId})">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                `;
                
                schedule.insertAdjacentHTML('beforeend', entryHTML);
            }

            removeAmortizationEntry(entryId) {
                const entry = document.querySelector(`[data-entry-id="${entryId}"]`);
                if (entry) {
                    entry.remove();
                }
            }

            clearBondForm() {
                // Clear all form inputs
                document.getElementById('bondCompany').value = '';
                document.getElementById('bondCoupon').value = '';
                document.getElementById('bondInvestmentAmount').value = '';
                document.getElementById('bondInitialPrice').value = '';
                document.getElementById('bondActualPrice').value = '';
                
                // Reset dropdowns to defaults
                document.getElementById('bondFrequency').value = 'semiannual';
                document.getElementById('bondType').value = 'bullet';
                
                // Clear amortization schedule
                document.getElementById('amortizationSchedule').innerHTML = '';
                document.getElementById('partialAmortizationSection').style.display = 'none';
                
                // Hide results
                document.getElementById('bondResultsSection').style.display = 'none';
                
                // Reset dates to defaults
                this.setDefaultBondDates();
                
                this.showSuccess('Bond calculator form cleared');
            }

            calculateBondMetrics() {
                try {
                    // Validate required fields
                    const requiredFields = [
                        'bondCompany', 'bondCoupon', 'bondIssueDate', 'bondMaturityDate',
                        'bondInvestmentAmount', 'bondLiquidationDate', 'bondInitialPrice', 'bondActualPrice'
                    ];
                    
                    for (const fieldId of requiredFields) {
                        const field = document.getElementById(fieldId);
                        if (!field.value) {
                            this.showError(`Please fill in the ${fieldId.replace('bond', '').toLowerCase()} field`);
                            return;
                        }
                    }
                    
                    // Validate amortization schedule if partial amortization is selected
                    const bondType = document.getElementById('bondType').value;
                    if (bondType === 'partial') {
                        const entries = document.querySelectorAll('.amortization-entry');
                        let totalAmortization = 0;
                        
                        for (const entry of entries) {
                            const percentage = parseFloat(entry.querySelector('.amortization-percentage').value);
                            if (!isNaN(percentage)) {
                                totalAmortization += percentage;
                            }
                        }
                        
                        if (totalAmortization > 100) {
                            this.showError('Total amortization percentage cannot exceed 100%');
                            return;
                        }
                        
                        if (totalAmortization === 0) {
                            this.showError('Please add at least one amortization entry for partial amortization bonds');
                            return;
                        }
                    }
                    
                    // Get form values
                    const bondData = this.getBondFormData();
                    
                    // Calculate bond metrics
                    const metrics = this.performBondCalculations(bondData);
                    
                    // Display results
                    this.displayBondResults(metrics, bondData);
                    
                } catch (error) {
                    console.error('Error calculating bond metrics:', error);
                    this.showError('Error calculating bond metrics: ' + error.message);
                }
            }

            getBondFormData() {
                const bondType = document.getElementById('bondType').value;
                const amortizationSchedule = [];
                
                if (bondType === 'partial') {
                    const entries = document.querySelectorAll('.amortization-entry');
                    entries.forEach(entry => {
                        const date = entry.querySelector('.amortization-date').value;
                        const percentage = parseFloat(entry.querySelector('.amortization-percentage').value);
                        
                        if (date && !isNaN(percentage)) {
                            amortizationSchedule.push({
                                date: new Date(date),
                                percentage: percentage / 100
                            });
                        }
                    });
                }
                
                return {
                    company: document.getElementById('bondCompany').value,
                    coupon: parseFloat(document.getElementById('bondCoupon').value) / 100,
                    issueDate: new Date(document.getElementById('bondIssueDate').value),
                    maturityDate: new Date(document.getElementById('bondMaturityDate').value),
                    frequency: document.getElementById('bondFrequency').value,
                    type: bondType,
                    investmentAmount: parseFloat(document.getElementById('bondInvestmentAmount').value),
                    liquidationDate: new Date(document.getElementById('bondLiquidationDate').value),
                    initialPrice: parseFloat(document.getElementById('bondInitialPrice').value) / 100,
                    actualPrice: parseFloat(document.getElementById('bondActualPrice').value) / 100,
                    amortizationSchedule: amortizationSchedule
                };
            }

            performBondCalculations(bondData) {
                // Calculate days between liquidation and maturity (30/360 convention)
                const daysToMaturity = this.calculateDays360(bondData.liquidationDate, bondData.maturityDate);
                const yearsToMaturity = daysToMaturity / 360;
                
                // Calculate coupon payments per year
                const paymentsPerYear = this.getPaymentsPerYear(bondData.frequency);
                const couponPayment = bondData.coupon / paymentsPerYear;
                
                // Calculate YTM (Yield to Maturity) using Newton-Raphson method
                const ytm = this.calculateYTM(bondData, yearsToMaturity, paymentsPerYear);
                
                // Calculate Macaulay Duration
                const macaulayDuration = this.calculateMacaulayDuration(bondData, ytm, yearsToMaturity, paymentsPerYear);
                
                // Calculate Modified Duration
                const modifiedDuration = this.calculateModifiedDuration(bondData, ytm, yearsToMaturity, paymentsPerYear);
                
                // Calculate Convexity
                const convexity = this.calculateConvexity(bondData, ytm, yearsToMaturity, paymentsPerYear);
                
                // Calculate Price Change
                const priceChange = this.calculatePriceChange(bondData);
                
                // Calculate Total Return
                const totalReturn = this.calculateTotalReturn(bondData, ytm, yearsToMaturity);
                
                // Calculate Current Yield
                const currentYield = this.calculateCurrentYield(bondData);
                
                // Calculate Parity
                const parity = this.calculateParity(bondData, ytm, yearsToMaturity, paymentsPerYear);
                
                return {
                    ytm: ytm,
                    macaulayDuration: macaulayDuration,
                    modifiedDuration: modifiedDuration,
                    convexity: convexity,
                    priceChange: priceChange,
                    totalReturn: totalReturn,
                    currentYield: currentYield,
                    parity: parity,
                    daysToMaturity: daysToMaturity,
                    yearsToMaturity: yearsToMaturity,
                    couponPayment: couponPayment,
                    paymentsPerYear: paymentsPerYear
                };
            }

            calculateDays360(startDate, endDate) {
                const start = new Date(startDate);
                const end = new Date(endDate);
                
                const startYear = start.getFullYear();
                const startMonth = start.getMonth();
                const startDay = start.getDate();
                
                const endYear = end.getFullYear();
                const endMonth = end.getMonth();
                const endDay = end.getDate();
                
                // 30/360 convention
                const startDay360 = Math.min(startDay, 30);
                const endDay360 = Math.min(endDay, 30);
                
                return (endYear - startYear) * 360 + (endMonth - startMonth) * 30 + (endDay360 - startDay360);
            }

            getPaymentsPerYear(frequency) {
                switch (frequency) {
                    case 'quarterly': return 4;
                    case 'semiannual': return 2;
                    case 'annual': return 1;
                    default: return 2;
                }
            }

            calculateYTM(bondData, yearsToMaturity, paymentsPerYear) {
                // YTM calculation using TIR.NO.PER method (Excel's XIRR equivalent)
                const cashFlows = this.generateBondCashFlows(bondData, yearsToMaturity, paymentsPerYear);
                const dates = this.generateBondCashFlowDates(bondData, yearsToMaturity, paymentsPerYear);
                
                // Debug: Log cash flows and bond data
                console.log('Bond Data:', {
                    coupon: bondData.coupon,
                    couponPercent: bondData.coupon * 100 + '%',
                    actualPrice: bondData.actualPrice,
                    actualPricePercent: bondData.actualPrice * 100 + '%',
                    yearsToMaturity: yearsToMaturity,
                    paymentsPerYear: paymentsPerYear,
                    issueDate: bondData.issueDate,
                    maturityDate: bondData.maturityDate,
                    liquidationDate: bondData.liquidationDate
                });
                console.log('Cash Flows:', cashFlows);
                console.log('Cash Flow Dates:', dates);
                
                // Better initial guess based on bond price vs face value
                let initialGuess = 0.05; // Default 5%
                if (bondData.actualPrice > 1) {
                    // Bond trading at premium, YTM < coupon rate
                    initialGuess = bondData.coupon * 0.8; // Start below coupon rate
                } else if (bondData.actualPrice < 1) {
                    // Bond trading at discount, YTM > coupon rate
                    initialGuess = bondData.coupon * 1.2; // Start above coupon rate
                } else {
                    // Bond trading at par, YTM ≈ coupon rate
                    initialGuess = bondData.coupon;
                }
                
                const ytm = this.calculateXIRR(cashFlows, dates, initialGuess);
                console.log('TIR.NO.PER YTM:', ytm * 100 + '%');
                
                return ytm;
            }

            generateBondCashFlows(bondData, yearsToMaturity, paymentsPerYear) {
                const cashFlows = [];
                const periodsToMaturity = Math.ceil(yearsToMaturity * paymentsPerYear);
                const couponPayment = bondData.coupon / paymentsPerYear;
                
                // Calculate dirty price for initial investment (TIR.NO.PER uses dirty price)
                const dirtyPrice = this.calculateDirtyPrice(bondData);
                
                // Initial investment (negative cash flow) - using dirty price as per TIR.NO.PER
                cashFlows.push(-dirtyPrice);
                
                // Get actual coupon payment dates
                const futureCouponDates = this.getFutureCouponDates(bondData.issueDate, bondData.frequency, bondData.liquidationDate, periodsToMaturity);
                
                // Create a map of amortization payments by date
                const amortizationPayments = new Map();
                if (bondData.amortizationSchedule && bondData.amortizationSchedule.length > 0) {
                    bondData.amortizationSchedule.forEach(amort => {
                        const dateKey = amort.date.toISOString().split('T')[0];
                        amortizationPayments.set(dateKey, amort.percentage);
                    });
                }
                
                // Add coupon payments and amortization on actual dates
                for (let i = 0; i < futureCouponDates.length; i++) {
                    const isLastPayment = i === futureCouponDates.length - 1;
                    let payment = couponPayment;
                    
                    // Check if there's amortization on this date
                    const currentDate = new Date(futureCouponDates[i]);
                    const dateKey = currentDate.toISOString().split('T')[0];
                    const amortizationPercentage = amortizationPayments.get(dateKey) || 0;
                    
                    // Add amortization payment
                    if (amortizationPercentage > 0) {
                        payment += amortizationPercentage;
                    }
                    
                    // Add remaining principal repayment on maturity date (if no amortization or partial amortization)
                    if (isLastPayment) {
                        const totalAmortized = Array.from(amortizationPayments.values()).reduce((sum, pct) => sum + pct, 0);
                        const remainingPrincipal = 1 - totalAmortized;
                        payment += remainingPrincipal;
                    }
                    
                    cashFlows.push(payment);
                }
                
                console.log('TIR.NO.PER Cash Flow Details:', {
                    dirtyPrice: dirtyPrice,
                    couponPayment: couponPayment,
                    periodsToMaturity: periodsToMaturity,
                    totalCashFlows: cashFlows.length,
                    futureCouponDates: futureCouponDates.length,
                    finalPayment: cashFlows[cashFlows.length - 1],
                    amortizationSchedule: bondData.amortizationSchedule,
                    amortizationPayments: Array.from(amortizationPayments.entries())
                });
                
                return cashFlows;
            }

            generateBondCashFlowDates(bondData, yearsToMaturity, paymentsPerYear) {
                const dates = [];
                const periodsToMaturity = Math.ceil(yearsToMaturity * paymentsPerYear);
                
                // Initial investment date (liquidation date)
                dates.push(new Date(bondData.liquidationDate));
                
                // Get actual coupon payment dates
                const futureCouponDates = this.getFutureCouponDates(bondData.issueDate, bondData.frequency, bondData.liquidationDate, periodsToMaturity);
                
                // Add coupon payment dates
                for (let i = 0; i < futureCouponDates.length; i++) {
                    dates.push(new Date(futureCouponDates[i]));
                }
                
                return dates;
            }

            generateFutureCashFlows(bondData, yearsToMaturity, paymentsPerYear) {
                const cashFlows = [];
                const periodsToMaturity = Math.ceil(yearsToMaturity * paymentsPerYear);
                const couponPayment = bondData.coupon / paymentsPerYear;
                
                // Get actual coupon payment dates
                const futureCouponDates = this.getFutureCouponDates(bondData.issueDate, bondData.frequency, bondData.liquidationDate, periodsToMaturity);
                
                // Create a map of amortization payments by date
                const amortizationPayments = new Map();
                if (bondData.amortizationSchedule && bondData.amortizationSchedule.length > 0) {
                    bondData.amortizationSchedule.forEach(amort => {
                        const dateKey = amort.date.toISOString().split('T')[0];
                        amortizationPayments.set(dateKey, amort.percentage);
                    });
                }
                
                // Add coupon payments and amortization on actual dates (no initial investment)
                for (let i = 0; i < futureCouponDates.length; i++) {
                    const isLastPayment = i === futureCouponDates.length - 1;
                    let payment = couponPayment;
                    
                    // Check if there's amortization on this date
                    const currentDate = new Date(futureCouponDates[i]);
                    const dateKey = currentDate.toISOString().split('T')[0];
                    const amortizationPercentage = amortizationPayments.get(dateKey) || 0;
                    
                    // Add amortization payment
                    if (amortizationPercentage > 0) {
                        payment += amortizationPercentage;
                    }
                    
                    // Add remaining principal repayment on maturity date (if no amortization or partial amortization)
                    if (isLastPayment) {
                        const totalAmortized = Array.from(amortizationPayments.values()).reduce((sum, pct) => sum + pct, 0);
                        const remainingPrincipal = 1 - totalAmortized;
                        payment += remainingPrincipal;
                    }
                    
                    cashFlows.push(payment);
                }
                
                return cashFlows;
            }

            generateFutureCashFlowDates(bondData, yearsToMaturity, paymentsPerYear) {
                const dates = [];
                const periodsToMaturity = Math.ceil(yearsToMaturity * paymentsPerYear);
                
                // Get actual coupon payment dates (no initial investment date)
                const futureCouponDates = this.getFutureCouponDates(bondData.issueDate, bondData.frequency, bondData.liquidationDate, periodsToMaturity);
                
                // Add coupon payment dates
                for (let i = 0; i < futureCouponDates.length; i++) {
                    dates.push(new Date(futureCouponDates[i]));
                }
                
                return dates;
            }

            calculateIRR(cashFlows, guess = 0.1) {
                // IRR calculation using Newton-Raphson method (similar to Excel's IRR function)
                let rate = guess;
                const tolerance = 0.0000001;
                const maxIterations = 100;
                
                // Try multiple initial guesses to avoid local minima
                const guesses = [guess, guess * 0.5, guess * 1.5, 0.05, 0.1, 0.15];
                let bestRate = guess;
                let bestNPV = Math.abs(this.calculateNPV(cashFlows, guess));
                
                for (let g = 0; g < guesses.length; g++) {
                    let currentRate = guesses[g];
                    
                    for (let i = 0; i < maxIterations; i++) {
                        const npv = this.calculateNPV(cashFlows, currentRate);
                        const derivative = this.calculateNPVDerivative(cashFlows, currentRate);
                        
                        if (Math.abs(derivative) < 1e-10) {
                            break; // Avoid division by zero
                        }
                        
                        const newRate = currentRate - npv / derivative;
                        
                        // Ensure rate stays reasonable (between -50% and 200%)
                        if (newRate < -0.5 || newRate > 2.0) {
                            break;
                        }
                        
                        if (Math.abs(newRate - currentRate) < tolerance) {
                            const currentNPV = Math.abs(this.calculateNPV(cashFlows, newRate));
                            if (currentNPV < bestNPV) {
                                bestNPV = currentNPV;
                                bestRate = newRate;
                            }
                            break;
                        }
                        
                        currentRate = newRate;
                    }
                }
                
                return bestRate;
            }

            calculateNPV(cashFlows, rate) {
                let npv = 0;
                for (let i = 0; i < cashFlows.length; i++) {
                    npv += cashFlows[i] / Math.pow(1 + rate, i);
                }
                return npv;
            }

            calculateNPVDerivative(cashFlows, rate) {
                let derivative = 0;
                for (let i = 1; i < cashFlows.length; i++) {
                    derivative -= (i * cashFlows[i]) / Math.pow(1 + rate, i + 1);
                }
                return derivative;
            }

            calculateSimpleYTM(bondData, yearsToMaturity, paymentsPerYear) {
                // Simple YTM approximation: (Annual Coupon + (Face Value - Price) / Years) / ((Face Value + Price) / 2)
                const annualCoupon = bondData.coupon;
                const faceValue = 1; // 100% = 1
                const price = bondData.actualPrice;
                const years = yearsToMaturity;
                
                const numerator = annualCoupon + (faceValue - price) / years;
                const denominator = (faceValue + price) / 2;
                
                return numerator / denominator;
            }

            calculateXIRR(cashFlows, dates, guess = 0.1) {
                // XIRR calculation (equivalent to Excel's TIR.NO.PER)
                let rate = guess;
                const tolerance = 0.0000001;
                const maxIterations = 100;
                
                // Try multiple initial guesses to avoid local minima
                const guesses = [guess, guess * 0.5, guess * 1.5, 0.05, 0.1, 0.15];
                let bestRate = guess;
                let bestNPV = Math.abs(this.calculateXNPV(cashFlows, dates, guess));
                
                for (let g = 0; g < guesses.length; g++) {
                    let currentRate = guesses[g];
                    
                    for (let i = 0; i < maxIterations; i++) {
                        const npv = this.calculateXNPV(cashFlows, dates, currentRate);
                        const derivative = this.calculateXNPVDerivative(cashFlows, dates, currentRate);
                        
                        if (Math.abs(derivative) < 1e-10) {
                            break; // Avoid division by zero
                        }
                        
                        const newRate = currentRate - npv / derivative;
                        
                        // Ensure rate stays reasonable (between -50% and 200%)
                        if (newRate < -0.5 || newRate > 2.0) {
                            break;
                        }
                        
                        if (Math.abs(newRate - currentRate) < tolerance) {
                            const currentNPV = Math.abs(this.calculateXNPV(cashFlows, dates, newRate));
                            if (currentNPV < bestNPV) {
                                bestNPV = currentNPV;
                                bestRate = newRate;
                            }
                            break;
                        }
                        
                        currentRate = newRate;
                    }
                }
                
                return bestRate;
            }

            calculateXNPV(cashFlows, dates, rate) {
                let npv = 0;
                const startDate = dates[0];
                
                for (let i = 0; i < cashFlows.length; i++) {
                    const daysDiff = (dates[i] - startDate) / (1000 * 60 * 60 * 24); // Convert to days
                    const yearsDiff = daysDiff / 365; // Convert to years
                    npv += cashFlows[i] / Math.pow(1 + rate, yearsDiff);
                }
                
                return npv;
            }

            calculateXNPVDerivative(cashFlows, dates, rate) {
                let derivative = 0;
                const startDate = dates[0];
                
                for (let i = 1; i < cashFlows.length; i++) {
                    const daysDiff = (dates[i] - startDate) / (1000 * 60 * 60 * 24); // Convert to days
                    const yearsDiff = daysDiff / 365; // Convert to years
                    derivative -= (yearsDiff * cashFlows[i]) / Math.pow(1 + rate, yearsDiff + 1);
                }
                
                return derivative;
            }



            calculateMacaulayDuration(bondData, ytm, yearsToMaturity, paymentsPerYear) {
                const couponPayment = bondData.coupon / paymentsPerYear;
                const periodsToMaturity = yearsToMaturity * paymentsPerYear;
                const ratePerPeriod = ytm / paymentsPerYear;
                
                let duration = 0;
                let price = 0;
                
                // Get future cash flow dates and amounts
                const futureCashFlows = this.generateFutureCashFlows(bondData, yearsToMaturity, paymentsPerYear);
                const futureDates = this.generateFutureCashFlowDates(bondData, yearsToMaturity, paymentsPerYear);
                
                // Calculate duration using actual cash flows (including amortization)
                for (let i = 0; i < futureCashFlows.length; i++) {
                    const cashFlow = futureCashFlows[i];
                    const paymentDate = new Date(futureDates[i]);
                    const liquidationDate = new Date(bondData.liquidationDate);
                    
                    // Calculate time to payment in years
                    const timeToPayment = this.calculateDays360(liquidationDate, paymentDate) / 360;
                    
                    // Calculate present value of this cash flow
                    const pv = cashFlow / Math.pow(1 + ytm, timeToPayment);
                    
                    // Add to duration calculation
                    duration += timeToPayment * pv;
                    price += pv;
                }
                
                // Use dirty price instead of clean price for accurate duration calculation
                const dirtyPrice = this.calculateDirtyPrice(bondData);
                return duration / dirtyPrice;
            }

            calculateModifiedDuration(bondData, ytm, yearsToMaturity, paymentsPerYear) {
                // Modified Duration = Macaulay Duration / (1 + YTM/paymentsPerYear)
                const macaulayDuration = this.calculateMacaulayDuration(bondData, ytm, yearsToMaturity, paymentsPerYear);
                const ratePerPeriod = ytm / paymentsPerYear;
                
                return macaulayDuration / (1 + ratePerPeriod);
            }

            calculateConvexity(bondData, ytm, yearsToMaturity, paymentsPerYear) {
                let convexity = 0;
                let price = 0;
                
                // Get future cash flow dates and amounts
                const futureCashFlows = this.generateFutureCashFlows(bondData, yearsToMaturity, paymentsPerYear);
                const futureDates = this.generateFutureCashFlowDates(bondData, yearsToMaturity, paymentsPerYear);
                
                // Calculate convexity using actual cash flows (including amortization)
                for (let i = 0; i < futureCashFlows.length; i++) {
                    const cashFlow = futureCashFlows[i];
                    const paymentDate = new Date(futureDates[i]);
                    const liquidationDate = new Date(bondData.liquidationDate);
                    
                    // Calculate time to payment in years
                    const timeToPayment = this.calculateDays360(liquidationDate, paymentDate) / 360;
                    
                    // Calculate present value of this cash flow
                    const pv = cashFlow / Math.pow(1 + ytm, timeToPayment);
                    
                    // Add to convexity calculation
                    convexity += timeToPayment * (timeToPayment + 1) * pv / Math.pow(1 + ytm, 2);
                    price += pv;
                }
                
                // Use dirty price instead of clean price for accurate convexity calculation
                const dirtyPrice = this.calculateDirtyPrice(bondData);
                return convexity / (dirtyPrice * Math.pow(1 + ytm, 2));
            }

            calculatePriceChange(bondData) {
                return ((bondData.actualPrice - bondData.initialPrice) / bondData.initialPrice) * 100;
            }

            calculateTotalReturn(bondData, ytm, yearsToMaturity) {
                const couponIncome = bondData.coupon * yearsToMaturity;
                const priceAppreciation = (bondData.actualPrice - bondData.initialPrice) / bondData.initialPrice;
                return (couponIncome + priceAppreciation) * 100;
            }

            calculateAccruedInterest(bondData, liquidationDate) {
                // Calculate accrued interest from last coupon date to liquidation date
                const lastCouponDate = this.getLastCouponDate(bondData.issueDate, bondData.frequency, liquidationDate);
                const daysSinceLastCoupon = this.calculateDays360(lastCouponDate, liquidationDate);
                
                // Accrued Interest = (Coupon Rate / 360) × Days Since Last Coupon
                const accruedInterest = (bondData.coupon / 360) * daysSinceLastCoupon;
                return accruedInterest; // Return as percentage
            }

            getLastCouponDate(issueDate, frequency, currentDate) {
                const issue = new Date(issueDate);
                const current = new Date(currentDate);
                const paymentsPerYear = this.getPaymentsPerYear(frequency);
                const monthsBetweenPayments = 12 / paymentsPerYear;
                
                let lastCoupon = new Date(issue);
                
                while (lastCoupon <= current) {
                    lastCoupon.setMonth(lastCoupon.getMonth() + monthsBetweenPayments);
                }
                
                // Go back one payment period
                lastCoupon.setMonth(lastCoupon.getMonth() - monthsBetweenPayments);
                
                return lastCoupon;
            }

            getDaysInPeriod(frequency) {
                switch (frequency) {
                    case 'quarterly': return 90;
                    case 'semiannual': return 180;
                    case 'annual': return 360;
                    default: return 180;
                }
            }

            calculateDirtyPrice(bondData) {
                // Dirty Price = Clean Price + Accrued Interest
                const accruedInterest = this.calculateAccruedInterest(bondData, bondData.liquidationDate);
                return bondData.actualPrice + accruedInterest;
            }

            calculateCurrentYield(bondData) {
                // Current Yield = Annual Coupon Payment / Clean Price
                // Clean Price is the bond price without accrued interest
                return (bondData.coupon / bondData.actualPrice) * 100;
            }

            calculateParity(bondData, ytm, yearsToMaturity, paymentsPerYear) {
                // Parity = Dirty Price / Technical Price
                const dirtyPrice = this.calculateDirtyPrice(bondData);
                const technicalPrice = this.calculateTechnicalPrice(bondData, ytm, yearsToMaturity, paymentsPerYear);
                return dirtyPrice / technicalPrice;
            }

            calculateTechnicalPrice(bondData, ytm, yearsToMaturity, paymentsPerYear) {
                // Technical Price = Present value of all cash flows discounted at YTM
                const couponPayment = bondData.coupon / paymentsPerYear;
                const periodsToMaturity = yearsToMaturity * paymentsPerYear;
                const ratePerPeriod = ytm / paymentsPerYear;
                
                let technicalPrice = 0;
                
                // Present value of coupon payments
                for (let i = 1; i <= periodsToMaturity; i++) {
                    technicalPrice += couponPayment / Math.pow(1 + ratePerPeriod, i);
                }
                
                // Present value of face value
                technicalPrice += 1 / Math.pow(1 + ratePerPeriod, periodsToMaturity);
                
                return technicalPrice;
            }

            generateCashFlowTable(bondData, ytm, yearsToMaturity, paymentsPerYear) {
                const dirtyPrice = this.calculateDirtyPrice(bondData);
                const couponPayment = bondData.coupon / paymentsPerYear;
                const periodsToMaturity = Math.ceil(yearsToMaturity * paymentsPerYear);
                
                // Get future coupon dates
                const futureCouponDates = this.getFutureCouponDates(bondData.issueDate, bondData.frequency, bondData.liquidationDate, periodsToMaturity);
                
                // Prepare data for chart
                const chartData = this.prepareCashFlowChartData(bondData, futureCouponDates, dirtyPrice, couponPayment);
                
                let html = `
                    <div style="margin-bottom: 20px;">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;">
                            <h5 style="margin: 0; font-size: 16px; color: #333;">Cash Flow Visualization</h5>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <button class="cashflow-nav-btn" onclick="portfolio.switchCashFlowView(0)" style="background: #007bff; color: white; border: none; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: background-color 0.2s;">
                                    <i class="fas fa-table"></i>
                                </button>
                                <button class="cashflow-nav-btn" onclick="portfolio.switchCashFlowView(1)" style="background: #ccc; color: white; border: none; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: background-color 0.2s;">
                                    <i class="fas fa-chart-bar"></i>
                                </button>
                                <span class="cashflow-nav-indicator" style="font-size: 14px; color: #666; min-width: 80px; text-align: center;">Table View</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Table View -->
                    <div id="cashflow-table-view" style="display: block;">
                        <table style="width: 100%; border-collapse: collapse; font-size: 14px;">
                            <thead>
                                <tr style="background: linear-gradient(135deg, #667eea, #764ba2); color: white;">
                                    <th style="padding: 12px; text-align: center; border-radius: 8px 0 0 0; font-weight: 600;">Date</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Coupon Payment</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Principal</th>
                                    <th style="padding: 12px; text-align: center; border-radius: 0 8px 0 0; font-weight: 600;">Total Payment</th>
                                </tr>
                            </thead>
                            <tbody>
                                <!-- Liquidation Date Row -->
                                <tr style="background: #f8f9fa; border-bottom: 2px solid #e1e5e9;">
                                    <td style="padding: 12px; text-align: center; font-weight: 600; color: #333;">
                                        ${new Date(bondData.liquidationDate).toLocaleDateString()}
                                    </td>
                                    <td style="padding: 12px; text-align: center;">-</td>
                                    <td style="padding: 12px; text-align: center;">-</td>
                                    <td style="padding: 12px; text-align: center; font-weight: 600; color: #ff6b6b;">
                                        -${(dirtyPrice * 100).toFixed(2)}%
                                    </td>
                                </tr>
                `;
                
                // Create a map of amortization payments by date
                const amortizationPayments = new Map();
                if (bondData.amortizationSchedule && bondData.amortizationSchedule.length > 0) {
                    bondData.amortizationSchedule.forEach(amort => {
                        const dateKey = amort.date.toISOString().split('T')[0];
                        amortizationPayments.set(dateKey, amort.percentage);
                    });
                }
                
                // Add future coupon payments
                let totalCouponPayments = 0;
                let totalPrincipal = 0;
                
                for (let i = 0; i < futureCouponDates.length; i++) {
                    const isLastPayment = i === futureCouponDates.length - 1;
                    const couponAmount = couponPayment * 100; // Convert to percentage
                    
                    // Check if there's amortization on this date
                    const currentDate = new Date(futureCouponDates[i]);
                    const dateKey = currentDate.toISOString().split('T')[0];
                    const amortizationPercentage = amortizationPayments.get(dateKey) || 0;
                    
                    // Calculate principal amount
                    let principalAmount = 0;
                    if (amortizationPercentage > 0) {
                        principalAmount = amortizationPercentage * 100; // Convert to percentage
                    } else if (isLastPayment) {
                        // Add remaining principal repayment on maturity date
                        const totalAmortized = Array.from(amortizationPayments.values()).reduce((sum, pct) => sum + pct, 0);
                        const remainingPrincipal = 1 - totalAmortized;
                        principalAmount = remainingPrincipal * 100;
                    }
                    
                    const totalPayment = couponAmount + principalAmount;
                    
                    totalCouponPayments += couponAmount;
                    totalPrincipal += principalAmount;
                    
                    html += `
                        <tr style="border-bottom: 1px solid #e1e5e9;">
                            <td style="padding: 12px; text-align: center; font-weight: 500; color: #333;">
                                ${futureCouponDates[i].toLocaleDateString()}
                            </td>
                            <td style="padding: 12px; text-align: center; font-weight: 600; color: #667eea;">
                                ${couponAmount.toFixed(2)}%
                            </td>
                            <td style="padding: 12px; text-align: center; font-weight: 600; color: #2ed573;">
                                ${principalAmount.toFixed(2)}%
                            </td>
                            <td style="padding: 12px; text-align: center; font-weight: 600; color: #9c27b0;">
                                ${totalPayment.toFixed(2)}%
                            </td>
                        </tr>
                    `;
                }
                
                // Add totals row
                const grandTotal = totalCouponPayments + totalPrincipal - (dirtyPrice * 100);
                
                html += `
                            <tr style="background: linear-gradient(135deg, #667eea, #764ba2); color: white; font-weight: 600;">
                                <td style="padding: 12px; text-align: center; border-radius: 0 0 0 8px;">
                                    <strong>TOTAL</strong>
                                </td>
                                <td style="padding: 12px; text-align: center;">
                                    ${totalCouponPayments.toFixed(2)}%
                                </td>
                                <td style="padding: 12px; text-align: center;">
                                    ${totalPrincipal.toFixed(2)}%
                                </td>
                                <td style="padding: 12px; text-align: center; border-radius: 0 0 8px 0;">
                                    ${grandTotal.toFixed(2)}%
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    </div>
                    
                    <!-- Chart View -->
                    <div id="cashflow-chart-view" style="display: none;">
                        <div id="cashflow-chart-container" style="width: 100%; height: 400px; border: 1px solid #e1e5e9; border-radius: 8px; background: white; display: flex; align-items: center; justify-content: center;">
                            <div style="text-align: center; color: #666;">
                                <i class="fas fa-chart-bar" style="font-size: 2rem; margin-bottom: 10px;"></i>
                                <p>Loading chart...</p>
                            </div>
                        </div>
                    </div>
                `;
                
                // Store chart data for later use
                this.cashFlowChartData = chartData;
                
                return html;
            }

            prepareCashFlowChartData(bondData, futureCouponDates, dirtyPrice, couponPayment) {
                const chartData = {
                    dates: [],
                    couponPayments: [],
                    principalPayments: [],
                    totalPayments: [],
                    isPartialAmortization: false
                };
                
                // Create a map of amortization payments by date
                const amortizationPayments = new Map();
                if (bondData.amortizationSchedule && bondData.amortizationSchedule.length > 0) {
                    chartData.isPartialAmortization = true;
                    bondData.amortizationSchedule.forEach(amort => {
                        const dateKey = amort.date.toISOString().split('T')[0];
                        amortizationPayments.set(dateKey, amort.percentage);
                    });
                }
                
                // Add future payments (skip initial investment for chart)
                for (let i = 0; i < futureCouponDates.length; i++) {
                    const isLastPayment = i === futureCouponDates.length - 1;
                    const couponAmount = couponPayment * 100;
                    
                    // Check if there's amortization on this date
                    const currentDate = new Date(futureCouponDates[i]);
                    const dateKey = currentDate.toISOString().split('T')[0];
                    
                    // More flexible date matching - check if any amortization date is within 1 day
                    let amortizationPercentage = 0;
                    for (const [amortDateKey, percentage] of amortizationPayments.entries()) {
                        const amortDate = new Date(amortDateKey);
                        const daysDiff = Math.abs((currentDate - amortDate) / (1000 * 60 * 60 * 24));
                        if (daysDiff <= 1) { // Within 1 day
                            amortizationPercentage = percentage;
                            console.log(`Found amortization match: ${dateKey} matches ${amortDateKey} with ${percentage * 100}%`);
                            break;
                        }
                    }
                    
                    // Calculate principal amount
                    let principalAmount = 0;
                    if (amortizationPercentage > 0) {
                        principalAmount = amortizationPercentage * 100; // Convert to percentage
                    } else if (isLastPayment) {
                        // Add remaining principal repayment on maturity date
                        const totalAmortized = Array.from(amortizationPayments.values()).reduce((sum, pct) => sum + pct, 0);
                        const remainingPrincipal = 1 - totalAmortized;
                        principalAmount = remainingPrincipal * 100;
                    }
                    
                    const totalPayment = couponAmount + principalAmount;
                    
                    chartData.dates.push(futureCouponDates[i].toLocaleDateString());
                    chartData.couponPayments.push(couponAmount);
                    chartData.principalPayments.push(principalAmount);
                    chartData.totalPayments.push(totalPayment);
                }
                
                console.log('Chart data prepared:', chartData); // Debug log
                return chartData;
            }

            switchCashFlowView(viewIndex) {
                const tableView = document.getElementById('cashflow-table-view');
                const chartView = document.getElementById('cashflow-chart-view');
                const navButtons = document.querySelectorAll('.cashflow-nav-btn');
                const indicator = document.querySelector('.cashflow-nav-indicator');
                
                if (viewIndex === 0) {
                    // Table view
                    tableView.style.display = 'block';
                    chartView.style.display = 'none';
                    navButtons[0].style.background = '#007bff';
                    navButtons[1].style.background = '#ccc';
                    indicator.textContent = 'Table View';
                } else {
                    // Chart view
                    tableView.style.display = 'none';
                    chartView.style.display = 'block';
                    navButtons[0].style.background = '#ccc';
                    navButtons[1].style.background = '#007bff';
                    indicator.textContent = 'Chart View';
                    
                    // Generate chart if data exists
                    if (this.cashFlowChartData) {
                        this.renderCashFlowChart();
                    }
                }
            }

            renderCashFlowChart() {
                if (!this.cashFlowChartData) return;
                
                const container = document.getElementById('cashflow-chart-container');
                container.innerHTML = '';
                
                // Create fintech-style bar plot
                const canvas = document.createElement('canvas');
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                canvas.style.width = '100%';
                canvas.style.height = '100%';
                container.appendChild(canvas);
                
                // Simple animation - just draw the chart with animation
                let progress = 0;
                const animate = () => {
                    progress += 0.02;
                    if (progress > 1) progress = 1;
                    
                    try {
                        this.drawChartFrame(canvas, progress);
                    } catch (error) {
                        console.warn('Animation error, falling back to static chart:', error);
                        this.drawChartFrame(canvas, 1); // Draw static chart
                        return;
                    }
                    
                    if (progress < 1) {
                        setTimeout(animate, 30); // 30ms delay for smooth animation
                    }
                };
                
                animate();
            }
            
            drawChartFrame(canvas, animationProgress) {
                
                const ctx = canvas.getContext('2d');
                const data = this.cashFlowChartData;
                
                // Safety check for valid data
                if (!data || !data.dates || !data.couponPayments || !data.principalPayments) {
                    return;
                }
                
                // Modern fintech gradient colors
                const colors = {
                    coupon: '#4f46e5',      // Modern indigo
                    principal: '#7c3aed',   // Modern violet
                    grid: '#f1f5f9',        // Slate gray grid
                    text: '#1e293b',        // Slate dark text
                    background: '#ffffff',  // White background
                    shadow: 'rgba(0, 0, 0, 0.1)' // Subtle shadow
                };
                
                // Chart dimensions - adjusted for horizontal dates
                const margin = { top: 40, right: 30, bottom: 100, left: 80 };
                const width = canvas.width - margin.left - margin.right;
                const height = canvas.height - margin.top - margin.bottom;
                
                // Clear canvas with modern background
                ctx.fillStyle = colors.background;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Add subtle background gradient
                const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                bgGradient.addColorStop(0, '#fafafa');
                bgGradient.addColorStop(1, '#ffffff');
                ctx.fillStyle = bgGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Find data ranges - exclude initial investment
                const positivePayments = data.totalPayments.filter(payment => payment > 0);
                const maxValue = Math.max(...positivePayments) || 0;

                // Axis maximum rounded to nearest 10% and not less than 10%
                const yMax = Math.max(10, Math.ceil(maxValue / 10) * 10);
                const intervals = Math.max(1, Math.ceil(yMax / 10));
                
                // Scales - adjust for proper spacing with padding on both sides
                const xScale = (width - 100) / Math.max(data.dates.length - 1, 1); // Leave 50px padding on each side
                const yScale = height / yMax;
                
                // Draw modern grid
                ctx.strokeStyle = colors.grid;
                ctx.lineWidth = 0.5;
                ctx.setLineDash([3, 3]);
                
                // Horizontal grid lines - 10% scale
                for (let i = 0; i <= intervals; i++) {
                    const y = margin.top + (height / intervals) * i;
                    ctx.beginPath();
                    ctx.moveTo(margin.left, y);
                    ctx.lineTo(margin.left + width, y);
                    ctx.stroke();
                }
                
                // Vertical grid lines
                for (let i = 0; i < data.dates.length; i++) {
                    const x = margin.left + 50 + i * xScale;
                    ctx.beginPath();
                    ctx.moveTo(x, margin.top);
                    ctx.lineTo(x, margin.top + height);
                    ctx.stroke();
                }
                
                ctx.setLineDash([]);
                
                // Draw bars with modern fintech gradients
                const barWidth = Math.min(40, xScale * 0.7); // Cap width for very few bars to preserve scale perception
                
                for (let i = 0; i < data.dates.length; i++) {
                    const x = margin.left + 50 + i * xScale - barWidth / 2; // Centered with 50px padding on each side
                    
                    // Skip initial investment (negative values)
                    if (data.totalPayments[i] <= 0) continue;
                    
                    // Debug log for first few bars
                    if (i < 3) {
                        console.log(`Bar ${i}: Coupon=${data.couponPayments[i]}, Principal=${data.principalPayments[i]}, Total=${data.totalPayments[i]}`);
                    }
                    
                    // Bounded stagger so the last bar always animates
                    const clamp = (v, min = 0, max = 1) => Math.min(max, Math.max(min, v));
                    const numBars = Math.max(data.dates.length, 1);
                    const maxStagger = 0.6; // portion of the animation window reserved for staggering
                    const perBarDelay = numBars > 1 ? maxStagger / (numBars - 1) : 0;
                    const barDelay = i * perBarDelay;
                    // Stage principal slightly after coupon for stacked feel
                    const denomCoupon = Math.max(0.0001, 1 - barDelay);
                    const denomPrincipal = Math.max(0.0001, 1 - (barDelay + 0.08));
                    const couponProgress = clamp((animationProgress - barDelay) / denomCoupon);
                    const principalProgress = clamp((animationProgress - barDelay - 0.08) / denomPrincipal);
                    
                    // Draw coupon payment bar with enhanced gradient
                    if (data.couponPayments[i] > 0) {
                        const couponHeight = Math.max(0, data.couponPayments[i] * yScale * couponProgress);
                        const couponY = Math.max(0, margin.top + height - couponHeight);
                        
                        // Safety check for valid coordinates
                        if (!isFinite(couponHeight) || !isFinite(couponY)) continue;
                        
                        // Create modern gradient for coupon payments
                        const couponGradient = ctx.createLinearGradient(x, Math.max(0, couponY), x, Math.max(0, couponY + couponHeight));
                        couponGradient.addColorStop(0, '#6366f1');  // Modern indigo top
                        couponGradient.addColorStop(0.4, '#4f46e5'); // Main indigo
                        couponGradient.addColorStop(0.8, '#4338ca'); // Darker indigo
                        couponGradient.addColorStop(1, '#3730a3');   // Darkest indigo bottom
                        
                        ctx.fillStyle = couponGradient;
                        ctx.fillRect(x, couponY, barWidth, couponHeight);
                        
                        // Add modern highlight at top
                        const highlightGradient = ctx.createLinearGradient(x, Math.max(0, couponY), x, Math.max(0, couponY + 8));
                        highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
                        highlightGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.1)');
                        highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                        ctx.fillStyle = highlightGradient;
                        ctx.fillRect(x, couponY, barWidth, 8);
                        
                        // Add subtle shadow effect
                        ctx.shadowColor = colors.shadow;
                        ctx.shadowBlur = 4;
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 2;
                        
                        // Add modern border
                        ctx.strokeStyle = '#3730a3';
                        ctx.lineWidth = 0.5;
                        ctx.strokeRect(x, couponY, barWidth, couponHeight);
                        
                        // Reset shadow
                        ctx.shadowColor = 'transparent';
                        ctx.shadowBlur = 0;
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 0;
                        
                        // Show coupon value for all bars
                        if (animationProgress > 0.7) {
                            const labelOpacity = Math.min((animationProgress - 0.7) / 0.3, 1);
                            ctx.fillStyle = `rgba(102, 126, 234, ${labelOpacity})`;
                            ctx.font = 'bold 12px Inter, sans-serif';
                            ctx.textAlign = 'center';
                            ctx.fillText(data.couponPayments[i].toFixed(1) + '%', x + barWidth/2, couponY - 5);
                        }
                    }
                    
                                            // Draw principal payment bar (stacked on top) with enhanced gradient
                        if (data.principalPayments[i] > 0) {
                        const couponHeight = Math.max(0, data.couponPayments[i] * yScale * couponProgress);
                        const principalHeight = Math.max(0, data.principalPayments[i] * yScale * principalProgress);
                        const principalY = Math.max(0, margin.top + height - couponHeight - principalHeight);
                        
                        // Safety check for valid coordinates
                        if (!isFinite(principalHeight) || !isFinite(principalY)) continue;
                        
                        // Create modern gradient for principal payments
                        const principalGradient = ctx.createLinearGradient(x, Math.max(0, principalY), x, Math.max(0, principalY + principalHeight));
                        principalGradient.addColorStop(0, '#8b5cf6');  // Modern violet top
                        principalGradient.addColorStop(0.4, '#7c3aed'); // Main violet
                        principalGradient.addColorStop(0.8, '#6d28d9'); // Darker violet
                        principalGradient.addColorStop(1, '#5b21b6');   // Darkest violet bottom
                        
                        ctx.fillStyle = principalGradient;
                        ctx.fillRect(x, principalY, barWidth, principalHeight);
                        
                        // Add modern highlight at top
                        const highlightGradient = ctx.createLinearGradient(x, Math.max(0, principalY), x, Math.max(0, principalY + 8));
                        highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
                        highlightGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.1)');
                        highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                        ctx.fillStyle = highlightGradient;
                        ctx.fillRect(x, principalY, barWidth, 8);
                        
                        // Add subtle shadow effect
                        ctx.shadowColor = colors.shadow;
                        ctx.shadowBlur = 4;
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 2;
                        
                        // Add modern border with special highlighting for amortization payments
                        ctx.strokeStyle = '#5b21b6';
                        ctx.lineWidth = data.principalPayments[i] > 0 ? 2 : 0.5; // Thicker border for amortization
                        ctx.strokeRect(x, principalY, barWidth, principalHeight);
                        

                        
                        // Reset shadow
                        ctx.shadowColor = 'transparent';
                        ctx.shadowBlur = 0;
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 0;
                        
                        // Add principal value label for amortization payments
                        if (animationProgress > 0.7) {
                            const labelOpacity = Math.min((animationProgress - 0.7) / 0.3, 1);
                            ctx.fillStyle = `rgba(118, 75, 162, ${labelOpacity})`;
                            ctx.font = 'bold 12px Inter, sans-serif';
                            ctx.textAlign = 'center';
                            const totalValue = data.couponPayments[i] + data.principalPayments[i];
                            // Align label top with y-scale exactly so it matches axis visually
                            const totalHeight = Math.max(0, totalValue * yScale);
                            const totalY = Math.max(0, margin.top + height - totalHeight);
                            
                            // Show principal amount for amortization payments
                            if (data.principalPayments[i] > 0) {
                                ctx.fillText(data.principalPayments[i].toFixed(1) + '%', x + barWidth/2, totalY - 5);
                            }
                        }
                    }
                }
                
                // Draw axes with modern fintech style
                ctx.strokeStyle = '#4f46e5';
                ctx.lineWidth = 2;
                
                // X-axis
                ctx.beginPath();
                ctx.moveTo(margin.left, margin.top + height);
                ctx.lineTo(margin.left + width, margin.top + height);
                ctx.stroke();
                
                // Y-axis
                ctx.beginPath();
                ctx.moveTo(margin.left, margin.top);
                ctx.lineTo(margin.left, margin.top + height);
                ctx.stroke();
                
                // Draw labels with smaller font
                ctx.fillStyle = colors.text;
                ctx.font = '10px Inter, sans-serif';
                ctx.textAlign = 'center';
                
                // X-axis labels - horizontal
                for (let i = 0; i < data.dates.length; i++) {
                    const x = margin.left + 50 + i * xScale;
                    const y = margin.top + height + 20;
                    
                    // Horizontal text
                    ctx.fillText(data.dates[i], x, y);
                }
                
                // Y-axis labels - 10% scale with proper spacing
                ctx.textAlign = 'right';
                ctx.font = '9px Inter, sans-serif';
                
                for (let i = 0; i <= intervals; i++) {
                    const value = yMax - (i * 10);
                    if (value >= 0) {
                        const y = margin.top + (height / intervals) * i;
                        ctx.fillText(value.toFixed(0) + '%', margin.left - 5, y + 3);
                    }
                }
                
                // Draw title with modern fintech style and gradient
                if (animationProgress > 0.3) { // Show title after 30% animation
                    const titleOpacity = Math.min((animationProgress - 0.3) / 0.7, 1);
                    ctx.font = 'bold 18px Inter, sans-serif';
                    ctx.textAlign = 'center';
                    
                    // Create gradient for title text with opacity
                    const titleGradient = ctx.createLinearGradient(canvas.width / 2 - 100, margin.top - 15, canvas.width / 2 + 100, margin.top - 15);
                    titleGradient.addColorStop(0, `rgba(79, 70, 229, ${titleOpacity})`);   // Modern indigo
                    titleGradient.addColorStop(0.3, `rgba(99, 102, 241, ${titleOpacity})`); // Lighter indigo
                    titleGradient.addColorStop(0.7, `rgba(139, 92, 246, ${titleOpacity})`); // Violet
                    titleGradient.addColorStop(1, `rgba(124, 58, 237, ${titleOpacity})`);   // Modern violet
                    
                    ctx.fillStyle = titleGradient;
                    const titleText = this.cashFlowChartData && this.cashFlowChartData.isPartialAmortization ? 
                        'Bond Cash Flow Chart (Partial Amortization)' : 'Bond Cash Flow Chart';
                    ctx.fillText(titleText, canvas.width / 2, margin.top - 15);
                }
                
                // Draw axis titles with modern fintech style
                ctx.font = '12px Inter, sans-serif';
                ctx.fillStyle = '#4f46e5';
                ctx.fillText('Payment Date', canvas.width / 2, margin.top + height + 35);
                
                ctx.save();
                ctx.translate(margin.left - 35, canvas.height / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.font = '12px Inter, sans-serif';
                ctx.fillText('Payment Amount (%)', 0, 0);
                ctx.restore();
                
                // Draw legend with fintech style
                const legendY = margin.top + height + 50;
                const legendX = margin.left;
                
                // Coupon payments legend with modern gradient
                const legendGradient1 = ctx.createLinearGradient(legendX, legendY, legendX + 20, legendY + 15);
                legendGradient1.addColorStop(0, '#6366f1');
                legendGradient1.addColorStop(0.5, '#4f46e5');
                legendGradient1.addColorStop(1, '#3730a3');
                ctx.fillStyle = legendGradient1;
                ctx.fillRect(legendX, legendY, 20, 15);
                ctx.strokeStyle = '#3730a3';
                ctx.strokeRect(legendX, legendY, 20, 15);
                ctx.fillStyle = '#4f46e5';
                ctx.font = '11px Inter, sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText('Coupon Payments', legendX + 30, legendY + 12);
                
                // Principal payments legend with modern gradient
                const legendGradient2 = ctx.createLinearGradient(legendX + 150, legendY, legendX + 170, legendY + 15);
                legendGradient2.addColorStop(0, '#8b5cf6');
                legendGradient2.addColorStop(0.5, '#7c3aed');
                legendGradient2.addColorStop(1, '#5b21b6');
                ctx.fillStyle = legendGradient2;
                ctx.fillRect(legendX + 150, legendY, 20, 15);
                ctx.strokeStyle = '#5b21b6';
                ctx.lineWidth = 2; // Thicker border to match amortization bars
                ctx.strokeRect(legendX + 150, legendY, 20, 15);
                ctx.lineWidth = 0.5; // Reset line width
                ctx.fillStyle = '#7c3aed';
                ctx.font = '11px Inter, sans-serif';
                ctx.fillText('Principal Payments (Amortization)', legendX + 180, legendY + 12);
            }

            getFutureCouponDates(issueDate, frequency, currentDate, periodsToMaturity) {
                const issue = new Date(issueDate);
                const current = new Date(currentDate);
                const paymentsPerYear = this.getPaymentsPerYear(frequency);
                const monthsBetweenPayments = 12 / paymentsPerYear;
                
                let nextCoupon = new Date(issue);
                
                // Find the next coupon date after current date
                while (nextCoupon <= current) {
                    nextCoupon.setMonth(nextCoupon.getMonth() + monthsBetweenPayments);
                }
                
                const futureDates = [];
                
                // Generate all future coupon dates
                for (let i = 0; i < periodsToMaturity; i++) {
                    const couponDate = new Date(nextCoupon);
                    couponDate.setMonth(couponDate.getMonth() + (i * monthsBetweenPayments));
                    futureDates.push(couponDate);
                }
                
                return futureDates;
            }

            displayBondResults(metrics, bondData) {
                const resultsSection = document.getElementById('bondResultsSection');
                const resultsContent = document.getElementById('bondResults');
                
                // Format maturity date
                const maturityDate = new Date(bondData.maturityDate).toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric'
                });
                
                // Compute Investment Total Return (USD and %)
                const totalReturnPct = Number(metrics.totalReturn) || 0; // percent value
                const investedUsd = Number(bondData.investmentAmount) || 0;
                const totalReturnUsd = investedUsd * (totalReturnPct / 100);
                const totalReturnUsdStr = `${totalReturnUsd >= 0 ? '+' : ''}${totalReturnUsd.toLocaleString('en-US', { style: 'currency', currency: 'USD' })}`;
                const totalReturnPctStr = `${totalReturnPct >= 0 ? '+' : ''}${totalReturnPct.toFixed(2)}%`;
                
                const html = `
                    <!-- Bond Identification Header -->
                    <div style="background: linear-gradient(135deg, #667eea, #764ba2); color: white; padding: 25px; border-radius: 15px; margin-bottom: 30px; text-align: center; box-shadow: 0 8px 25px rgba(0,0,0,0.2);">
                        <h3 style="margin: 0 0 15px 0; font-size: 24px; font-weight: 700;">
                            <i class="fas fa-certificate"></i> Bond Identification
                        </h3>
                        <div style="display: flex; justify-content: center; gap: 40px; flex-wrap: wrap; font-size: 18px; font-weight: 600;">
                            <div>
                                <i class="fas fa-building"></i> ${bondData.company}
                    </div>
                            <div>
                                <i class="fas fa-percentage"></i> ${(bondData.coupon * 100).toFixed(2)}%
                    </div>
                            <div>
                                <i class="fas fa-calendar-alt"></i> ${maturityDate}
                    </div>
                        </div>
                    </div>

                    
                    
                    <!-- Bond Metrics Table -->
                    <div style="background: white; border-radius: 15px; padding: 25px; box-shadow: 0 4px 20px rgba(0,0,0,0.1); border: 1px solid #e1e5e9; overflow-x: auto;">
                        <h4 style="margin: 0 0 20px 0; font-size: 20px; font-weight: 600; color: #333; text-align: center;">
                            <i class="fas fa-chart-line"></i> Bond Analysis Results
                        </h4>
                        
                        <table style="width: 100%; border-collapse: collapse; font-size: 16px;">
                            <thead>
                                <tr style="background: linear-gradient(135deg, #667eea, #764ba2); color: white;">
                                    <th style="padding: 15px; text-align: center; border-radius: 8px 0 0 0; font-weight: 600;">Clean Price</th>
                                    <th style="padding: 15px; text-align: center; font-weight: 600;">Accrued Interest</th>
                                    <th style="padding: 15px; text-align: center; font-weight: 600;">Dirty Price</th>
                                    <th style="padding: 15px; text-align: center; font-weight: 600;">Current Yield</th>
                                    <th style="padding: 15px; text-align: center; font-weight: 600;">Duration</th>
                                    <th style="padding: 15px; text-align: center; font-weight: 600;">MD</th>
                                    <th style="padding: 15px; text-align: center; font-weight: 600;">Convexity</th>
                                    <th style="padding: 15px; text-align: center; font-weight: 600;">YTM</th>
                                    <th style="padding: 15px; text-align: center; border-radius: 0 8px 0 0; font-weight: 600;">Parity</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr style="border-bottom: 1px solid #e1e5e9;">
                                    <td style="padding: 15px; text-align: center; font-weight: 600; color: #667eea; font-size: 18px;">
                                        ${(bondData.actualPrice * 100).toFixed(2)}%
                                    </td>
                                    <td style="padding: 15px; text-align: center; font-weight: 600; color: #00bcd4; font-size: 18px;">
                                        ${(this.calculateAccruedInterest(bondData, bondData.liquidationDate) * 100).toFixed(2)}%
                                    </td>
                                    <td style="padding: 15px; text-align: center; font-weight: 600; color: #4caf50; font-size: 18px;">
                                        ${(this.calculateDirtyPrice(bondData) * 100).toFixed(2)}%
                                    </td>
                                    <td style="padding: 15px; text-align: center; font-weight: 600; color: #2ed573; font-size: 18px;">
                                        ${metrics.currentYield.toFixed(2)}%
                                    </td>
                                    <td style="padding: 15px; text-align: center; font-weight: 600; color: #ffa726; font-size: 18px;">
                                        ${metrics.macaulayDuration.toFixed(2)}
                                    </td>
                                    <td style="padding: 15px; text-align: center; font-weight: 600; color: #ffa726; font-size: 18px;">
                                        ${metrics.modifiedDuration.toFixed(2)}
                                    </td>
                                    <td style="padding: 15px; text-align: center; font-weight: 600; color: #ff9800; font-size: 18px;">
                                        ${metrics.convexity.toFixed(2)}
                                    </td>
                                    <td style="padding: 15px; text-align: center; font-weight: 600; color: #ff6b6b; font-size: 18px;">
                                        ${(metrics.ytm * 100).toFixed(2)}%
                                    </td>
                                    <td style="padding: 15px; text-align: center; font-weight: 600; color: #9c27b0; font-size: 18px;">
                                        ${metrics.parity.toFixed(2)}
                                    </td>
                                </tr>
                            </tbody>
                        </table>

                        <!-- Investment Total Return: placed inside results container, below the metrics table -->
                        <div style="margin-top: 20px; padding: 18px; background: #ffffff; border: 1px solid #e1e5e9; border-radius: 10px;">
                            <div style="display: flex; justify-content: center; gap: 40px; flex-wrap: wrap;">
                                <div style="font-size: 16px; font-weight: 700;">
                                    <span style="color:#2ed573;">Total Return (USD):</span>
                                    <span style="margin-left: 8px; font-weight: 600; color: #2ed573; letter-spacing: 0.2px; opacity: 0.95;">${totalReturnUsdStr}</span>
                                </div>
                                <div style="font-size: 16px; font-weight: 700;">
                                    <span style="color:#2ed573;">Total Return (%):</span>
                                    <span style="margin-left: 8px; font-weight: 600; color: #2ed573; letter-spacing: 0.2px; opacity: 0.95;">${totalReturnPctStr}</span>
                                </div>
                            </div>
                        </div>

                        <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; font-size: 14px; color: #666;">
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                                <div><strong>Clean Price:</strong> Bond price without accrued interest as percentage of face value</div>
                                <div><strong>Accrued Interest:</strong> Interest accumulated since last coupon payment</div>
                                <div><strong>Dirty Price:</strong> Clean price plus accrued interest (total amount paid)</div>
                                <div><strong>Current Yield:</strong> Annual coupon payment divided by dirty price</div>
                                <div><strong>Duration:</strong> Weighted average time to receive all cash flows</div>
                                <div><strong>MD (Modified Duration):</strong> Duration adjusted for yield changes</div>
                                <div><strong>Convexity:</strong> Rate of change of duration with respect to yield</div>
                                <div><strong>YTM:</strong> Total return if bond is held to maturity (calculated using dirty price)</div>
                                <div><strong>Parity:</strong> Price relative to face value (100 = par)</div>
                            </div>
                    </div>
                    
                        <!-- Last Coupon Information -->
                        <div style="margin-top: 15px; padding: 15px; background: linear-gradient(135deg, #667eea, #764ba2); color: white; border-radius: 8px; font-size: 14px;">
                            <div style="text-align: center;">
                                <strong>Last Coupon Date:</strong> ${this.getLastCouponDate(bondData.issueDate, bondData.frequency, bondData.liquidationDate).toLocaleDateString()}
                            </div>
                        </div>
                        
                        ${bondData.type === 'partial' && bondData.amortizationSchedule && bondData.amortizationSchedule.length > 0 ? `
                        <!-- Amortization Schedule Information -->
                        <div style="margin-top: 15px; padding: 15px; background: linear-gradient(135deg, #00b894, #00a085); color: white; border-radius: 8px; font-size: 14px;">
                            <div style="text-align: center; margin-bottom: 10px;">
                                <strong>Partial Amortization Schedule</strong>
                            </div>
                            <div style="text-align: center; margin-bottom: 15px; font-size: 16px; font-weight: 600;">
                                Total Amortization: ${(bondData.amortizationSchedule.reduce((sum, amort) => sum + amort.percentage, 0) * 100).toFixed(2)}%
                            </div>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; font-size: 12px;">
                                ${bondData.amortizationSchedule.map(amort => `
                                    <div style="text-align: center; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 6px;">
                                        <div><strong>Date:</strong> ${amort.date.toLocaleDateString()}</div>
                                        <div><strong>Amount:</strong> ${(amort.percentage * 100).toFixed(2)}%</div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        ` : ''}
                    </div>

                    <!-- Bond Cash Flow Table -->
                    <div style="background: white; border-radius: 15px; padding: 25px; box-shadow: 0 4px 20px rgba(0,0,0,0.1); border: 1px solid #e1e5e9; margin-top: 30px; overflow-x: auto;">
                        <h4 style="margin: 0 0 20px 0; font-size: 20px; font-weight: 600; color: #333; text-align: center;">
                            <i class="fas fa-calculator"></i> Bond Cash Flow Schedule
                        </h4>
                        
                        ${this.generateCashFlowTable(bondData, metrics.ytm, metrics.yearsToMaturity, metrics.paymentsPerYear)}
                    </div>
                `;
                
                resultsContent.innerHTML = html;
                resultsSection.style.display = 'block';
                
                // Scroll to results
                resultsSection.scrollIntoView({ behavior: 'smooth' });
                
                this.showSuccess('Bond metrics calculated successfully!');
            }

            // Bond Portfolio Management Methods
            addBondToPortfolio() {
                try {
                    // Validate required fields
                    const requiredFields = [
                        'bondCompany', 'bondCoupon', 'bondIssueDate', 'bondMaturityDate',
                        'bondInvestmentAmount', 'bondLiquidationDate', 'bondInitialPrice', 'bondActualPrice'
                    ];
                    
                    for (const fieldId of requiredFields) {
                        const field = document.getElementById(fieldId);
                        if (!field.value) {
                            this.showError(`Please fill in the ${fieldId.replace('bond', '').toLowerCase()} field`);
                            return;
                        }
                    }
                    
                    // Get form values and calculate metrics
                    const bondData = this.getBondFormData();
                    const metrics = this.performBondCalculations(bondData);
                    
                    // Create unique bond ID
                    const bondId = `${bondData.company}_${bondData.issueDate.getTime()}`;
                    
                    // Check if bond already exists
                    if (this.bondPortfolio.has(bondId)) {
                        this.showError('This bond is already in your portfolio');
                        return;
                    }
                    
                    // Add bond to portfolio
                    this.bondPortfolio.set(bondId, {
                        id: bondId,
                        data: bondData,
                        metrics: metrics,
                        addedDate: new Date()
                    });
                    
                    // Save and render
                    this.saveBondPortfolio();
                    this.renderBondPortfolio();
                    
                    this.showSuccess(`Added ${bondData.company} bond to portfolio`);
                    
                } catch (error) {
                    console.error('Error adding bond to portfolio:', error);
                    this.showError('Error adding bond to portfolio: ' + error.message);
                }
            }

            removeBondFromPortfolio(bondId) {
                if (confirm('Are you sure you want to remove this bond from your portfolio?')) {
                    this.bondPortfolio.delete(bondId);
                    this.saveBondPortfolio();
                    this.renderBondPortfolio();
                    this.showSuccess('Bond removed from portfolio');
                }
            }

            loadBondPortfolio() {
                try {
                    const saved = localStorage.getItem('bondPortfolio');
                    if (saved) {
                        const portfolioData = JSON.parse(saved);
                        this.bondPortfolio = new Map();
                        
                        for (const [key, value] of Object.entries(portfolioData)) {
                            // Convert dates back to Date objects
                            value.data.issueDate = new Date(value.data.issueDate);
                            value.data.maturityDate = new Date(value.data.maturityDate);
                            value.data.liquidationDate = new Date(value.data.liquidationDate);
                            value.addedDate = new Date(value.addedDate);
                            
                            if (value.data.amortizationSchedule) {
                                value.data.amortizationSchedule = value.data.amortizationSchedule.map(item => ({
                                    ...item,
                                    date: new Date(item.date)
                                }));
                            }
                            
                            this.bondPortfolio.set(key, value);
                        }
                        console.log('Bond portfolio loaded:', this.bondPortfolio.size, 'bonds');
                    }
                } catch (error) {
                    console.error('Error loading bond portfolio:', error);
                }
            }

            saveBondPortfolio() {
                try {
                    const portfolioData = {};
                    for (const [key, value] of this.bondPortfolio) {
                        portfolioData[key] = value;
                    }
                    localStorage.setItem('bondPortfolio', JSON.stringify(portfolioData));
                } catch (error) {
                    console.error('Error saving bond portfolio:', error);
                }
            }

            renderBondPortfolio() {
                const grid = document.getElementById('bondPortfolioGrid');
                const selectionControls = document.getElementById('bondSelectionControls');
                
                if (this.bondPortfolio.size === 0) {
                    grid.innerHTML = `
                        <div class="empty-bond-portfolio">
                            <i class="fas fa-briefcase"></i>
                            <h3>Your bond portfolio is empty</h3>
                            <p>Calculate bond metrics above and add them to your portfolio for comparison</p>
                        </div>
                    `;
                    selectionControls.style.display = 'none';
                    return;
                }

                // Show selection controls
                selectionControls.style.display = 'flex';
                
                // Update bond selection dropdowns
                this.updateBondSelectionDropdowns();
                
                // Render bond portfolio as table instead of individual cards
                grid.innerHTML = `
                    <table class="bond-portfolio-table">
                        <thead>
                            <tr>
                                <th>Company</th>
                                <th>Maturity Date</th>
                                <th>Coupon Rate</th>
                                <th>Modified Duration</th>
                                <th>YTM</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${Array.from(this.bondPortfolio.entries()).map(([bondId, bond]) => {
                                const metrics = bond.metrics;
                                const data = bond.data;
                                return `
                                    <tr>
                                        <td class="bond-company">${data.company}</td>
                                        <td class="bond-maturity">${data.maturityDate.toLocaleDateString()}</td>
                                        <td class="bond-metric-grey">${(data.coupon * 100).toFixed(2)}%</td>
                                        <td class="bond-metric-grey">${metrics.macaulayDuration.toFixed(2)}</td>
                                        <td class="bond-metric">${(metrics.ytm * 100).toFixed(2)}%</td>
                                        <td>
                                            <div class="bond-actions">
                                                <button class="bond-action-btn compare" onclick="portfolio.selectBondForComparison('${bondId}')" title="Select for comparison">
                                                    <i class="fas fa-balance-scale"></i>
                                                </button>
                                                <button class="bond-action-btn remove" onclick="portfolio.removeBondFromPortfolio('${bondId}')" title="Remove from portfolio">
                                                    <i class="fas fa-trash"></i>
                                                </button>
                                            </div>
                                        </td>
                                    </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                `;
            }

            createBondCard(bond, bondId) {
                const card = document.createElement('div');
                card.className = 'bond-card';
                
                const metrics = bond.metrics;
                const data = bond.data;
                
                card.innerHTML = `
                    <div class="bond-card-header">
                        <div class="bond-company">${data.company}</div>
                        <div class="bond-actions">
                            <button class="bond-action-btn compare" onclick="portfolio.selectBondForComparison('${bondId}')" title="Select for comparison">
                                <i class="fas fa-balance-scale"></i>
                            </button>
                            <button class="bond-action-btn remove" onclick="portfolio.removeBondFromPortfolio('${bondId}')" title="Remove from portfolio">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    </div>
                    
                    <div class="bond-metrics-grid">
                        <div class="bond-metric-item">
                            <div class="bond-metric-value">${(data.coupon * 100).toFixed(2)}%</div>
                            <div class="bond-metric-label">Coupon Rate</div>
                        </div>
                        <div class="bond-metric-item">
                            <div class="bond-metric-value">${(metrics.ytm * 100).toFixed(2)}%</div>
                            <div class="bond-metric-label">YTM</div>
                        </div>
                        <div class="bond-metric-item">
                            <div class="bond-metric-value">${metrics.macaulayDuration.toFixed(2)}</div>
                            <div class="bond-metric-label">Duration</div>
                        </div>
                        <div class="bond-metric-item">
                            <div class="bond-metric-value">${(metrics.currentYield * 100).toFixed(2)}%</div>
                            <div class="bond-metric-label">Current Yield</div>
                        </div>
                    </div>
                    
                    <div style="font-size: 0.9rem; color: #666; margin-top: 10px;">
                        <div>Maturity: ${data.maturityDate.toLocaleDateString()}</div>
                        <div>Added: ${bond.addedDate.toLocaleDateString()}</div>
                    </div>
                `;
                
                return card;
            }

            updateBondSelectionDropdowns() {
                const bond1Select = document.getElementById('bond1Select');
                const bond2Select = document.getElementById('bond2Select');
                
                // Clear existing options
                bond1Select.innerHTML = '<option value="">Choose a bond...</option>';
                bond2Select.innerHTML = '<option value="">Choose a bond...</option>';
                
                // Add bond options
                this.bondPortfolio.forEach((bond, bondId) => {
                    const option1 = document.createElement('option');
                    option1.value = bondId;
                    option1.textContent = `${bond.data.company} (${(bond.data.coupon * 100).toFixed(2)}%)`;
                    bond1Select.appendChild(option1);
                    
                    const option2 = document.createElement('option');
                    option2.value = bondId;
                    option2.textContent = `${bond.data.company} (${(bond.data.coupon * 100).toFixed(2)}%)`;
                    bond2Select.appendChild(option2);
                });
            }

            updateCompareButton() {
                const bond1Select = document.getElementById('bond1Select');
                const bond2Select = document.getElementById('bond2Select');
                const compareBtn = document.getElementById('compareBondsBtn');
                
                const bond1Selected = bond1Select.value;
                const bond2Selected = bond2Select.value;
                
                if (bond1Selected && bond2Selected && bond1Selected !== bond2Selected) {
                    compareBtn.disabled = false;
                } else {
                    compareBtn.disabled = true;
                }
            }

            selectBondForComparison(bondId) {
                const bond1Select = document.getElementById('bond1Select');
                const bond2Select = document.getElementById('bond2Select');
                
                // Auto-select the bond in the first available dropdown
                if (!bond1Select.value) {
                    bond1Select.value = bondId;
                } else if (!bond2Select.value && bond1Select.value !== bondId) {
                    bond2Select.value = bondId;
                } else if (bond1Select.value !== bondId && bond2Select.value !== bondId) {
                    // If both are filled, replace the second one
                    bond2Select.value = bondId;
                }
                
                this.updateCompareButton();
            }

            compareBonds() {
                const bond1Id = document.getElementById('bond1Select').value;
                const bond2Id = document.getElementById('bond2Select').value;
                
                if (!bond1Id || !bond2Id || bond1Id === bond2Id) {
                    this.showError('Please select two different bonds to compare');
                    return;
                }
                
                const bond1 = this.bondPortfolio.get(bond1Id);
                const bond2 = this.bondPortfolio.get(bond2Id);
                
                if (!bond1 || !bond2) {
                    this.showError('Selected bonds not found');
                    return;
                }
                
                this.displayBondComparison(bond1, bond2);
            }

            displayBondComparison(bond1, bond2) {
                const comparisonSection = document.getElementById('bondComparisonSection');
                const comparisonContent = document.getElementById('bondComparisonContent');
                
                const metrics1 = bond1.metrics;
                const metrics2 = bond2.metrics;
                const data1 = bond1.data;
                const data2 = bond2.data;
                
                // Calculate comparison metrics
                const yieldSpread = Math.abs(metrics1.ytm - metrics2.ytm) * 100;
                const durationDiff = Math.abs(metrics1.macaulayDuration - metrics2.macaulayDuration);
                const priceSensitivity1 = metrics1.modifiedDuration * 0.01; // 1% rate change
                const priceSensitivity2 = metrics2.modifiedDuration * 0.01;
                
                // Determine which metrics are better (higher YTM, lower duration for same risk)
                const ytmBetter = metrics1.ytm > metrics2.ytm ? 'bond1' : 'bond2';
                const durationBetter = metrics1.macaulayDuration < metrics2.macaulayDuration ? 'bond1' : 'bond2';
                
                const html = `
                    <div class="comparison-container">
                        <div class="comparison-grid">
                            <div class="comparison-bond-card">
                                <div class="comparison-bond-header">
                                    <div class="comparison-bond-company">${data1.company}</div>
                                    <div class="comparison-bond-details">
                                        ${(data1.coupon * 100).toFixed(2)}% Coupon | ${data1.maturityDate.toLocaleDateString()}
                                    </div>
                                </div>
                                
                                <table class="comparison-metrics-table">
                                    <thead>
                                        <tr>
                                            <th>Metric</th>
                                            <th>Value</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td>YTM</td>
                                            <td class="${ytmBetter === 'bond1' ? 'better' : 'worse'}">${(metrics1.ytm * 100).toFixed(2)}%</td>
                                        </tr>
                                        <tr>
                                            <td>Duration</td>
                                            <td class="${durationBetter === 'bond1' ? 'better' : 'worse'}">${metrics1.macaulayDuration.toFixed(2)}</td>
                                        </tr>
                                        <tr>
                                            <td>Modified Duration</td>
                                            <td>${metrics1.modifiedDuration.toFixed(2)}</td>
                                        </tr>
                                        <tr>
                                            <td>Convexity</td>
                                            <td>${metrics1.convexity.toFixed(2)}</td>
                                        </tr>
                                        <tr>
                                            <td>Current Yield</td>
                                            <td>${(metrics1.currentYield * 100).toFixed(2)}%</td>
                                        </tr>
                                        <tr>
                                            <td>Price Sensitivity</td>
                                            <td>${(priceSensitivity1 * 100).toFixed(2)}%</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                            
                            <div class="comparison-bond-card">
                                <div class="comparison-bond-header">
                                    <div class="comparison-bond-company">${data2.company}</div>
                                    <div class="comparison-bond-details">
                                        ${(data2.coupon * 100).toFixed(2)}% Coupon | ${data2.maturityDate.toLocaleDateString()}
                                    </div>
                                </div>
                                
                                <table class="comparison-metrics-table">
                                    <thead>
                                        <tr>
                                            <th>Metric</th>
                                            <th>Value</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td>YTM</td>
                                            <td class="${ytmBetter === 'bond2' ? 'better' : 'worse'}">${(metrics2.ytm * 100).toFixed(2)}%</td>
                                        </tr>
                                        <tr>
                                            <td>Duration</td>
                                            <td class="${durationBetter === 'bond2' ? 'better' : 'worse'}">${metrics2.macaulayDuration.toFixed(2)}</td>
                                        </tr>
                                        <tr>
                                            <td>Modified Duration</td>
                                            <td>${metrics2.modifiedDuration.toFixed(2)}</td>
                                        </tr>
                                        <tr>
                                            <td>Convexity</td>
                                            <td>${metrics2.convexity.toFixed(2)}</td>
                                        </tr>
                                        <tr>
                                            <td>Current Yield</td>
                                            <td>${(metrics2.currentYield * 100).toFixed(2)}%</td>
                                        </tr>
                                        <tr>
                                            <td>Price Sensitivity</td>
                                            <td>${(priceSensitivity2 * 100).toFixed(2)}%</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        
                        <div class="comparison-summary">
                            <h4>📊 Comparison Summary</h4>
                            <div class="comparison-summary-grid">
                                <div class="comparison-summary-item">
                                    <div class="comparison-summary-value">${yieldSpread.toFixed(2)}%</div>
                                    <div class="comparison-summary-label">Yield Spread</div>
                                </div>
                                <div class="comparison-summary-item">
                                    <div class="comparison-summary-value">${durationDiff.toFixed(2)}</div>
                                    <div class="comparison-summary-label">Duration Difference</div>
                                </div>
                                <div class="comparison-summary-item">
                                    <div class="comparison-summary-value">${Math.abs(priceSensitivity1 - priceSensitivity2).toFixed(2)}%</div>
                                    <div class="comparison-summary-label">Price Sensitivity Diff</div>
                                </div>
                                <div class="comparison-summary-item">
                                    <div class="comparison-summary-value">${ytmBetter === 'bond1' ? data1.company : data2.company}</div>
                                    <div class="comparison-summary-label">Higher YTM</div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="comparison-charts">
                            <h4 style="margin-bottom: 20px; text-align: center;">📈 Cash Flow Comparison</h4>
                            <div id="comparisonCashFlowChart" class="comparison-chart-container"></div>
                        </div>
                    </div>
                `;
                
                comparisonContent.innerHTML = html;
                comparisonSection.style.display = 'block';
                
                // Generate comparison cash flow chart
                this.generateComparisonCashFlowChart(bond1, bond2);
                
                // Scroll to comparison
                comparisonSection.scrollIntoView({ behavior: 'smooth' });
            }

            generateComparisonCashFlowChart(bond1, bond2) {
                // Generate future cash flows only (no initial investment)
                const futureCashFlows1 = this.generateFutureCashFlows(bond1.data, bond1.metrics.yearsToMaturity, bond1.metrics.paymentsPerYear);
                const futureCashFlows2 = this.generateFutureCashFlows(bond2.data, bond2.metrics.yearsToMaturity, bond2.metrics.paymentsPerYear);
                
                const futureDates1 = this.generateFutureCashFlowDates(bond1.data, bond1.metrics.yearsToMaturity, bond1.metrics.paymentsPerYear);
                const futureDates2 = this.generateFutureCashFlowDates(bond2.data, bond2.metrics.yearsToMaturity, bond2.metrics.paymentsPerYear);
                
                // Create separate traces for coupon and principal payments for better visualization
                const createSeparateTraces = (cashFlows, dates, bondData, color) => {
                    const couponPayments = [];
                    const principalPayments = [];
                    const couponDates = [];
                    const principalDates = [];
                    
                    const couponPayment = bondData.coupon / bond1.metrics.paymentsPerYear;
                    
                    for (let i = 0; i < cashFlows.length; i++) {
                        const totalPayment = cashFlows[i];
                        const principalPart = totalPayment - couponPayment;
                        
                        // Always add coupon payment
                        couponPayments.push(couponPayment);
                        couponDates.push(new Date(dates[i]));
                        
                        // Add principal payment if it exists
                        if (principalPart > 0) {
                            principalPayments.push(principalPart);
                            principalDates.push(new Date(dates[i]));
                        }
                    }
                    
                    return {
                        couponTrace: {
                            x: couponDates,
                            y: couponPayments,
                            type: 'bar',
                            name: 'Coupon',
                            marker: { 
                                color: color,
                                opacity: 0.6
                            }
                        },
                        principalTrace: {
                            x: principalDates,
                            y: principalPayments,
                            type: 'bar',
                            name: 'Principal',
                            marker: { 
                                color: color.replace('0.6', '1'),
                                opacity: 0.9
                            }
                        }
                    };
                };
                
                const traces1 = createSeparateTraces(futureCashFlows1, futureDates1, bond1.data, '#667eea');
                const traces2 = createSeparateTraces(futureCashFlows2, futureDates2, bond2.data, '#00b894');
                
                // Create subplot layout for two separate charts
                const isDark = this.isDarkMode;
                
                // Use separate traces for coupon and principal payments
                const trace1Coupon = {
                    ...traces1.couponTrace,
                    xaxis: 'x',
                    yaxis: 'y',
                    name: bond1.data.company + ' - Coupon'
                };
                
                const trace1Principal = {
                    ...traces1.principalTrace,
                    xaxis: 'x',
                    yaxis: 'y',
                    name: bond1.data.company + ' - Principal'
                };
                
                const trace2Coupon = {
                    ...traces2.couponTrace,
                    xaxis: 'x2',
                    yaxis: 'y2',
                    name: bond2.data.company + ' - Coupon'
                };
                
                const trace2Principal = {
                    ...traces2.principalTrace,
                    xaxis: 'x2',
                    yaxis: 'y2',
                    name: bond2.data.company + ' - Principal'
                };
                
                const layout = {
                    title: 'Cash Flow Comparison',
                    grid: {
                        rows: 1,
                        columns: 2,
                        pattern: 'independent'
                    },
                    xaxis: { 
                        title: 'Date',
                        color: isDark ? '#ffffff' : '#333333',
                        gridcolor: isDark ? '#2a2a3a' : '#e1e5e9',
                        type: 'date',
                        domain: [0, 0.45]
                    },
                    xaxis2: { 
                        title: 'Date',
                        color: isDark ? '#ffffff' : '#333333',
                        gridcolor: isDark ? '#2a2a3a' : '#e1e5e9',
                        type: 'date',
                        domain: [0.55, 1]
                    },
                    yaxis: { 
                        title: 'Cash Flow ($)',
                        color: isDark ? '#ffffff' : '#333333',
                        gridcolor: isDark ? '#2a2a3a' : '#e1e5e9'
                    },
                    yaxis2: { 
                        title: 'Cash Flow ($)',
                        color: isDark ? '#ffffff' : '#333333',
                        gridcolor: isDark ? '#2a2a3a' : '#e1e5e9'
                    },
                    hovermode: 'closest',
                    showlegend: false,
                    plot_bgcolor: isDark ? '#1e1e2e' : '#ffffff',
                    paper_bgcolor: isDark ? '#1e1e2e' : '#ffffff',
                    font: { color: isDark ? '#ffffff' : '#333333' },
                    annotations: [
                        {
                            text: bond1.data.company,
                            x: 0.225,
                            y: 1.05,
                            xref: 'paper',
                            yref: 'paper',
                            showarrow: false,
                            font: { size: 16, color: isDark ? '#ffffff' : '#333333' }
                        },
                        {
                            text: bond2.data.company,
                            x: 0.775,
                            y: 1.05,
                            xref: 'paper',
                            yref: 'paper',
                            showarrow: false,
                            font: { size: 16, color: isDark ? '#ffffff' : '#333333' }
                        }
                    ]
                };
                
                Plotly.newPlot('comparisonCashFlowChart', [trace1Coupon, trace1Principal, trace2Coupon, trace2Principal], layout, {responsive: true});
            }

            // Dark Mode Methods
            initDarkMode() {
                // Load saved theme preference
                const savedTheme = localStorage.getItem('theme');
                if (savedTheme === 'dark') {
                    this.enableDarkMode();
                } else {
                    this.disableDarkMode();
                }
            }

            toggleDarkMode() {
                if (this.isDarkMode) {
                    this.disableDarkMode();
                } else {
                    this.enableDarkMode();
                }
            }

            enableDarkMode() {
                this.isDarkMode = true;
                document.documentElement.setAttribute('data-theme', 'dark');
                localStorage.setItem('theme', 'dark');
                
                const toggleBtn = document.getElementById('themeToggle');
                toggleBtn.innerHTML = '<i class="fas fa-sun"></i><span>Light Mode</span>';
                toggleBtn.classList.add('dark');
                
                // Update Plotly charts for dark mode
                this.updateChartsForDarkMode();
            }

            disableDarkMode() {
                this.isDarkMode = false;
                document.documentElement.removeAttribute('data-theme');
                localStorage.setItem('theme', 'light');
                
                const toggleBtn = document.getElementById('themeToggle');
                toggleBtn.innerHTML = '<i class="fas fa-moon"></i><span>Dark Mode</span>';
                toggleBtn.classList.remove('dark');
                
                // Update Plotly charts for light mode
                this.updateChartsForLightMode();
            }

            updateChartsForDarkMode() {
                // Update existing charts for dark mode
                const chartContainers = document.querySelectorAll('.comparison-chart-container, #comparisonCashFlowChart');
                chartContainers.forEach(container => {
                    if (container.children.length > 0) {
                        // Re-render charts with dark theme
                        Plotly.relayout(container, {
                            'plot_bgcolor': '#1e1e2e',
                            'paper_bgcolor': '#1e1e2e',
                            'font': { color: '#ffffff' },
                            'xaxis': { 
                                'color': '#ffffff',
                                'gridcolor': '#2a2a3a'
                            },
                            'yaxis': { 
                                'color': '#ffffff',
                                'gridcolor': '#2a2a3a'
                            }
                        });
                    }
                });
            }

            updateChartsForLightMode() {
                // Update existing charts for light mode
                const chartContainers = document.querySelectorAll('.comparison-chart-container, #comparisonCashFlowChart');
                chartContainers.forEach(container => {
                    if (container.children.length > 0) {
                        // Re-render charts with light theme
                        Plotly.relayout(container, {
                            'plot_bgcolor': '#ffffff',
                            'paper_bgcolor': '#ffffff',
                            'font': { color: '#333333' },
                            'xaxis': { 
                                'color': '#333333',
                                'gridcolor': '#e1e5e9'
                            },
                            'yaxis': { 
                                'color': '#333333',
                                'gridcolor': '#e1e5e9'
                            }
                        });
                    }
                });
            }

        }

        // Initialize the portfolio when the page loads
        const portfolio = new StockPortfolio();

        // Auto-update analyses if portfolio has data
        setTimeout(async () => {
            console.log('Page loaded successfully');
            console.log('Stock page visible:', document.getElementById('stocks-tab').style.display !== 'none');
            console.log('Bond calculator section found:', document.getElementById('bondCalculatorSection') !== null);
            
            // If portfolio has stocks, auto-update all analyses
            if (portfolio.portfolio.size > 0) {
                console.log('Portfolio has data, auto-updating analyses...');
                await portfolio.autoUpdateAllAnalyses();
            }
        }, 1000);
    </script>
</body>
</html>
